> 1. **AQS**

​		

1. **原理**

AQS是同步锁队列,用于解决多线程情境下锁分配的问题,获得锁线程再没有释放之前,没有获得到锁的线程处于等待队列中.

AQS对于锁的资源共享方式有独占方式和共享方式,即排它锁和共享锁.

常见的排它锁有`ReentrantLock`,可以有公平锁模式和非公平锁模式,公平锁需要按照队列中等待线程的顺序获取锁,性能差.

常见的共享锁有`Semaphora`,`CyclicBarrier`,`CountDownLatch`,`ReentranReadWriteLock`,可以允许多个线程的同时使用.

`CountdownLatch` 用于注册中心重启加载启动参数

`CyclicBarrier` 释放之后可以重新计数,而`CountDownLatch`不可以

> 2. **原子操作**

原子操作指的是不可再向下细分的操作,即再并发情况下操作的基本单位.

原子操作是最基本的操作,用于构建复杂的操作.常用有八种类型的原子操作,例如`storage`,`load`,`read`,`write`等,每种操作都会之间对相关的寄存器进行修改.

原子操作底层是基于CAS进行的,CAS即比较并在两者值不相等的时候修改,会出现ABA问题,通常使用时间戳唯一标定参数,从而解决ABA问题.

`JDK`中`Atomic`包含基本类型和引用类型的原子类.

> 3. **线程池**

1. 常用的线程池参数

+ corePoolSize 核心线程数量
+ maxPoolSize 最大线程数量
+ keepaliveTime 保持链接的时间
+ unit 时间的时间单位
+ waitingQueue 等待队列
+ handler 线程池饱和策略

2. 常用方法

   + `excute`执行不需要返回值的任务,无法判断是否执行完毕
   + `submit`执行需要返回值的任务, 返回一个`future`

3. 常用线程池

   + 定长线程池`FixedThreadPool`

   + 单线程线程池`SingleThreadPool`

   + 定时线程池`ScheduledThreadPoolExecutor `

   + 缓存线程池`CachedThreadPool `

     `corePoolSize=0 && maxPoolSize=Integer.MAX_VALUE`

> 4. **并发关键字**

 1. `synchronized`

    + **偏向锁**

      

      加锁过程:

      访问同步块的时候,只需要核对对象头中的偏向锁是否指向当前的线程,如果是且启用了偏向锁(设置了对应的状态位). 这表示获取锁成功. 如果没有启用偏向锁,则使用CAS的方式竞争锁的使用.如果启用了,但是偏向了其他的线程,则会使用CAS的方式将偏向锁重新指定到当前线程再访问.

      

      撤销过程:

      如果当前线程仍然存活,则将偏向锁改为偏向锁指向其他线程或者无锁状态.

      如果当前线程死亡,则修改为无锁状态.

      

    + **轻量级锁**

      一种介于偏向锁和重量级锁性能之间的锁, 使用CAS操作进行加锁和解锁,

      为了在锁竞争不大的情况下,减少向OS申请互斥量的开销. 一般同步的过程中发生竞争的可能性不大.当竞争大的时候会膨胀为重量级锁.

      

    + **自旋锁**

      在真正向OS发起中断请求之前,需要进行一段时间的自旋操作,如果这段时间获得了锁,则不用向OS申请挂起线程.自旋锁默认大小为10.

      

    + **锁消除**

      在编译期间,将不可能存在竞争代码块中消除锁,可以节省申请锁的时间.

      

    + **锁粗化**

      尽可能将同步的范围缩小,从而减小持有锁的时间.

 2. `volatile`

> 5. **ThreadLocal**

线程本地变量,内部维护一个包私有`ThreadLocalMap`,用于存储本地线程的变量,存储的是一个弱引用,即垃圾回收的时候这个key就会被回收掉.

> 6. **并发容器**

1. CopyOnWriteArrayList

   提供主副本两份数据,修改对副本起效,并同步到主本供读取, 读写分离.

2. ConcurrentHashMap

   1.7之前使用分段锁`segment`来实现

   1.8之后使用`Node`来实现,并使用红黑树的结构进行组织

3. HashTable

   全表加锁,效率低下

4. LinkedBlockingQueue

   链表形式的阻塞队列

5. BlockingQueue

   阻塞队列,可以用来实现生产者消费者模式

> 7. **线程模型**