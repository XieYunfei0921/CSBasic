#### ZooKeeper 观察者

**观察者: 在不影响写性能的前提下对zookeeper进行扩展**

---

尽管zookeeper直连到客户端(全体投票成员)上效果比较好,这个结构很难横向扩展客户端.问题是一旦投票的成员增加,那么写性能就会下降.因为写操作需要超过半数节点的同意.因此随着投票者的增加这个开销会增加.

下面介绍一种新的zookeeper节点,叫做**观察者**.这个会提高zookeeper的扩展性.观察者不会参与投票,除此之外观察者表现的像个follower一样,客户端会连接到它们,并且对着它发送读写请求.观察者发送请求到leader,同时也会发送到follower上,但是观察者仅仅会监听投票的结果.正因为如此,如果不希望降低投票性能,需要增加观察者的数量.
观察者也有其他的优势,但是他们不会参与投票,它不是zookeeper的重要组成部分.它们的失败或者从集群中断开连接,不会对zookeeper服务操作降低.

为了对用户起到好处,观察者的网络连接要弱于follower.观察者可以与zookeeper服务器进行交互.客户端的观察者会快速读取,因为读取工作都是本地进行的,且写出结果的网络开销也会减少.

**观察者的使用方法**

创建带有观察者的zookeeper集群很简单,需要对配置文件进行两个改变.首先配置每个节点的配置文件为观察者

```shell
peerType=observer
```

这个配置会告诉zookeeper，这个服务器是一个观察者。其次，在每个服务器的配置文件中，必须添加`:observer`给观察者的定义中:

```shell
server.1:localhost:2181:3181:observer
```

这个告知了其他服务器`server.1`这个是一个观察者,且不应当参加投票.这个是你在zookeeper集群的操作.

现在可以连接到服务器.

```shell
$ bin/zkCli.sh -server localhost:2181
```

当`localhost:2181`是观察者的主机+端口号名称的时候,需要使用类型`/s`的指令查询zk服务.

**观察者Master的使用方法**

观察者函数仅仅是一个不会参与投票的成员,和follower共享`Learner `接口.且仅仅是不同的内部pipeline.但都是保持了Leader的`quorum`端口的连接,这个会模仿到所有的目标.

默认情况下,观察者连接到leader上,通过quorum(法定人数,这里理解为投票使用的端口)端口.这就是他们模仿leader的主要方式.允许观察者连接到Follower是有好处的.它会从leader中移除一些观察者的负担,并且关注与写的提交.

这意味着在leader处于高负载的情况下(尤其是在高网络负载,比如说leader选举之后,learn需要同步的时候),会提升性能.在大量观察者存在的情况下向,降低了leader网络的链接的保持量.

另一方面,观察者花费更短的时间完成同步,并且启动服务客户端.

这个特征可以让所有成员知道哪个端口会被follower使用,用于监听观察者的连接.下述配置,会添加到服务器的配置文件中,指导观察者连接端口2191,用于followers去创建观察者线程,用于监听这个端口.

```shell
observerMasterPort=2191
```
**简单使用**

下面的两个例子使用观察者监听,事实上,无论你是否需要**扩展zk客户端**,或者希望**隔离一些客户端请求的负载**,观察者都是好的选择.

+ **作为数据中心的桥梁**

  在两个数据中心之间构建zk是一个不确定的尝试,为在数据中心之间的潜伏的变量可能引发错误的失败检测和分区.

  但是如果在一个数据中心中运行,第二个数据中心作为观察者,分区就不会称为问题.

+ **作为消息总线的连接**:

  一些公司使用zk开发了持久化的消息总线.观察者可以到这个工作的自然的整合.使用插件原理连接指定的观察者锁监控的流。