## Zookeeper 配置

#### zookeeper高级设置

在这篇文章中，可以使用zk实现高级排序函数。这些都是客户端自己的实现,不需要zk的特殊支持.可以从客户端获取这些实现,并且鼓励标准化.

尽管zk是使用异步通知的机制,但是仍旧可以使用同步措施,比如队列或者锁.可以看到zk将所有的指令都保留处理.

注意到使用下述配置,用于最佳实践.特别地,为了避免轮询,计时,以及其他任何会导致羊群效应的操作,这样会限制系统的可扩容性能.

有许多这里没有使用的函数(**可恢复的读写优先锁**).特别地,考虑特别的情况,尽管可以找到其他的构造器,比如**事件处理**或者**队列**.总体来说,这个部分的示例用于模拟这类情况.

#### 关于错误处理的需要注意的内容

必须要手动处理可恢复的异常,特别地,多种配置会使用连续临时节点配置,当创建连续临时节点的时候.当服务器调用`create()`方法成功,但是服务器在返回节点名称给客户端时宕机的时候会引发错误.

当客户端重连会话的时候,节点没有被移除.**这个实现对于客户端来说很难直到节点是否创建与否**,下述配置就是用于处理这个问题的.

#### 命名服务,配置和组关系

**命名服务**和**配置**是两个zk重要的应用。这两个函数直接有zk的API实现。

另一个由zk直接提供的函数是**组关系**。这个组由一个节点表示，组成员在组节点下创建一个临时节点。当zk发现失败的时候，组成员会由于异常自动地移除。

#### 内存屏障

分布式系统使用**内存屏障**,用于阻塞节点集合,直到满足条件为止才能开始执行.**内存屏障**在zk中,通过设置一个屏障节点,如果屏障节点不存在,则会选择适当的位置.下面是伪代码:

1. 客户端在屏障节点上调用zk API`exist()`,观测器设置为true
2. 如果`exist()`返回false,那么内存屏障就会消失,客户端会继续进行.
3. 如果`exist()`返回true,客户端会等待zk的观测事件返回.
4. 如果触发了观测事件,客户端会重新发起`exist()`请求,重新等待屏障节点移除.

#### 双重内存屏障

双重内存屏障使得客户端同步了计算的起始和结束点.当足够的进程加入到内存屏障之后,进程会启动计算,且计算完成则离开内存屏障.这个配置显示了如何去使用zk节点作为内存屏障.

配置的伪代码称作`b`,每个客户端进程`p`进入的时候注册内存屏障节点,离开的时候解除注册.节点注册会通过下述表的形式进行,等待到`x`客户端处理之前注册.(`x`取决于你的系统).

| **进入内存屏障**                     | **离开内存屏障**               |
|-----------------------------------|-------------------------------|
| 1. 创建节点 __n_ = _b_+“/”+_p__ | 1. **L = getChildren(b, false)** |
| 2. 设置观测点: **exists(_b_ + ‘‘/ready’’, true)** | 2. 没有子节点,退出 |
| 3. 创建子节点: **create(_n_, EPHEMERAL)** | 3. 如果`p`是L的进程节点,删除n并退出 |
| 4. **L = getChildren(b, false)**  | 4. 如果`p`是L的底层节点,等待L的顶层节点结束 |
| 5. 如果L中的子节点小于`_x_`,那么等待观测事件 | 5. 如果n节点存在,并且等待到叶子节点,删除n节点 |
| 6. **create(b + ‘‘/ready’’, REGULAR)** | 6. goto 1 |

进入的时候,所有观测准备完成的节点,并创建一个临时节点,作为屏障节点的一个子节点.每个进程(除了最后一个进入的)进入内存屏障之后,等待节点的观测事件.这个进程会创建第x个节点,并唤醒其他进程.注意等待进程仅仅在退出的时候才会唤醒,所以等待需要高效.

退出的时候,不能使用标记,因为你正在观测进程节点消失.通过使用临时节点,在进入内存屏障之后没有正确完成节点,可以正常的结束.当进程需要离开的时候,需要删除进程节点并且等待其他进程也这么做.

当没有进程节点退出的时候(`/b`目录下没有子节点),进程就会退出.所有进程节点在底层存在的阶段快要消失的时候就准备退出.这就意味着仅仅单个进程会唤醒每个节点(除了最后一个节点).且在移除的时候唤醒的节点.

#### 队列

分布式队列是通用的数据结构，为了实现zk的分布式队列，首先设计一个znode用于容纳队列。分布式客户端通过调用`create()`将节点添加进去.且路径名称需要满足`queue-`的格式,使用临时标记,创建的阶段标记为true.因为设置了序列标记,新的路径为`path-to-queue-node/queue-X`,X就是单调增加的数字.

队列使用`getChildren()`方法移除客户端,通过在队列节点上设置观测器为true/且使用最小数字开启进程节点.客户端不需要处理其他`getChildren()`请求,直到上一个`getChildren()`方法处理完毕.如果队列节点中没有子节点,读取器会等待观测器检查队列的指令.

> **注意**:
>
> zk中实现队列的类位于,`zookeeper-recipes/zookeeper-recipes-queue`

#### 优先队列

需要对队列配置添加两个简单的改变,使其变为优先队列.

首先添加到一个队列中,路径名称以`queue-YY`接受,YY是优先参数,值越小优先值越高.

其次,从队列移除的时候,客户端使用最小的子列表,意味着如果观测器触发的情况下,客户端会校验之前的子节点列表.

#### 锁

分布式锁广泛的进行同步操作,意味着任何时间任何快照不会有两个客户端持有同一把锁.这个可以使用zk实现.使用优先队列,定义zookeeper-recipes/zookeeper-recipes-queue.

> **注意**
>
> zk关于分布式锁的实现位于`zookeeper-recipes/zookeeper-recipes-lock`

客户端获取锁可以进行下述操作:

1. 调用`create()`方法,设置`locknode/guid-lock-`和队列已经临时标记的设置.`guid`在`create()`结果丢失的时候创建.可以参考下面的内容.
2. 在锁节点上调用`getChildren()`,不用设置观测标记(这点对于避免羊群效应很重要)
3. 如果步骤1的操作的路径名称的序列编号最小,客户端持有锁且客户端退出协议.
4. 客户端调用`exist()`方法,这时候需要使用锁路径的观测标记,获取下一个最小序列编号.
5. 如果`exist()`返回null,跳转到步骤2.此外,等待上一步的观测器通知.

解锁的协议非常简单,客户端希望释放锁,就会删除步骤1创建的节点.

注意下述几点:

+ 节点的移除只会引起客户端的唤醒,因为每个节点设计为监视一个客户端.这种情况下用于避免羊群效应
+ 没有轮询和超时设置
+ 由于锁实现的原因,很方便查看锁的实时情况.

##### 可恢复的错误和GUID

如果可恢复的错误在调用`create()`的时候发送,需要调用`getChildren()`且检查节点是否在路径中包含`guid`.这个会处理`create()`方法成功在服务端执行,但是在返回节点名称之前服务器宕机的情况.

##### 共享锁

可以修改下述内容实现共享锁

| **获取共享读取锁** | **获取写锁** |
|----------------------------|-----------------------------|
| 1. 调用`create()`方法创建路径为`guid-/read-`的路径名称.这个锁节点会在协议中使用.保证序列编号和临时标记设置完成. | 1. 调用`create()`方法创建路径为`guid-/write-`的路径名称.这个锁节点会在协议中使用,保证设置序列编号和临时标记. |
| 2. 不要设置观测标记,在锁节点上调用`getChildren()`方法.用于避免羊群效应. | 2. 不要设置观测标记,在锁节点上调用`getChildren()`方法.用于避免羊群效应. |
| 3. 如果路径名称下面没有以`write-`开头的子节点,且节点的序列编号都小于第一步创建的编号,说明客户端以及持有锁,并可以退出协议. | 3. 如果没有小于步骤1创建出来的序列号,则说明当前客户端持有锁,并且可以冲协议中退出. |
| 4. 此外,调用`exists()`,这时候需要使用观测标记,这个在路径以`write-`开头且有最新的序列编号的情况下,设置于锁目录上. | 4. 调用`exists()`，这时需要设置观测标记，在下一个小的序列节点上设置. |
| 5. 如果`exists()`返回false,返回到步骤2 | 5. 如果`exists()`返回false,返回到步骤2.否则等待通知. |
| 6. 否则,等待上一步(5)的通知                                  |  |

> **注意**:
>
> 可能会发生如下情况,就是当一大批客户端等待读取锁,且获取通知的时候或多或少同时删除小编号了`write-`节点.事实上这时一个不合法的行为,因为等待的读取客户端需要释放,因为他们持有锁.羊群效应指的是释放一只"羊",这个"羊"大量的机器需要处理.

##### 可恢复的共享锁

对共享锁进行一些修改,可以获取获取可恢复的共享锁.

在步骤1中,获取读取器和写出器的锁协议的时候,在`create()`之后立即调用`getData()`设置观测器集合.如果客户端接收到步骤1创建的阶段通知,则在节点上进行再一次的`getData()`.这个就会通知客户端释放锁.

这是因为,通过共享锁协议,可以使用锁请求客户端,同时通过`getData()`方法释放锁.

注意这个协议需要锁持有者同意释放锁.这里的同意是非常重要的,尤其是锁持有者需要在释放锁之前进行动作.当然可以通过`Freaking Laser Beams`的方式实现`Revocable Shared Locks`.

#### 双向提交

双向提交协议是一个算法,这个算法可以允许分布式系统中的所有客户端同意提交或者是放弃事务.

zookeeper中,可以通过创建事务节点来实现双向提交.这个节点叫做`/app/Tx`,且每个参与的子节点叫做`/app/Tx/s_i`.当协调者创建子节点的时候,将节点定义为未定义.一旦每个位置包含的事务接收到协调者的事务的时候,这个位置会读取每个子节点且设置观测点.

每个位置会处理请求,且表示**提交**或者**放弃**,通过写入到各自的节点中.一旦写入完成,其他位置会被提示,当所有位置都投票的时候,它们可以决定**放弃**或者**提交**.注意到节点选择**放弃**要早于其他位置选择**放弃**.

这个实现的方式的一个重点是协调者的角色用于决定组位置,为了创建zk节点,需要传播事务到相应的位置.事实上,传递事务可以通过写入到事务节点实现.

但是有两种上述方法的缺陷,一个就是消息复杂度过高,为O(n^2).

第二是不能通过临时节点发现某个位置上执行失败的情况.为了能够发现指定位置的失败情况,在指定位置创建节点是很重要的.

为了解决第一个问题,需要提示协调者事务节点发生了变化,然后提示协调者获取决定的位置.之一这个方法是可以扩展的,但是仍然速度较慢,因为需要与所有的协调者进行沟通.

为了解决第二个问题,可以使协调者传递事务到指定位置上,且创建每个位置创建临时节点.

#### Leader选举

最简单的leader选举方式就是通过编号|临时节点标记进行leader选举.

假设有一个znode节点叫做`/election`,比如znode使用编号和临时节点标记创建了`/election/guid-n`节点/使用编号,zk自动添加编号,这个编号要大于之前的所有子节点的编号.创建最小编号的znode进程就会被选举为leader.

但是仅仅是这些是不够的,对于leader来说还需要去观测失败情况.以便于新的客户端在当前客户端失败的情况下能够进行替换.最简单的实现就是去将所有应用进程观测当前最小的znode,检查是否在最小的znode丢失之后会变成新的leader.

但是这样做会引起羊群效应,由于当前leader的失败,所有其他进程都接收到一个提示,且执行`/election`的`getChildren`方法,获取当前节点下所有的子节点.如果客户端数量很大,会引起zk服务器操作的峰值.为了避免羊群效应,观测下一个znode是很重要的.如果客户端接收到leader的znode丢失,如果没有更小的znode就会变成新的leader.这里通过监视同一个znode避免羊群效应.

下面是伪代码:

首先,选取一个leader

1. 创建路径为`/election/guid-n`的znode,携带有编号和临时节点标志
2. 让C变成`/election`的子节点,i变成z的编号
3. 监视节点`/election/guid-n_j`的变化,当j是满足j<i的最大编号值,且n_j是C的znode的时候

如果接收到了znode的删除信息

1. 让C变成新的`/election`子节点集合
2. 如果z是C中最小的阶段,执行leader程序
3. 否则观测`/election/guid-n_j`的变化,这是j满足在C集合中是满足j<i且j最大.