1. **图的抽象数据类型**

   ```markdown
   ADT Graph{
   	数据对象 V: V是具有相同特性数据元素的集合，称作顶点集
   	数据关系 R: R={VR}
   		VR=<v(i),w(i)> 表示vi 到wi之间的弧
   	基本操作 P:
   		createGraph(&G,V,VR)
   			根据给定的V以及VR关系创建图G
   		destoryGraph(&G)
   			初始条件: 图G存在
   			操作: 释放图G的空间
   		locateVex(G,x)
   			初始条件: 图G存在且x和G中顶点有相同的特征
   			功能: 若图中存在有顶点x，则返回顶点在图中的位置，否则返回其他信息
   		getVex(G,v)
   			初始条件: 图G存在，v是G中的某个节点
   			结果：返回v的值(节点信息)
   		putVex(G,v,val)
   			初始条件: 图G存在，v是G中某个节点
   			结果：将val赋值给v
   		FirstAdjVex(G,v)
   			初始条件: 图G存在，v是G中某个节点
   			结果：返回节点v的第一个邻接节点
   		NextAdjVex(G,v,w)
   			初始条件: 图G存在，v是G中某个节点,w是v的邻接阶段
   			结果: 返回w下一个v的邻接节点
   		InsertVex(&G,v)
   			初始条件: 图G存在，v具有节点特征
   			结果： G中新增一个节点v
   		DeleteVex(&G,v)
   			初始条件: 图G存在，v是G中某个节点
   			结果: 删除节点以及节点连接的弧
   		insertArc(&G,v,w)
   			初始条件: 图G存在，v,w是G中某个节点
   			结果: 新增v，w之间的弧，如果是无向图还需要添加一条反向的弧
   		deleteArc(&G,v,2)
   			初始条件: 图G存在，v是G中某个节点
   			结果: 删除v,w之间的弧，若是无向图还需要删除反向的那一条弧
   		DFSTraverse(G,visit())
   			初始条件: 图G存在
   			结果: 深度遍历一个图
   		BFSTraverse(G,visist())
   			初始条件: 图G存在
   			结果: 广度遍历一个图
   }
   ```

2. **图相关术语**

   + 基本概念

     图中元素称作**顶点**，两个顶点之间存在的连接关系称作**弧**，设这个关系为<v,w> 则v为弧头，w为弧尾。这时图称作**有向图**。若对于关系<v,w> 一定存在关系<w,v> 也输入关系集合中，称这样的图为**无向图**。关系<v,w>称作**边**。

     对于无向图来说，当边的数量达到**n(n-1)/2**,其中n为顶点数量时，称这个图为**完全图**。对于有向图，边数达到**n(n-1)**.称作**有向完全图**。

     当边(弧)数量少于**nlogn**时称作**稀疏图**，否则称作**稠密图**。

   + 度的概念

     **度**是与节点相连接的边的数目。

     其中以节点v为弧头的连接数目称作**出度**。

     以节点v为弧尾的连接数目称作**入度**。

   + 连通相关概念

     **路径**: 从节点v到节点vx的顶点序列 List

     **路径长度**：路径上经过边或者弧的数目，可以加权计算。

     **回路和环**: 第一个节点和最后一个节点相同的路径称作**回路**和**环**。

     **连通**：无向图中,从节点v到vx有路径，则v和vx是**连通**的。

     **连通图**：对于图中任意两个顶点，都保证是连通的，则这个图示**连通图**。

     **连通分量**： 非连通图中，**连通分量**是图中**最大连通子图**。

     **强连通图**:有向图中，对于图中两个节点v,vx，v->vx,vx->v都存在有路径，则称作为**强连通图**。

     **强连通分量**: 有向图中的最大连通子图。

     **生成树**: 是一个极小的连通子图，图中包含所有的顶点。但是它的边数为**n-1**.如果在边上再添加一个点，则势必会构成一个环。生成树可以保证v到vx只有一条路径。

     **生成森林**: 一个有向图顶点入度为0，其他顶点入度为1，则称作有向树。一个有向图的生成森林有多个有向树组成，包含图中全部节点，但是不存在有相交的弧。

3. **图的存储结构**

   + 数组表示

     ```c++
     // 使用两个数组，分别存储顶点以及数据元素关系(边/弧)信息
     const int INF=0x3fffffff;
     const int MAXN=200;
     typedef enum {DG,DN,UDG,UDN} kinds;// 有向图，有向网，无向图，无向网
     AdjMatrix[MAXN][MAXN];
     struct Node{
         T vexs[MAXN]; // 顶点向量
         AdjMatrix matrix;// 邻接矩阵 考虑到无向图矩阵是对称的，可以考虑矩阵压缩
         kinds kind;// 图类型
     };
     ```

   + 邻接表表示

     对图中每个节点建立起一个单链表，边链表节点通常包含三个部分

     ​	邻接点域: 与顶点v邻接的点在图中的位置

     ​	链域: 下一条边/弧的节点

     ​    数据域：存储边和弧的信息(权值)

     ```c++
     const int MAXN=200;
     // 弧节点
     struct ArcNode{
       	  int adjvex;// 弧的邻接节点(起始点)
           ArcNode* next;// 下一条弧
           Info* info;//弧信息
     };
     struct VNode{
         int data;// 节点数据
         ArcNode* firstptr;// 指向第一条邻接的弧/边
     }
     ```

   + 十字链表表示

     十字链表是有向图的一种链式存储结构。

     一个弧节点有5个域

     1. 尾域 指向弧尾顶点在图中位置

      	2. 头域 指向弧头在图中位置
      	3. 链域hlink 指向弧头相同的下一条弧
      	4. 链域tlink 指向弧尾相同的下一条弧
      	5. 数据域 info

     ```c++
     // 弧
     struct ArcNode{
       int tailvex;
       int headvex;
       ArcNode* hlink;
       ArcNode* tlink;
       Info* info;
     };
     struct VNode{
       	int data;
         ArcNode* firstin;// 指向第一条入弧
         ArcNode* firstout;// 指向第一条出弧
     };
     ```

   + 邻接多重表表示

     是无向图的一种链式存储结构

     由于无向图的对称性，访问一次的元素不能再次访问，所以为了能够正常遍历。需要对对称的两个元素做个标志表示这条边（包含对称那条）以及访问。所以邻接多重表结构如下:

     1. mark 标记域: 指示该边是否被访问过
     2. ivex,jvex: 顶点域，指向边的两个顶点的位置
     3. ilink,jlink: 指向下一条依附在顶点i,j上的边。
     4. info 数据域

     对于顶点来说，包含下面两个域

     	1. 数据域: data
     
      	2. 首个依附于该顶点的边：firstEdge

   ```c++
   struct ANode{
   	int mark;
   	int ivex;
       int jvex;
       ANode* ilink;
       ANode* jlink;
       Info* info;
   };
   struct VNode{
       int data;
       ANode* firstEdge;
   }
   ```

4. **图的遍历**

   ​	比起与树的遍历，图的遍历访问元素后需要设置访问标记，以免元素的重复访问

   + 深度优先搜索

     ```c++
     // DFS
     ```

   + 广度优先搜索

     ```c++
     // BFS
     ```

5. **图的连通性**

   + 无向图的连通分量和生成树

     遍历一个非连通图时，会生成多个生成树，这些生成树会组成生成森林。其中由深度优先搜索的生产树叫做深度优先生成树，使用广度优先搜索产生的生产树叫做广度优先生成树。特别地，当图不连通时，则不存在有广度优先搜索森林的概念(不连通)，深度优先搜索森林，是指每个生产树的深度优先搜索的并集。

     ```c++
     // 通用的广度优先森林遍历
     ```

   + 有向图的强连通分量

     使用深度优先搜索的一般步骤

     假设起始点为v，则以v为弧头深度优先遍历，将访问过的节点加入到访问集合**S**中。接着以S集合中最后一个访问元素为起点(弧头)，进行一次深度优先遍历，访问到的节点加入到集合S中。即为G的强连通分量的顶点集。

     ```markdown
     证明:
     ```

   + 最小生成树

     最小生成树的**MST**性质,假设**N={V,{E}}**是一个连通网，U是顶点集V的一个非空子集。设(u,v)是一条具有最小权值的边，其中u belong to U,v belong to V-U.则必定存在一颗包含(u,v)边的最小生成树。

     ```markdown
     证明:
     ```

     应用: 

     1. 普里姆法则(prim)

        普里姆法则思路:

        假设TE是最小生成树中边的集合,算法从U={a0}，TE={}开始。重复执行:

        在所有u belong to U,v belong to V-U的边(u,v) belong to E 中找到一条最小的边(u0,v0),放置到TE中。同时u0放置到U中。直到U=V位置。此时TE中必定有n-1条边.则T={V,{TE}}

        ```c++
        // prim法则实现示例
        ```

     2. 克鲁斯卡尔算法(kruskal)

        思路:

        假设连通网N={T,{E}}，求解最小生成树时，令初始状态下所有节点都为非连通图T={V,{}}。现在从E中选取代价最小的边，或改变连接的两个顶点不在一个连通分量中，则将此边添加到连通分量中。以此类推知道所有的顶点都放到了一个连通分量上。

        ```c++
        // kruskal实现示例
        ```

   + 关节点和重连通分量

     **关节点**: 将一个点以及其余其他顶点的边去除，剩下的元素构成的图会被分割成两个或者两个以上的连通分量。则该点称作关节点。

     **重连通图**: 一个不存在有关节点的图，称作重连通图。

     如何去确认一个图是否为重连通图：
     
      1. 使用深度优先搜索求取图的关键点
     
         使用深度优先搜索去遍历图，获得深度优先生成树。观察生成树的结构:
     
         如果生成树有两颗及以上的子树，则存在有这样的关键点，使得图不是重连通图：
     
     2. 求关键点的方法
     
        在原有的访问状态向量vis的基础上，加设新的向量low，装载一次深度优先遍历中的所有关键点。
     
        ```c++
        // 求取关键点的方法
        ```
   
6. **有向无环图**

   + 基本概念: 一个无环的有向图称作**有向无环图**

     有向无环图是描述一项工程或是系统进行过程中的有效工具。除了最简单的情况之外，几乎所有工程都可以分为若干个称为**活动**的子工程。而工程之间，需要有相对的限制条件。通常，在工程中，人们在乎的是工程是否能够成功进行，二是估算工程的最短时间(对应最长路径)。

   + **拓扑排序**

     1. **偏序**的概念

        在集合X上关系R是自反的，反对称的且是传递的，称R是集合X的偏序关系。

        如此，对于任意两个集合元素x，y。有xRy=yRx，则R是集合X上的**全序**关系。

     2. AOE网与AOV网概念:

        AOV网: 顶点表示活动，顶点的点权表示活动进行的时间

        AOE网: 弧表示活动，弧的边权表示活动进行的时间

     3. **拓扑排序**的过程:

        + 从有向图中选择一个节点，并对其进行访问
        + 删除以访问节点为弧头的边，更新对应节点的前驱
        + 重复上述操作，知道一个有向无环图中的顶点全数访问完毕。

     4. **拓扑排序**的简单实现:

        ```c++
        // 拓扑排序
        ```

   + **关键路径**

     通常使用AOE网来计算工程完成时间

     有向无环图中路径最长的叫做**关键路径**，关键路径是完成所有工作中耗时最短的。

     1. **工期优化**

        设ve( i ) 表示v工作的最早发生时间，vl( i )表示v工作的最迟发生时间。关键路径上的节点满足e(i)=l(i)

        其中:

        ​	e(i) = ve(i)

        ​	l(i)= vl(k) - duty(j,k)

        首先计算各个工期的最早发生时间: duty( j ,i) 表示工作j的持续时间

        ​	ve(0) =0

        ​	ve(j)=MAX( ve(i) +duty( i, j ) )

        然后从后往前计算工作的的最迟结束时间

        ​	vl(n-1)=ve(n-1)

        ​	vl(i)=MIN(vl( j )- duty(i , j))

        将所有满足关键路径元素关系的节点加入集合，并排列起来，即求得关键路径

     2. **关键路径求解**

        + 输入弧信息，构建AOE网
        + 从源点出发，令ve(0)=0,按拓扑关系求取各个顶点的最早发生时间ve(i).如果拓扑序列中的顶点数小于AOE网节点数量，说明其中有环，算法终止，不存在有关键路径。
        + 从汇点vn出发，设vl(n-1)=ve(n-1)，按逆向拓扑序列求取各个节点的最迟发生时间vl(i).
        + 根据关键节点判定条件，按照拓扑序列顺序记录**关键节点**，连接成**关键路径**。

     3. **关键路径求取实例**

        ```c++
        // 求AOE网关键路径
        ```

7. **最短路径**

   + **单源最短路径**(主要讨论非负边的Dijkstra算法)

     引进一个辅助分量D[ i ]，表示当前所找到的节点与起始点v0之间的距离最小值。

     ​	满足: D[ j ] = MIN {D[ i ] | vi belong to V}

     求出最短距离之后接着求取最短路径下一段的值，此时只需要将起始点改为j，求j到下一段的最短距离即可，再与起始点到该点的最短距离求最小值即可，总体来说是对最短距离的贪心算法。

     ```c++
     // Dijkstra算法的实现
     ```

   + **多源最短路径**(Floyd算法)

     ```c++
     // Floyd算法实现
     ```

     

     