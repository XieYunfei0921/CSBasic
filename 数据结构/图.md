1. **图的抽象数据类型**

   ```markdown
   ADT Graph{
   	数据对象 V: V是具有相同特性数据元素的集合，称作顶点集
   	数据关系 R: R={VR}
   		VR=<v(i),w(i)> 表示vi 到wi之间的弧
   	基本操作 P:
   		createGraph(&G,V,VR)
   			根据给定的V以及VR关系创建图G
   		destoryGraph(&G)
   			初始条件: 图G存在
   			操作: 释放图G的空间
   		locateVex(G,x)
   			初始条件: 图G存在且x和G中顶点有相同的特征
   			功能: 若图中存在有顶点x，则返回顶点在图中的位置，否则返回其他信息
   		getVex(G,v)
   			初始条件: 图G存在，v是G中的某个节点
   			结果：返回v的值(节点信息)
   		putVex(G,v,val)
   			初始条件: 图G存在，v是G中某个节点
   			结果：将val赋值给v
   		FirstAdjVex(G,v)
   			初始条件: 图G存在，v是G中某个节点
   			结果：返回节点v的第一个邻接节点
   		NextAdjVex(G,v,w)
   			初始条件: 图G存在，v是G中某个节点,w是v的邻接阶段
   			结果: 返回w下一个v的邻接节点
   		InsertVex(&G,v)
   			初始条件: 图G存在，v具有节点特征
   			结果： G中新增一个节点v
   		DeleteVex(&G,v)
   			初始条件: 图G存在，v是G中某个节点
   			结果: 删除节点以及节点连接的弧
   		insertArc(&G,v,w)
   			初始条件: 图G存在，v,w是G中某个节点
   			结果: 新增v，w之间的弧，如果是无向图还需要添加一条反向的弧
   		deleteArc(&G,v,2)
   			初始条件: 图G存在，v是G中某个节点
   			结果: 删除v,w之间的弧，若是无向图还需要删除反向的那一条弧
   		DFSTraverse(G,visit())
   			初始条件: 图G存在
   			结果: 深度遍历一个图
   		BFSTraverse(G,visist())
   			初始条件: 图G存在
   			结果: 广度遍历一个图
   }
   ```

2. **图相关术语**

   + 基本概念

     图中元素称作**顶点**，两个顶点之间存在的连接关系称作**弧**，设这个关系为<v,w> 则v为弧头，w为弧尾。这时图称作**有向图**。若对于关系<v,w> 一定存在关系<w,v> 也输入关系集合中，称这样的图为**无向图**。关系<v,w>称作**边**。

     对于无向图来说，当边的数量达到**n(n-1)/2**,其中n为顶点数量时，称这个图为**完全图**。对于有向图，边数达到**n(n-1)**.称作**有向完全图**。

     当边(弧)数量少于**nlogn**时称作**稀疏图**，否则称作**稠密图**。

   + 度的概念

     **度**是与节点相连接的边的数目。

     其中以节点v为弧头的连接数目称作**出度**。

     以节点v为弧尾的连接数目称作**入度**。

   + 连通相关概念

     **路径**: 从节点v到节点vx的顶点序列 List

     **路径长度**：路径上经过边或者弧的数目，可以加权计算。

     **回路和环**: 第一个节点和最后一个节点相同的路径称作**回路**和**环**。

     **连通**：无向图中,从节点v到vx有路径，则v和vx是**连通**的。

     **连通图**：对于图中任意两个顶点，都保证是连通的，则这个图示**连通图**。

     **连通分量**： 非连通图中，**连通分量**是图中**最大连通子图**。

     **强连通图**:有向图中，对于图中两个节点v,vx，v->vx,vx->v都存在有路径，则称作为**强连通图**。

     **强连通分量**: 有向图中的最大连通子图。

     **生成树**: 是一个极小的连通子图，图中包含所有的顶点。但是它的边数为**n-1**.如果在边上再添加一个点，则势必会构成一个环。生成树可以保证v到vx只有一条路径。

     **生成森林**: 一个有向图顶点入度为0，其他顶点入度为1，则称作有向树。一个有向图的生成森林有多个有向树组成，包含图中全部节点，但是不存在有相交的弧。

3. **图的存储结构**

   + 数组表示

     ```c++
     // 使用两个数组，分别存储顶点以及数据元素关系(边/弧)信息
     const int INF=0x3fffffff;
     const int MAXN=200;
     typedef enum {DG,DN,UDG,UDN} kinds;// 有向图，有向网，无向图，无向网
     AdjMatrix[MAXN][MAXN];
     struct Node{
         T vexs[MAXN]; // 顶点向量
         AdjMatrix matrix;// 邻接矩阵 考虑到无向图矩阵是对称的，可以考虑矩阵压缩
         kinds kind;// 图类型
     };
     ```

   + 邻接表表示

     对图中每个节点建立起一个单链表，边链表节点通常包含三个部分

     ​	邻接点域: 与顶点v邻接的点在图中的位置

     ​	链域: 下一条边/弧的节点

     ​    数据域：存储边和弧的信息(权值)

     ```c++
     const int MAXN=200;
     // 弧节点
     struct ArcNode{
       	  int adjvex;// 弧的邻接节点(起始点)
           ArcNode* next;// 下一条弧
           Info* info;//弧信息
     };
     struct VNode{
         int data;// 节点数据
         ArcNode* firstptr;// 指向第一条邻接的弧/边
     }
     ```

   + 十字链表表示

     十字链表是有向图的一种链式存储结构。

     一个弧节点有5个域

     1. 尾域 指向弧尾顶点在图中位置

      	2. 头域 指向弧头在图中位置
      	3. 链域hlink 指向弧头相同的下一条弧
      	4. 链域tlink 指向弧尾相同的下一条弧
      	5. 数据域 info

     ```c++
     // 弧
     struct ArcNode{
       int tailvex;
       int headvex;
       ArcNode* hlink;
       ArcNode* tlink;
       Info* info;
     };
     struct VNode{
       	int data;
         ArcNode* firstin;// 指向第一条入弧
         ArcNode* firstout;// 指向第一条出弧
     };
     ```

   + 邻接多重表表示

     是无向图的一种链式存储结构

     由于无向图的对称性，访问一次的元素不能再次访问，所以为了能够正常遍历。需要对对称的两个元素做个标志表示这条边（包含对称那条）以及访问。所以邻接多重表结构如下:

     1. mark 标记域: 指示该边是否被访问过
     2. ivex,jvex: 顶点域，指向边的两个顶点的位置
     3. ilink,jlink: 指向下一条依附在顶点i,j上的边。
     4. info 数据域

     对于顶点来说，包含下面两个域

     	1. 数据域: data
     
      	2. 首个依附于该顶点的边：firstEdge

   ```c++
   struct ANode{
   	int mark;
   	int ivex;
       int jvex;
       ANode* ilink;
       ANode* jlink;
       Info* info;
   };
   struct VNode{
       int data;
       ANode* firstEdge;
   }
   ```

4. **图的遍历**

   ​	比起与树的遍历，图的遍历访问元素后需要设置访问标记，以免元素的重复访问

   + 深度优先搜索

     ```c++
     // DFS
     ```

   + 广度优先搜索

     ```c++
     // BFS
     ```

5. **图的连通性**

   + 无向图的连通分量和生成树

     遍历一个非连通图时，会生成多个生成树，这些生成树会组成生成森林。其中由深度优先搜索的生产树叫做深度优先生成树，使用广度优先搜索产生的生产树叫做广度优先生成树。特别地，当图不连通时，则不存在有广度优先搜索森林的概念(不连通)，深度优先搜索森林，是指每个生产树的深度优先搜索的并集。

     ```c++
     // 通用的广度优先森林遍历
     ```

   + 有向图的强连通分量

     使用深度优先搜索的一般步骤

     假设起始点为v，则以v为弧头深度优先遍历，将访问过的节点加入到访问集合**S**中。接着以S集合中最后一个访问元素为起点(弧头)，进行一次深度优先遍历，访问到的节点加入到集合S中。即为G的强连通分量的顶点集。

     ```markdown
     证明:
     ```

   + 最小生成树

     最小生成树的**MST**性质,假设**N={V,{E}}**是一个连通网，U是顶点集V的一个非空子集。设(u,v)是一条具有最小权值的边，其中u belong to U,v belong to V-U.则必定存在一颗包含(u,v)边的最小生成树。

     ```markdown
     证明:
     ```

     应用: 

     1. 普里姆法则(prim)

        普里姆法则思路:

        假设TE是最小生成树中边的集合,算法从U={a0}，TE={}开始。重复执行:

        在所有u belong to U,v belong to V-U的边(u,v) belong to E 中找到一条最小的边(u0,v0),放置到TE中。同时u0放置到U中。直到U=V位置。此时TE中必定有n-1条边.则T={V,{TE}}

        ```c++
        // prim法则实现示例
        ```

     2. 克鲁斯卡尔算法(kruskal)

        思路:

        假设连通网N={T,{E}}，求解最小生成树时，令初始状态下所有节点都为非连通图T={V,{}}。现在从E中选取代价最小的边，或改变连接的两个顶点不在一个连通分量中，则将此边添加到连通分量中。以此类推知道所有的顶点都放到了一个连通分量上。

        ```c++
        // kruskal实现示例
        ```

   + 关节点和重连通分量

     **关节点**: 将一个点以及其余其他顶点的边去除，剩下的元素构成的图会被分割成两个或者两个以上的连通分量。则该点称作关节点。

     **重连通图**: 一个不存在有关节点的图，称作重连通图。

     