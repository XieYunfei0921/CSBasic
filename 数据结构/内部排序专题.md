1. **插入排序**

   + **直接插入排序**: 将一个记录插入到以及排序好的记录集中，记录集总数+11111

     ```c++
     // 直接插入排序 时间复杂度O(n^2)
     ```

   + **折半插入排序**： 对一个有序表进行折半查找，找不到则插入。

     ```c++
     // 折半插入排序 时间复杂度O(n^2)
     ```

   + **2-路插入排序**： 在折半插入的基础上进行改进，目的是减少排序过程中移动记录的次数，因此这个排序需要n个记录的辅助空间。

   + **表插入排序**

     ```c++
     // 表节点结构
     // 单条记录节点信息
     const int MAXN=200;  
     struct STNode{
       	T rc;	// 记录项  
     	int next; // 指针项
     };
     // 静态链表
     struct StaticLinkList{
         STNode sll[MAXN];
         int curlength;
     }
     // 节点数组
     STNode r[MAXN];
     ```

     表节点插入排序的基本步骤:

     ​	1. 设数组下标为0的点为表头节点，并令表头节点记录的关键字取最大整数MAXINT。

     	2. 将静态链表中1的分量与表头节点构成一个循环链表，然后2-n节点信息按照关键字非递减的顺序插入到循环链表中。插入完毕之后会得到一个有序的链表，值支持数据的顺序查找，不支持随机查找，还需要进行一步操作。
      	3. 记录重排: 顺序扫描有序链表的第i个节点到数组的第i个节点中去。

   + **希尔排序**

     希尔排序有称作**最小增量排序**，也是一种插入排序的方法。

     下面定义基本有序的概念:

     ​	L.r[i].key<max{L.r[ j] .key} ( j < i )

     基本是将整个序列分割成多个子序列，对子序列直接进行**直接插入排序**，保证子序列基本有序。在全体记录进行一次直接插入排序。

     ```c++
     // shell 排序算法
     ```

     如何去确定增量序列:

     ​	增量序列 deta[ k ] = 2^(t-k+1) - 1 时，排序的时间复杂度为n^(3/2)

2. **快速排序**

   + 冒泡排序

     ```c++
     // 冒泡排序法 时间复杂度 O(n^2)
     ```

   + 快速排序

     ```c++
     
     ```

     快速排序平均时间复杂度为O(nlog n)，属于比较类排序方法中最快的。但是考虑到序列有序或基本有序是，快速排序时间复杂度会向O(n^2)去逼进。

3. **选择排序**

   + 简单选择排序

     ```c++
     // 简单选择排序
     ```

   + 树型选择排序

     n个关键字两两进行比较，然后在ceil(n/2)个较小元素之间继续进行比较。如此重复，直至选择出最小的关键字为止。整个过程可以使用一颗完全二叉树来表示。

     ```c++
     
     ```

   + 堆排序

     1. 建堆

        ```c++
        
        ```

     2. 堆的调整

        ```c++
        
        ```

     3. 堆排序

        ```c++
        
        ```

4. **基数排序**

   基数排序是借助多关键字排序的思想，对单个关键字进行排序

   假设序列中的元素为 R0，R1... Rn

   Ri中含有d个关键字列表 K(i,0),K(i,1)...K(i,d-1)

   K0 称作主位关键字，Kd-1称作最次关键字

   + 从主位关键字开始，依次对下位关键字排序获得的有序序列称作为**最高位优先**(MSD)
   + 从最次关键字开始，依次对上位关键字排序获得的有序序列称作为**最低位优先**(LSD)

   使用MSD方法进行排序时，必须要将序列逐层分割成子序列。而使用LSD方法进行排序时，可以不通过比较的方法，仅仅通过分配和收集的方法进行排序。

   **链式基数排序**

   ```c++
   // 定义的新结构体
   const int maxn=1000;
   const int max_key_nums=26;
   // 单个节点信息
   struct SLLCell{
     	T key[max_key_nums];// 关键字
       int next;// 指向下一个节点
   };
   struct SLList{
      SLLCell r[maxn];
      int curlen;
      int keynum;
   };
   ```

   分配和收集操作

   ```c++
   // 分配空间
   void Distribute(SLList &list){
       
   }
   // 收集空间
   void Collect(SLList &list){
       
   }
   ```

   基数排序

   ```c++
   // 基数排序
   void RadixSort(SLList &list){
       
   }
   ```

   

5. **归并排序**

   ```c++
   // 归并排序
   ```

6. **各种排序的性能比较**

   + 当记录数量很大的时候，时间消耗很大，可以采用静态链表作为存储结构,以修改指针的操作来代替移动数据。如果某种排序(快速排序或者是堆排序)，无法使用表排序的形式，那么，则需要另外设定**地址变量**指向对应的记录。通过修改地址变量去修改指针。