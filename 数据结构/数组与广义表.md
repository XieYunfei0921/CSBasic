1. **数组的抽象数据类型**

```markdown
ADT Array{
	数据对象: ji=0...bi-1
			D={aj1...ajn}(n>0)
			其中,称作n的维度,bi为第ji维数组的长度
	数据关系:
			<aj1...ajn>
			一个维度的元素满足:
				0<=jk<=bk-1 k~[1,n]
	基本操作集:
		InitArray(Array &A,b1...bn)
			基本条件: 若维度长度满足条件.则构造相应的数组,并返回
		DestroyArrayy(Array &A)
			销毁数组A
		Value(A,x,index1...indexn)
			基本条件: A是一个n维的数组,e为元素变量,随后n个是下标值
			操作结果: 如何各个下标不越界,则e赋值为指定A位置的元素值,返回e
		Assign(A,x,index1...indexn)
        	基本条件: A是一个n维的数组,e为元素变量,随后n个是下标值
			操作结果: 如何各个下标不越界,则e赋值给指定A位置的元素值
}ADT Array
```

+ 对于一位数组,可以看做成定长线性表

+ 对于多维的数组,可以看出定长线性表,只不过这里的元素也是定长线性表.这种嵌套的形式有点类似与块链(只不过块链来说是两种数据结构的嵌合)

+ 数组一旦确定了,那么它的维度和维界就确定了

2. **数组的顺序表表示**

   数组一旦确定了,就不会出现增加和删除操作了,但是查找和修改还是可以进行的.不存在增删,也就不会改变数组内数据元素之间的关系(空间位置关系)
   
   对于一个n维数组,对于第j1j2...jn位置的数据满足:
   
   ​	LOC(j1,j2,j3,j4...jn)=LOC(0,0,0...0)+[(b2b3...bn*j1)+(b3...bn**ji)...+bn*jn-1+jn]*L*
   
   其中L为数据元素所占有的存储位置。这就叫做n维数组的**映像函数**
   
   伤式可以缩写为:
   
   ​	LOC(J1...JN)=LOC(0,0...0)+sigma(1,n,ci*ji)
   
   对于一个确定了维数的数组，ci就是一个长度，也就是可以根据基地址
   
   ，直接定位到当前元素的位置，存取每个元素所花费的时间相等（O(1)），有这个特征（存储每个元素的时间都相等）,叫做随机存储结构。
   
   ```c++
   const int MAX_DIM=8;
   struct Array{
     	int* base;  // 基地址
       int dim;	// 数组维数
       int* bounds;// 数组维数对应的维界限
   };
   Array initArray(int dim,int bound_para[],int const_para[]){
       // 形成一个固定大小的空间
       if(dim<0 || dim>MAX_DIM) throw excption;
       Array arr;
       arr.base=new int;
       // 初始化维界限 长度为dim,arr+i表示第i维度的维界
       arr.bounds=new int;
       // 常数指针，初始为第一个元素的空间，工具sigma(1,boundmax,bounds[i])
       arr.dim=dim;
       int cnt=0;
       for(int i=0;i<dim;i++){
           *(arr.bounds+i)=bound_para[i];
           cnt+=bound_para[i];
       }
       int p=0;
       while(p<cnt){
           *(base+p)=const_para[p];
           p++;
       }
   }
   void destroyArray(Array &arr){
       delete(arr.bounds);
       delete(arr.base);
   }
   int locate(Array arr,int dim,int offset){
       // 求维度编号为dim,维度内偏移量offset的元素位置,返回相对地址
       int cnt=0;
       for(int i=0;i<dim;i++)
           cnt+=*(arr.bounds+i);
       cnt+=offset;
       return cnt;
   }
   int value(Array arr,int dim,int offset){
       int cnt=0;
       for(int i=0;i<dim;i++)
           cnt+=*(arr.bounds+i);
       cnt+=offset;
       return *(arr.base+cnt);
   }
   void assign(Array &arr,int dim,int offset,int val){
       int cnt=0;
       for(int i=0;i<dim;i++)
           cnt+=*(arr.bounds+i);
       cnt+=offset;
       *(arr.base+cnt)=val;
   }
   ```
   
3. **矩阵压缩**

   ​	矩阵压缩的规则：

   ​			为多个值相同的元只分配一个元，零元不分配空间

   1. **特殊矩阵的压缩**

      * 对称矩阵的压缩

        对称矩阵定义: aij=aji(对应任意i<=imax,j<jmax)

        储存量： n^2->n(n+1)/2

        矩阵映射数组关系:

        ​	sa[  (i-1)*i/2 + j-1 ]=matrix( i , j ) // 下三角矩阵

        ​	sa[  (j-1)*j/2 + i-1 ]  =  matrix(  i , j )  // 上三角矩阵	

      * 上/下三角矩阵的压缩

   2. **稀疏矩阵的压缩**

      + **稀疏因子**:

        在m*n的矩阵中，包含了t个不为零的元素，稀释因子 **fac=t/(m* * n)**

        通常fac<=0.05的时候，称作**稀疏矩阵**

      + **稀疏矩阵的抽象数据类型**

        ```markdown
        ADT SparseMatrix{
        	数据对象: D = {a(i,j) | i=1,2...m;j=1,2...n}
        	数据关系: R={Row,Col}
        		Row={<a(i,j),a(i,j+1)>} // 行间关系
        		Low={<a(i,j),a(i+1,j)>} // 列间关系		
        	操作集:
            	createSMatrix()  创建稀疏矩阵
            	destroySMatrix(SMatrix &s) 
            		操作条件: 稀疏矩阵s存在
            		功能: 销毁稀疏矩阵s
            	printSMatrix(SMatrix &s)
            		操作条件: 稀疏矩阵S存在
            		功能: 打印稀疏矩阵S
            	copySMatrix(SMatrix s)
            		操作条件：稀疏矩阵s存在
            		功能: 复制s矩阵，并返回
            	AddSMatrix(SMatrix s,SMatrix t,SMatrix Q)
            		条件: 稀疏矩阵s，t的行列匹配
            		功能: 返回矩阵Q=S+T
            	SubMatrix(SMatrix s,SMatrix t,SMatrix Q)
            		条件: 稀疏矩阵s,t行列匹配
            		功能: 返回矩阵Q=S-T
            	multiSMatrix(SMatrix s,SMatrix t,SMatrix Q)
            		条件: s的列=t的行
            		功能: 返回矩阵Q=S*T
            	matrixTraverse(SMatrix s)
            		条件: 矩阵s存在
            		功能: 矩阵遍历
        }
        ```

        

      + **矩阵压缩的三元组存储方式**

        ```c++
        struct Triple{
            int x,y;
            int val;
        }
        const int MAX_SIZE=2000;
        // 矩阵的三元组线性表结构
        struct Matrix{
            Triple list[MAX_SIZE];
            //行列数量，非零元素数据 行号1-rown 列号 1-coln 元素编号 1-nonum
            int rown,coln,nonum;
        }
        ```

      + **矩阵的转置**

        ```c++
        // 时间复杂度 O(mu*nu)
        void transposeMatrix(SMatrix s,SMatrix &t){
            // 行为主序列扫描
            t.rown=s.coln;t.coln=s.rown;t.nonum=s.nonum;
            // 对s的列进行扫描，扫描到的结果行列交换，加入到t中
            int cnt=0;
            for(int col=1;col<=s.coln;col++){
                for(int i=0;i<s.nonum;i++){
                    if(s.list[i].y==col){
                        t.list[cnt].x=col;
                        t.list[cnt].y=s.list[i].x;
                        t.list[cnt].val=s.list[i].val;
                        cnt++;
                    }
                }
            }
        }
        ```

      + **矩阵的快速转置法**

        ```c++
        // 设置两个参数
        /*
        	列非零元素数量个数向量	num[col]
        	列首个非零元素处于三元线性表中的位置向量表 : cpot[col]
        	转置之前需要先求出这两个向量表。
        */
        // 时间复杂度比上一个复杂度优秀，引入了两个位置的向量表
        void fastTransposeMatrix(SMatrix s,SMatrix &t){
            t.rown=s.coln;t.coln=s.rown;t.nonum=s.nonum;
            for(int col=1;col<=s.coln;col++){
                // 初始化元素数量向量表
                num[col]=0;
            }
            // 从0开始nonum个
            for(int t=0;t<nonum;t++){
               	// 形成元素数量向量表
                num[s.list[t].y]++;
            }
            cpot[1]=1;
            for(int col=2;col<=s.coln;col++){
                cpot[col]=cpot[col-1]+num[col-1];
            }
            // 转置 直接对点转置由于向量表的存在，所有能够确定转置后的位置
            int cur,q;
            for(int p=0;p<s.nonum;p++){
                cur=s.list[p].y;
                // 寻找位置向量表位置
                q=cpot[col];
                t.list[q].y=s.list[p].x;
                t.list[q].x=s.list[p].y;
                t.list[q].val=s.list[p].val;
            }
        }
        ```

        

