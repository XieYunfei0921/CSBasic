## **动态存储管理**

---

1. **基本概念**

   基本问题:

   ​	1. 系统如何处理用户提出的请求，并分配内存

   ​	2. 系统如何去处理用户不再使用内存(释放内存)，以便去对新请求的内存进行分配。	

   定义已经分配给用户使用的连续内存区为**占用块**/**内存块**

   定义未分配给用户的内存区叫做**可利用内存块**

   无论在什么样的动态内存管理系统，刚开工时，整个内存区都是空闲块(编译程序中称为**堆**)

   随着用户提出存储请求，整个内存区被分成两个部分，包括:

   ​	低地址区的占用块

   ​	高地址去的空闲块

   随着用户提出和释放内存的请求，整个内存区的占用块和空闲块呈现犬牙交错的状态。

   若此时用户在请求内存，该如何操作？

   ​	**策略1**： 继续分配高地址内存区域，不管低地址内存区域的内存释放，直到整个分配无法进行(剩余的内存区域无法	满足用户的要求)

   ​	**策略2**： 用户一旦运行完毕，则释放内存，使得相应占用块变成空闲块。这时候系统需要维护一个空闲块的列表(链表/ 目录表)，当有新用户申请内存时，系统从列表中找到一个**合适**的内存块分配给用户。使得其成为**占用块**。

   ​	表中节点信息至少需要包含： 空闲块起始地址，空闲块大小，空闲块的使用情况(占用/没有占用)

2. **可利用空间表及其分配方法**

   可利用空间表包括所有可分配的内存块，其中每一块是链表的一个节点。(整个链表就是可利用空间表)。

   ​	当用户申请内存时，系统从可利用空间表中删除一个节点，并将这个节点对应的空闲块分配给该用户。

   ​	用户释放内存时，系统将用户所对应的占用块，加入到链表中(可利用空间表)。

   这个歌可利用空间表也称作存储池。

   根据系统运行的不同情况，分为:

   + 系统运行期间，所有用户申请的内存量相同

     系统开始运行时，就将内存区分割成若干大小为指定大小的块，可利用空间表中存储每一块的首地址即可。这样就可以使用首地址+块大小直接定位空间表中的位置。释放空间时，只需要将一块新的内容插入到空间表的表头即可。事实上是一个**链栈**。

   + 系统运行期间，用户申请的内存有若干个大小的规格(有限种类的内存块大小)

     可以设定一个枚举，用于存储每种规格用户申请内存块的大小。

     空间表中存储的节点信息，就不只是上一步的首地址了，还要存储当前块的类型枚举(用于计算块大小)。最终仍通过首地址+块大小定位空间表中的空闲块位置。此时分配和回收内存与情景1类似。但是这个情景存在一个极限情况，就是： 当频繁地对小内存块进行分配与释放，将原先的大内存块进行分割，此时如果要申请等量的大内存块，就会获取不到。但是如果将小内存块进行移动操作，还是可以分配出这个大内存块的空间的。此时就需要@**存储紧缩**的操作。

   + 系统运行期间，用户申请的内存大小不固定，可以随请求发生变化，因此，可利用空间表节点是随意的。属于一般情况。

     首先要考虑空间表中节点域的设置，首地址是必须要的，其次，由于大小不一，所以必定要手动指定块的大小size。当需要分配大小为n的内存块时，此时空间大小m>=n，需要分配n空间的块给用户，剩余空间为m-n的部分留在空间表中即可。但是要是有多个不小于n的空间，该分配哪一块呢？

     1. **首次拟合法**

        从表头指针开始，找到第一个空间大于n的块，分配给用户。这里需要注意，链表中节点元素的首地址，大小分布都是不均的，所以不一定有序。

     2. **最佳拟合法**

        找到一块空间不小于n且空间最接近于n的空闲块，分配给用户。当然这个操作一定是要实现扫描一遍链表获取这个节点。分配时还需要再访问一次链表，将其移除。为了更加方便，可以预先按照块大小进行降序排列。

     3. **最差拟合法**

        找到一块空间不小于n且空间最大的一个内存块，分配给用户。这样排序后获取首个节点即可。

     三种分配方案应用领域:

     ​	**最佳拟合法**适应于内存大小分布较广的系统。(会产生许多存储量甚小且无法利用的内存，但是可以将大内存块留给需求内存高的用户)

     ​	**最差拟合法**适应于内存分布较为狭窄的系统。这样链表中节点的空间大小区域均匀。

     ​	**首次拟合法**内存分配时随机的，适用于系统运行不掌握到运行期间可能出现的情况。

     ​	因此选择的时候，需要考虑用户的逻辑请求，请求的内存量大小分布情况，以及**分配释放内存的频率**。**效率对系统的重要性**等。

   ```c++
   // 内存的回收与分配算法
   ```

3. **边界表示法**

4. **伙伴系统**

5. **无用单元收集**

6. **存储紧缩**