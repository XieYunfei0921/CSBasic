1. **哈希表**

   + 基本概念

   查找的理想情况下，是不经过任何的比较，一次边存取所查询的记录。那就必须建立起记录存储位置与它的关键字所对应的关系f。使每个关键字与结构中唯一一个存储位置相对应。称这个对应关系f为**哈希函数**。

   对于key1!=key2 但是f(key1)=f(key2)这种情况称作**哈希冲突**。而一般情况下，冲突是存在的但是需要尽可能的减小，才算是好的哈希函数的标准。

   根据设定的哈希函数H（key) 以及冲突处理的方法，将一组关键字映射到有限连续的地址集上，并以关键字在地址集中的像作为记录在表中的位置，这种表称作**哈希表**。这个过程叫做**散列**，所得位置称作**哈希地址**或者**散列地址**。

   + 哈希函数的构造方法

     好的哈希函数的标准: 对应关键字集合中的任意一个关键字，进过哈希函数映像到地址集合中任意一个地址的概率是相等的。此类哈希函数为均匀的哈希函数。也就是说，关键字从哈希函数中获得了随机的地址从而减小哈希冲突的可能性。

     几种常见的哈希函数:

     1.  直接定址法

        H(key) = key 或 H(key) =a*key+b

        这也叫做自身函数,这种哈希函数哈希冲突是不存在的，但是当关键字分布过于离散，对于存储空间的要求是非常大的。 

     2.  数字分析法

     3.  平方取中法

        取关键字平方后中间几位为哈希地址。通常在选定哈希函数时，不知道关键字的全部情况，也不知道该取其中哪几位，而一个数平方后中间几位与数的每一位都相关。由此随机出来的关键字得到的hash地址也是随机的。平方取中的位数由hash表长来决定。

        ```c++
        // 平方取中法hash
        ```

     4.  折叠法

        将关键字分割成位数相同的几个部分之后(最后一部分可以位数不同),取这几个部分的叠加和为哈希地址，这种方法称为**折叠法**。适用于关键字位数很多，且关键字中每一位数字分布大致均匀的情况下。

        ```c++
        // 折叠法hash
        ```

     5.  除余取留法

        H(key)= key MOD p （p<= m） m是表长

        p的选取与冲突出现的可能性有关。且p，最好要是素数。

     6. 随机数法

        H（key)=random(key)

        适用于关键字长度不相等时。

     几种冲突解决策略:

      1.  开发定址法

         当关键字出现冲突时,重设关键字的hash地址

         H(key)`=(H(key)+ d(i)) MOD m

         其中d(i) 是探测序列，i表示探测的次数

         根据类型的部分分为:

         + 线性探测法 d(i) = (+/-) i
         + 平方探测法 d(i) = (+/-) i^2
         + 随机探测法 d(i) = 伪随机序列

         ```c++
         // 线性探测法
         ```

         ```c++
         // 平方探测法
         ```

      2.  再哈希法

         当关键字 i 发生冲突时 重新计算 H(i)=RH(key) 直到不发生hash冲突时计算结束，注意不同阶段hash函数不一定相同。

      3.  链地址法

         当关键字冲突时，将相同hash值得关键字存储在一个线性链表中

     	4.  建立公共溢出区

         当关键字发生冲突时，无论什么情况，将后进入的关键字送入这个公共溢出区

   + **哈希表查找及其分析**

     ​	查找过程:

     1. 根据hash函数获取关键字位置，如果位置上没有记录则查找失败，如果由记录，则按照冲突处理方式一个一个往下找，知道找到与指定关键字相等的元素。

        ```c++
        // hash查找
        ```

        ```c++
        // 关键字的插入
        ```

     2. 装载因子相关

        装载因子alpha=表中填入的记录数/哈希表的长度

        直观的可以判断，装载因子alpha越小，发生冲突的可能性就越小。装载因子越大，重复的记录也越大。

        可以证明:

        ​	线性探测再散列的哈希表查找成功平均查找长度为

        ​		S=1/2(1+1/1-alpha)

        ​	随机探测再散列，平方探测再散列再hash的平均查找长度

        ​	   S=-1/alpha ln(1-alpha)

        ​	链地址冲突时查找成功平均查找长度为

        ​		S=1+alpha/2

        注意：

        ​	非链地址处理方案中，输入需要删除一条记录只能对记录做出标记，可以使用辅助数组来标记。

        ​	对于经常查找且规模不大的关键字集，可以获得不冲突的hash函数。

2. **静态查找表**

   + **抽象数据类型**

     ```markdown
     ADT StaticSearchTable{
     	数据元素: D是具有相同特性数据元素的集合.各个数据元素均含有类型相同,可唯一标识数据元素的关键字
     	数据关系R: 数据元素同属一个集合
     	操作集合:
     		create(StaticSearchTable &st,int n) 创建含有n个元素的静态查找表
     		destroy(StaticSearchTable &st) 释放表st
     		search(StaticSearchTable st, T key) 在静态查找表中查找指定key的元素
             traverse(StaticSearchTable st) 静态表的遍历
     }
     ```

   + **顺序表的查找**

     以顺序表以及线性链表为例,可以使用顺序查找的方式进行.
   
     **顺序查找**的查找过程为: 从表中最后一个记录开始,逐个进行关键字与给定值的比较,若两个值相等,则查找成功,反之直到第一个元素依旧查找不相等,则查找失败.
   
     ```c++
     struct Node{
       	int ele;
         Node* next;
     };
     // 第0个元素为哨兵
     /*
     	设置监视哨的目的:
     		避免查找过程中,每一步都要检测整个表是否查找完毕
     */
     Node nodes[length+1];
     void search(StaticSearchTable sst,int key){
         sst[0].ele=key;// 哨兵
         for(int i=length;sst[i]!=key;--i)
         return i;// 找不到是i为0
     }
     ```
   
     **查找操作的性能分析**
   
     算法的性能分析主要是由时间/空间复杂度绝对,查找操作中,所使用的辅助空间是有限的.因此查找操作性能的主要优化空间为关键值与给定值比较次数的期望.称之为**平均查找长度**.
   
     **ASL=sigma(P( i ),C( i ))**
   
     其中,pi为第i个记录的概率 且sigma(p( i ))=1 查询频率有外部查询分布决定
   
     在顺序表中,最后一个元素只需要比较一次,而第一个元素需要比较n次.假设n=ST.length
   
     则ASL=P1 * n+P2 * (n-1)+...+P(n)
   
     假设每个元素查找概率相等,即P(i)=1/n
   
     ​	ASL=1/n(sigma(n-i+1))=(n+1)/2
   
     上述结论是得出在查找概率相等的情况下,若查找概率不相等: 则需要对每个元素设置访问频数域,根据这个域升序排列,将访问频数高的元素放在列表后边,降低其查找长度.
   
     对于顺序查找来说,无论key给定何值,且key是否能够查询成功.其平均查询长度
   
     ​	ASL=1/2n * sigma(n-i+1) +(n+1)/2=3/4 *( n+1)
   
   + **有序表的查找**
   
     根据有序表的特性,有序表的查找可以通过**折半查找**(二分查找)来完成.主题思路为,先确定待查记录所在的范围,然后逐渐缩小范围直到找不到这条数据为止.
   
     ```c++
     int BinarySearch(StaticSearchTable sst,int key){
         int low=1,int high=length;
         while(low<=high){
             int mid=(low+high)/2;
             if(sst[mid]==key) return mid;
             else if(sst[mid]>key) high=mid-1;
             else if(sst[mid]<key) low=mid+1;
         }
         return -1;
     }
     ```
   
     **折半查找性能分析**
   
     查找成功时的平均查找长度
   
     ​	ASL=1/n+sigma( j * 2^(j-1)) = (n+1)/n * log(2) (n+1) -1
   
     ​	当n足够大的时候
   
     ​	ASL=log(2) (n+1) -1
   
     **有序表的斐波那契查找法**
   
     ```c++
     
     ```
   
     **有序表的插值查找**
   
     ```c++
     
     ```
   
   + **静态树表的查找**
   
     考虑到有序表进行查找是建立在相等概率的情景下,如果概率不相等,如何获取最优查询呢?
   
     设使得查找性能达到最佳的判定树是其带权内路径长度之和PH
   
     ​	PH=sigma(wi,hi)
   
     其中wi为第i个元素的权值,hi为i元素所在树的层数
   
     称使得PH值最小的二叉树为**静态最优查找树** 
   
     **静态最优查找树**构建方法:
   
     ```c++
     
     ```
   
     + 次优查找树的构建
   
       构建思路:
   
       ​	1. 首先在记录表(v1,v2...vn)中获取一个记录vi
   
       ​		满足deta(P i)=sigma(i+1,n,wi)-sigma(1,i-1,wi)最小
   
        	2. 对子序列(v1...v-i-1),(vi+1...vn)取节点i`作为该节点的左子树和右子树
   
       ```c++
       // 次优查找树的构建方法
       ```
   
   + **索引顺序表的查找**(分块查找)
   
     ```c++
     // 分块查找
     ```
   
     **查找性能分析**
   
     ​	ASL=L(block) +L(index)=1/b*sigma(j)+1/s *sigma(i)=1/2(n/s+s)+1
   
     使用折半查找确定所在的块
   
     ​	**ASL=log(2)(n/s+1)+s/2**
   
   
   
3. **动态查找表**

   + **二叉查找树**

     ```c++
     // 二叉查找树数据查询
     ```

     二叉查找树平均查找长度

     ​	ASL<=2(1+1/n)* ln n

   + **平衡二叉树**

     ```c++
     // 平衡二叉树的构成
     // 平衡二叉树的数据查询
     ```

     平衡二叉树平均查找长度

     ​	ASL=log(2) n

   + **B-树以及其查找**

     1. B-树

        B-树是一种平衡的多路查找树,在文件系统里很有用.

        一颗m阶的B-树,或为空树,或满足如下特征的m叉树.

        + 树中每个节点有至多m个子树

        + 若根节点不是叶子节点,则至少有两个子树

        + 非根节点且非叶子节点,每个节点至少要有ceil ( m/2 )棵子树

        + 所有的非叶子节点包含如下的信息:

          n (A1,K1,A2,K2...An,Kn)

          其中Ai表示指向子树的根节点指针,ki表示关键字

          其中Ai-1所有子树的关键字都小于Ki,An所有子树的关键字都大于Kn.,n为关键字的个数.
   
        ```c++
     // B- 树的构成与查找
        Node* SearchBTree(BTree T,int key){
            
        }
        ```
        
        查询性能分析:
        
        在B-树上进行查找,主要分为两个部分,一部分是在B-树中寻找节点,这一步分通常在磁盘上进行.另一部分实在节点列表中寻找关键字,这部分通常在内存中完成.一般情况的分析可以参照平衡二叉树,讨论深度为l+1的m阶B-树所具有的最少节点数,每个非叶子节点至少包含ceil(m/2)棵子树.若m阶B-树中有n个关键字,叶子节点(查询失败的节点为N+1)
        
        ​	N+1>=2 * (ceil(m/2))^(l-1)
        
        可以得到关系:
        
        ​	l<=log(m/2) [(N+1)/2] +1
        
        也就树形成的B树层数不会超过上述锁表达的树.
        
        **B- 树节点的增删操作**
        
        B-树的生成有空树开始,逐渐插入关键字得到.但是由于B-树的关键字数量必须要>=ceil[m/2]-1,因此每次插入一个元素不是添加一个叶子节点。而是在最底层的某个非叶子节点插入一个关键字。若节点的关键字个数不超过m-1.则插入完成。否则会**分裂**。
        
        分裂的实现思路:
        
        ​	假设p点有m-1个关键字，写入一个关键字后，节点中含有的信息为
        
        ​		m,A0,(A1,K1)...(Am,Km)
        
        ​	这可以将p节点分裂成p和px两个节点
        
        ​	其中p中包含信息
        
        ​		len= ceil(m)-1 A0,(A1,K1),(A2,K2)...(A(len),K(len))
        
        ​	其中px节点包含信息
        
        ​		len2=m-ceil(m) (A(len),K(len)...(Am,Km))
        
        ```c++
        // B-树增加关键字操作
        ```
        
        反之，考虑如何从一颗B-树中移除一个关键字。首先找到该关键字的节点，并从中删除，如果该节点为最底层的非叶子节点，且其中关键字数目小于ceil(m/2)，则删除完成。否则要进行合并的操作。
        
        ​	假设所删关键字为非叶子节点的Ki，可以指针Ai所指向子树最小的关键字Y。用Y来代替K。然后在相应节点中删除Y。就完成了基本的合并操作。
        
        ​	对应于不同情况下，节点的移动分成如下情况讨论:
        
        	1. 删除点中的关键字数目不小于ceil(m/2)，直接从节点中移除关键字Ki以及相关指针Ai即可。
         	2. 被删除的关键字数目等于ceil(m/2)-1,需要将兄弟节点中最小的关键字上移至双亲节点中，而将双亲节点中小于且紧靠该上移关键字的关键字下移动到被删除关键字处。
         	3. 被删除节点的兄弟节点关键字数目均等于ceil(m,2)-1。假如该节点有右兄弟节点，且该右兄弟节点的地址有双亲节点指针Ai所指向，则在删除关键字后，其所在节点中剩余的关键字和指针，加上双亲节点的关键字Ki一起，合并到右兄弟中。
   
   + **B+树**
   
     B+ 树的定义:
   
     B+ 树是一种B-树的变型树，一颗m阶的B+树和m阶的B-树之间的差距在于。
   
     1. n个子树节点中具有n个关键字
     2. 所有叶子节点中包含了所有的关键字信息，且只需含有这些关键字记录的指针。且叶子节点本身按照关键字大小顺序排列。
     3. 所有非叶子节点都可以看成是索引部分，节点中含有其子树中的最大/最小关键字。
   
     + B+树通常包含有两个指针，一个指针指向根节点（root）用户对关键字进行随机查找。另一个指针指向关键字最小的叶子节点，可以从最小关键字进行顺序查找。
   
     + B+树的查找以及增删与B-树类似，只是在查找时，非叶子节点关键字等于给定关键字，不会停止知道查找到叶子节点。
     + B+ 树关键字插入时，当个数大于m时，分裂成得两个部分为ceil((m+1)/2).
   
     ```c++
     // B+树的操作集
     ```
   
   + **键树**(**数字查找树**)
   
     1. 键树的描述
   
        + **孩子兄弟链表**
   
          每个分支节点包含三个域	
   
          ​	symbol域-- 存储关键字一个字符
   
          ​	first域-- 存储指向第一个子树的指针
   
          ​	next域-- 指向兄弟的指针
   
          ​	叶子节点的infoptr域指向该关键字记录的指针
   
          ```c++
          // 孩子兄弟链表的数据结构
          const enum{Leaf,NoLeaf} Tag;
          struct Node{
            Tag isLeaf;
            char symbol;
            Node* first;
            Node* next;
            Record* infoptr;
          };
          ```
   
          ```c++
          // 键树构成以及数据查找/增删算法
          ```
   
        + **Trie树**
   
          **定义**: 以树的多重链表表示键树，则树的每个节点隐包含有d个指针域（d是节点的最大度，与关键字的基有关，关键字为单词时则d=27）。
   
          **路径压缩**: 键树中某个节点到叶子节点路径上每个节点都有一个孩子，则将该路径压缩成一个叶子节点。且叶子节点存储的关键字执行记录指针infoptr信息。
   
          **查找过程**: 从根节点开始，沿着给定值相应的指针逐层向下，直到叶子节点为空。或叶子节点的关键字与给定值不等，则查找不成功。如果叶子节点的关键字与给定值相等，则查找成功。
   
          ```c++
          // Trie树数据结构
          ```
   
          ```c++
          // Trie树数据查找
          ```
   
          ```c++
          // Trie树的数据增删
          ```
   
          



