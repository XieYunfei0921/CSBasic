1. **哈希表**

   + 基本概念

   查找的理想情况下，是不经过任何的比较，一次边存取所查询的记录。那就必须建立起记录存储位置与它的关键字所对应的关系f。使每个关键字与结构中唯一一个存储位置相对应。称这个对应关系f为**哈希函数**。

   对于key1!=key2 但是f(key1)=f(key2)这种情况称作**哈希冲突**。而一般情况下，冲突是存在的但是需要尽可能的减小，才算是好的哈希函数的标准。

   根据设定的哈希函数H（key) 以及冲突处理的方法，将一组关键字映射到有限连续的地址集上，并以关键字在地址集中的像作为记录在表中的位置，这种表称作**哈希表**。这个过程叫做**散列**，所得位置称作**哈希地址**或者**散列地址**。

   + 哈希函数的构造方法

     好的哈希函数的标准: 对应关键字集合中的任意一个关键字，进过哈希函数映像到地址集合中任意一个地址的概率是相等的。此类哈希函数为均匀的哈希函数。也就是说，关键字从哈希函数中获得了随机的地址从而减小哈希冲突的可能性。

     几种常见的哈希函数:

     1.  直接定址法

        H(key) = key 或 H(key) =a*key+b

        这也叫做自身函数,这种哈希函数哈希冲突是不存在的，但是当关键字分布过于离散，对于存储空间的要求是非常大的。 

     2.  数字分析法

     3.  平方取中法

        取关键字平方后中间几位为哈希地址。通常在选定哈希函数时，不知道关键字的全部情况，也不知道该取其中哪几位，而一个数平方后中间几位与数的每一位都相关。由此随机出来的关键字得到的hash地址也是随机的。平方取中的位数由hash表长来决定。

        ```c++
        // 平方取中法hash
        ```

     4.  折叠法

        将关键字分割成位数相同的几个部分之后(最后一部分可以位数不同),取这几个部分的叠加和为哈希地址，这种方法称为**折叠法**。适用于关键字位数很多，且关键字中每一位数字分布大致均匀的情况下。

        ```c++
        // 折叠法hash
        ```

     5.  除余取留法

        H(key)= key MOD p （p<= m） m是表长

        p的选取与冲突出现的可能性有关。且p，最好要是素数。

     6. 随机数法

        H（key)=random(key)

        适用于关键字长度不相等时。

     几种冲突解决策略:

      1.  开发定址法

         当关键字出现冲突时,重设关键字的hash地址

         H(key)`=(H(key)+ d(i)) MOD m

         其中d(i) 是探测序列，i表示探测的次数

         根据类型的部分分为:

         + 线性探测法 d(i) = (+/-) i
         + 平方探测法 d(i) = (+/-) i^2
         + 随机探测法 d(i) = 伪随机序列

         ```c++
         // 线性探测法
         ```

         ```c++
         // 平方探测法
         ```

      2.  再哈希法

         当关键字 i 发生冲突时 重新计算 H(i)=RH(key) 直到不发生hash冲突时计算结束，注意不同阶段hash函数不一定相同。

      3.  链地址法

         当关键字冲突时，将相同hash值得关键字存储在一个线性链表中

     	4.  建立公共溢出区

         当关键字发生冲突时，无论什么情况，将后进入的关键字送入这个公共溢出区

   + **哈希表查找及其分析**

     ​	查找过程:

     1. 根据hash函数获取关键字位置，如果位置上没有记录则查找失败，如果由记录，则按照冲突处理方式一个一个往下找，知道找到与指定关键字相等的元素。

        ```c++
        // hash查找
        ```

        ```c++
        // 关键字的插入
        ```

     2. 装载因子相关

        装载因子alpha=表中填入的记录数/哈希表的长度

        直观的可以判断，装载因子alpha越小，发生冲突的可能性就越小。装载因子越大，重复的记录也越大。

        可以证明:

        ​	线性探测再散列的哈希表查找成功平均查找长度为

        ​		S=1/2(1+1/1-alpha)

        ​	随机探测再散列，平方探测再散列再hash的平均查找长度

        ​	   S=-1/alpha ln(1-alpha)

        ​	链地址冲突时查找成功平均查找长度为

        ​		S=1+alpha/2

        注意：

        ​	非链地址处理方案中，输入需要删除一条记录只能对记录做出标记，可以使用辅助数组来标记。

        ​	对于经常查找且规模不大的关键字集，可以获得不冲突的hash函数。

2. **静态查找表**

   + **抽象数据类型**

     ```markdown
     ADT StaticSearchTable{
     	数据元素: D是具有相同特性数据元素的集合.各个数据元素均含有类型相同,可唯一标识数据元素的关键字
     	数据关系R: 数据元素同属一个集合
     	操作集合:
     		create(StaticSearchTable &st,int n) 创建含有n个元素的静态查找表
     		destroy(StaticSearchTable &st) 释放表st
     		search(StaticSearchTable st, T key) 在静态查找表中查找指定key的元素
             traverse(StaticSearchTable st) 静态表的遍历
     }
     ```

   + **顺序表的查找**

     以顺序表以及线性链表为例,可以使用顺序查找的方式进行.
   
     **顺序查找**的查找过程为: 从表中最后一个记录开始,逐个进行关键字与给定值的比较,若两个值相等,则查找成功,反之直到第一个元素依旧查找不相等,则查找失败.
   
     ```c++
     struct Node{
       	int ele;
         Node* next;
     };
     // 第0个元素为哨兵
     /*
     	设置监视哨的目的:
     		避免查找过程中,每一步都要检测整个表是否查找完毕
     */
     Node nodes[length+1];
     void search(StaticSearchTable sst,int key){
         sst[0].ele=key;// 哨兵
         for(int i=length;sst[i]!=key;--i)
         return i;// 找不到是i为0
     }
     ```
   
     **查找操作的性能分析**
   
     算法的性能分析主要是由时间/空间复杂度绝对,查找操作中,所使用的辅助空间是有限的.因此查找操作性能的主要优化空间为关键值与给定值比较次数的期望.称之为**平均查找长度**.
   
     **ASL=sigma(P( i ),C( i ))**
   
     其中,pi为第i个记录的概率 且sigma(p( i ))=1 查询频率有外部查询分布决定
   
     在顺序表中,最后一个元素只需要比较一次,而第一个元素需要比较n次.假设n=ST.length
   
     则ASL=P1 * n+P2 * (n-1)+...+P(n)
   
     假设每个元素查找概率相等,即P(i)=1/n
   
     ​	ASL=1/n(sigma(n-i+1))=(n+1)/2
   
     上述结论是得出在查找概率相等的情况下,若查找概率不相等: 则需要对每个元素设置访问频数域,根据这个域升序排列,将访问频数高的元素放在列表后边,降低其查找长度.
   
     对于顺序查找来说,无论key给定何值,且key是否能够查询成功.其平均查询长度
   
     ​	ASL=1/2n * sigma(n-i+1) +(n+1)/2=3/4 *( n+1)
   
   + **有序表的查找**
   
     根据有序表的特性,有序表的查找可以通过**折半查找**(二分查找)来完成.主题思路为,先确定待查记录所在的范围,然后逐渐缩小范围直到找不到这条数据为止.
   
     ```c++
     int BinarySearch(StaticSearchTable sst,int key){
         int low=1,int high=length;
         while(low<=high){
             int mid=(low+high)/2;
             if(sst[mid]==key) return mid;
             else if(sst[mid]>key) high=mid-1;
             else if(sst[mid]<key) low=mid+1;
         }
         return -1;
     }
     ```
   
     **折半查找性能分析**
   
     查找成功时的平均查找长度
   
     ​	ASL=1/n+sigma( j * 2^(j-1)) = (n+1)/n * log(2) (n+1) -1
   
     ​	当n足够大的时候
   
     ​	ASL=log(2) (n+1) -1
   
     **有序表的斐波那契查找法**
   
     ```c++
     
     ```
   
     **有序表的插值查找**
   
     ```c++
     
     ```
   
   + **静态树表的查找**
   
     考虑到有序表进行查找是建立在相等概率的情景下,如果概率不相等,如何获取最优查询呢?
   
     设使得查找性能达到最佳的判定树是其带权内路径长度之和PH
   
     ​	PH=sigma(wi,hi)
   
     其中wi为第i个元素的权值,hi为i元素所在树的层数
   
     称使得PH值最小的二叉树为**静态最优查找树** 
   
     **静态最优查找树**构建方法:
   
     ```c++
     
     ```
   
     + 次优查找树的构建
   
       构建思路:
   
       ​	1. 首先在记录表(v1,v2...vn)中获取一个记录vi
   
       ​		满足deta(P i)=sigma(i+1,n,wi)-sigma(1,i-1,wi)最小
   
        	2. 对子序列(v1...v-i-1),(vi+1...vn)取节点i`作为该节点的左子树和右子树
   
       ```c++
       // 次优查找树的构建方法
       ```
   
   + **索引顺序表的查找**(分块查找)
   
     ```c++
     // 分块查找
     ```
   
     **查找性能分析**
   
     ​	ASL=L(block) +L(index)=1/b*sigma(j)+1/s *sigma(i)=1/2(n/s+s)+1
   
     使用折半查找确定所在的块
   
     ​	**ASL=log(2)(n/s+1)+s/2**
   
     
   
     
   
     