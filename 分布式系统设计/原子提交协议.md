> 分布式事务结束的时候,它的操作要不全部执行，要不全部不执行.

#### 单阶段提交协议

以原子方式完成事务的一种简单方法就是让协调者不断地向所有参与者发送**提交**或者**放弃**请求,直到所有参与者确认已经执行完相应的操作.

> **缺陷**: 协议不允许服务单方面的放弃事务.
>
> **场景1:** 系统由于基础死锁的需要放弃事务,但是协调者发起请求的时候不知道参与者已经放弃事务.
>
> **场景2**: 某个服务器采用了乐观并发控制,由于失败导致了事务的放弃,但是这个参与者仍然在协调者的列表中.仍旧发送了请求.

#### 两段式提交协议

针对单阶段提交协议的缺陷,提出了两段式提交协议

**阶段一**: 协调者询问参与者是否做好准备,即投票阶段 ,如果任意一台没有准备好，就投了No的票,事务就会放弃

**阶段二**: 协调者通知参与者提交或者放弃事务,参与者执行完操作之后向协调者汇报事务已经处理.

> **投票阶段**:
>
> 1.  协调者向分布式事务所有参与者发送消息,确认每个参与者是否可以提交
> 2.  参与者可以投Yes/No,在投Yes之前,参与者在持久化存储中保存所有对象,并准备提交.投No则放弃
>
> **执行阶段**
>
> 1. 协调者收集所有的参与者投票信息
>    + 如果有一个投了No,或者存在有故障的参与者,放弃事务
>    + 否则提交事务







#### 协调和协定

##### 分布式互斥

1. **中央服务器算法**

   实现分布式互斥最简单的方法:

   使用一个服务器授予进入临界区的许可.这个时候,进入临界区就变成,一个进程向这个中央服务器发送消息并等待消息的应答.

   如果请求的时候没有其他进程持有这个令牌,服务器就会立即授予令牌.

   如果另一个进程持有令牌,服务器就会把这个线程置入等待队列.注意到这个等待队列应当设计为FIFO队列,避免出现某个进程长期不能被调度.

   <img src="E:\截图文件\中央服务器算法.png" style="zoom:67%;" />

2. **基于环的算法**

   在N个进程中安排互斥且不需要其他进程的方式就是:

   将这些进程安排在一个逻辑上的环上.这样只要求进程Pi和进程P(i+1)有一个通信信道.该方法的思想是,通过获取进程间沿着**环单向传递的消息**形式的令牌实现互斥.可以视为Pi ->你P(i+1)这条弧.

   <img src="E:\截图文件\基于环的算法.png" style="zoom:67%;" />

3. **基于组播和逻辑时钟的算法**

   这个算法实现了对N个对等进程间互斥的算法.

   算法的基本思想为对即将进入临界区的进程组播一个请求消息，并且只有当其他进程都回答了这个消息的时候才能够进入。

4. **Maekawa算法**

   为了进入一个临界区,不必要求所有对等进程都同意.

   只要任意两个进程使用的子集有重叠，进程只需要等待进程子集获得准入即可。所以这样可以理解成互相选举的模型，即两个相交的集合交集中只需要选择一个即可。

##### 选举

选择一个唯一的进程扮演特定角色的算法称为**选举算法**

1. **基于环的选举算法**

   假定没有故障发生，且系统是异步的。

   该算法的目标是选举一个**协调者**，特征是具有最大标识符的进程。

   起始状态下，每个进程被标记为**非参与者**，任何进程都可以开始一次选举。将其标记为参与者，然后把自己的标识符放置到一个**选举**消息中去,并顺时针地发送给它的邻居.

   当一个进程收到一个选举消息的时候，会比较消息中的标识符和自己的标识符。如果到达的标识符较大，则将消息转发给邻居。

   如果消息的标识符小，且接受进程不是一个参与者，就把消息中的标识符替换为自己，并转发消息，当节点转发消息的时候，标记自己为参与者。

2. **霸道算法**

   假定进程间消息发送是可靠的，但是允许选举期间进程崩溃.并且假定系统时同步的.

   明确自己是最大标识符的进程可以发送协调者消息给所有较小标识符的进程,让其选举自己为协调者.此外,具有较小标识符的进程通过发送选举消息给那些具有较大标识符的进程,这样开启一次选举,并等待应答.

   如果消息在T时间内没有得到响应,则认为自己是协调者,并通知其他较小标识符的进程.否则需要等待T1时间,用于接收新的协调者发来的信息.

   由于具有最大标识符,就选自己为协调者,所以称作霸道算法.

##### 分布式事务的并发控制

1. **加锁**

   分布式事务中某个对象的锁总是本地特有的，是否加锁取决于本地锁管理器决定。本地锁管理器决定是否满足客户对锁的请求，还是让发出请求的事务等待。

   事务在服务器上提交或者放弃之前是不能被释放的。

   使用加锁机制的并发控制中，原子提交协议进行的时候对象一直被锁定，如果第一阶段就放弃执行可以提前释放锁。

2. **时间戳并发控制**

   分布式事务中，协调者必须保证每个事务带上全局唯一的时间戳。全局唯一的时间戳由第一个协调者分配。

   这样，即使每个服务器的本地时钟不同步，也能保证事务的正常进行。

   为了提升效率，尽量时间戳同步。

3. **乐观并发策略**

   乐观并发控制中，每个事务提交之前必须进行同步。事务在验证之前需要添加一个事务编号，事务编号是事务串行化的基础。由一组独立的服务器共同完成，每个服务器验证访问自己对象的事务。

   在2PC的第一阶段完成。