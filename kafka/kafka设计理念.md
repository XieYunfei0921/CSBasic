#### 持久化

kafka依赖于文件系统去存储和缓存消息.但是通识上来说磁盘读写缓慢的.为了弥补性能上的差异,现代OS在主存中进行磁盘缓存(**高速缓存**).现代OS会分配空闲内存空间给磁盘缓存.所有磁盘的读写都会通过主存进行.这个功能不能直接由关闭IO完成,所以尽管处理过程维护了处理中的数据缓存,这些数据会在OS的页缓存中备份,可以高效地存储两次.

进一步,来说,可以在JVM的基础上进行构建,使用java内存是需要注意到两点

1. 对象存储在内存中开销非常大,经常是数据存储的两倍
2. 随着堆内数据的增加,GC变得更加的缓慢

因此,需要同时使用文件系统和依赖页缓存.如果服务重启缓存保持运行.

消息系统中使用的持久化的数据结构,经常每个消费都会使用一个B树或者生成其他随机数去维护消息的元数据.B树是最通用的数据结构,可以获取消息系统中大量的事务/非事务语义.查找的时间复杂度为O(log N).正常情况下基本上等于是个常数时间,但是对于磁盘操作来说并不是这样.磁盘查找需要10ms,且每个磁盘同一时刻只允许一次查找,所以并行度被限制.假定磁盘查找需要大量的开销.因此存储系统混合了高速缓存和慢速的磁盘查找.

持久化的队列可以被简单的读取并添加到文件中.这个数据结构认为所有的操作都是O(1)的时间复杂度,且读取不会阻塞写出和其他操作.尽管如此,查找的性能仍然很大,这样在大量的读写情况下,使用1/3的代价和3倍的容量.

为了获取虚拟磁盘空间,提供一些消息系统中不常使用的功能.例如,kafka中数据不是消费完毕就会删除的,而是需要保持一定的周期,这个会对消费者提供很大的处理灵活性.

#### 高效

主要通过处理web的激活的数据,这个数据的量比较大,每个分页都会产生大量的写出操作,此外,假定每条消息都被至少一个消费者.

注意影响系统效率的主要行为许多小的IO操作,以及过多的字节拷贝工作.

小IO问题发生在客户端和服务器之间且用于服务器自己的持久化操作.为了避免这种情况，协议中围绕着**消息集合**进行抽象。

这个会自然的将消息聚合在一起，允许网络将组消息聚合在一起且分担网络开销，而不是同一个时间仅仅发送一条消息。在服务器运行的时候，服务器会轮流地添加消息块到日志中，消费者会获取一个数据块的消息。

这个简单的优化会加速生成的幅度。批量获取会生成更大的网络数据包以及较大的磁盘操作以及连续的数据块。kafka可以将其转换为随机的消息写入到消费者的工作流中。

另一个低效的操作就是字节拷贝了，关键的问题是加载数据的时候影响较大。为了避免这种情况下，使用标准的二进制消息格式，这个可以被生产者，broker，消费者共享。因此数据块的传输可以不修改的进行。由broker维护的消息日志仅仅是一个文件目录，消息集序列会被写入到磁盘中，生产者和消费者的消息形式相同。

理解发送文件的影响，重点是理解通用数据意义：

1. 操作系统读取磁盘数据到内核的页缓存中
2. 应用从内核空间读取数据到用户缓冲区中
3. 应用将数据写回内核中
4. 操作系统复制socker缓冲区的数据到一个NIC缓冲区中，这里可以通过网络发送数据

这个是低效的，有4次拷贝以及两个系统调用。使用发送文件的方式，通过使用OS发送页缓存的数据到网络中，重新拷贝被避免了。所以在这个优化路径中，仅仅最后需要拷贝到NIC缓冲区中。

希望对多个消费者进行通用的操作。使用**零拷贝**的优化技术，数据仅仅会拷贝到页缓存中一次，且在每次消费的时候会重新使用（而不是存储在内存中，每次需要拷贝到用户空间中）。这个允许消息按照一定的比率进行消费。

页缓存和发送文件的联合使用意味着kafka集群中可以在磁盘上没有读取的操作，因为可以通过缓存的范式进行数据服务。

#### 端对端的批次压缩

在一些情况下，性能瓶颈不是CPU或者磁盘而是网络的带宽。这个对于pipeline来说，需要通过广域网的数据中心发生数据。当然，用于可以将消息压缩，但是压缩比率可能很低。高效的压缩需要压缩多个消息而不是单条的进行压缩。kafka支持高效的批格式处理，一批消息可以一起压缩且按照这个格式发送到服务器。批次的消息会被写入，且在日志中保留着压缩的形式，且只有消费者可以对其进行解压缩。

kafka支持Gzip，Snappy，lz4，zStandard压缩协议。

#### 生产者

##### 负载均衡

生产者直接将消息发送到broker中，这个broker是分区的leader，且没有任何的中间路由层。为了帮助生产者进行这个操作，kafka节点可以回应元数据关于服务器存活状态以及leader的位置信息的请求。客户端控制发布消息的分区信息，这个可以随机处理，由随机的负载均衡处理，可以被分区函数的语义处理。这里保留分区语义的接口，允许用于指定分区的key，且使用hash进行分区。这个可以允许消费者去进行消费的位置假设。分区的方式可以显示地允许消费者的位置感知处理。

##### 异步发送

批量处理具有高效的特性，为了开启kafka的批量处理，生产者需要在内存中累加数据，且需要在单次请求中发送大批量数据。这个批次可以设置为指定数量的消息，或者是等待指定时间范围的消息(例如 64K或者 10ms)。这样会降低服务器的IO操作次数，配置缓存且获取更高的吞吐量。

#### 消费者

##### 推送和拉取数据的比较

##### 消费者位置指针

##### 离线数据负载

##### 静态关系

#### 消息传输语义

#### 副本

##### 副本日志(Quorum,ISR,状态机)

##### 未清除的leader选举

##### 可用性和持久性保证

##### 副本管理

#### 日志合并

##### 日志合并基础

##### 日志合并功能

##### 日志合并细节

##### 配置日志清理器

