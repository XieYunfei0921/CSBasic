**虚拟机字节码执行引擎**

---

在不同虚拟机实现中，执行引擎在执行字节码的时候，通常会有解释执行和编译执行的选择。但是输入输出都是一致的，输入的是字节码二进制流，输出流过程是字节码解释执行的过程。输出的是执行结果。

#### 运行时栈帧结构

栈帧是用于支持虚拟机进行方法调用和执行的数据结构，是虚拟机栈的栈元素，存储了方法的**局部变量表**，**操作数栈**，**动态连接**，**方法返回地址**以及额外的附加信息。编译源码的时候，栈帧需要多大的局部变量表，多深的操作数栈已经被计算处理，并写入到方法表的code属性中。也就是说，一个栈需要分配多少内存，并不会收到运行期变量数据的影响，仅仅取决于程序源码和具体虚拟机栈内存分布情况。

+ 局部变量表

  局部变量表是一组变量值的存储空间,用于存放方法参数和方法内部定义的局部变量.在Java程序被编译为Class文件时,就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。 

  局部变量表的变量以**变量槽**为最小单位,虚拟机规范中没有指出变量槽占用的内容大小空间,但是变量槽只能存放一个`boolean`,`byte`,`char`,`short`,`int`,`float`,`reference`,`returnAddress`类型的数据.可以使用32位或者更小的物理内存来存储,这个描述与**每个变量占用32位内存**有区别，它允许变量槽的长度随着处理器，操作系统或虚拟机实现不同发生变化，保证了即使在64位物理内存空间实现一个变量槽，仍然需要根据虚拟机的不同发生变化，虚拟机需要使用**对齐**和**补白**的手段让变量槽在外观上开启了与32位虚拟机一致。

  栈帧的结构:

  <img src="E:\截图文件\栈帧结构.png" style="zoom:67%;" />

  reference类型在虚拟机规范中没有说明其长度,也没有明确引用的结构,一般来说,虚拟机实现至少应该通过这个引用做到两件事情.

  一是根据引用直接或者间接查找对象在java堆存放的起始地址,而是根据引用直接或者间接查找对象所属数据类型在方法区中的存储类型信息.

  对于64位数据类型,java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间,java中明确的64位数据类型只有long/double,允许将long/double数据类型分两次32位写入.

  由于局部变量表是建立在线程堆栈中的,属于线程私有数据,物理读写两个变量槽是否为原子操作,都不会产生线程安全的问题.

  java虚拟机通过索引定位的方式使用局部变量表,索引值是0到局部变量最大变量槽数,如果是32位数据类型的变量,索引N就代码第N个变量槽,如果是64位变量槽,就代表是第N和第N+1个变量槽.

  为了节省栈帧的耗用空间,局部变量表中变量槽是可以重用的,方法体中定义的变量,作用范围不一定是覆盖整个方法体.如果字节码PC计数器超出了某个变量的作用域,这个变量对应的变量槽就可以交给其他变量重用.

  但是这样的复用可能会影响垃圾回收.

  ```java
  public static void main(String[] args)() {
      byte[] placeholder = new byte[64 * 1024 * 1024];
      System.gc();
  }
  ```

  使用虚拟机参数`-verbose:gc`查看垃圾回收过程

  ```shell
  [GC 66846K->65824K(125632K), 0.0032678 secs]
  [Full GC 65824K->65746K(125632K), 0.0064131 secs]
  ```

  可以看到placeholder并没有回收.

  做出修改

  ```java
  public static void main(String[] args)() {
      {
      	byte[] placeholder = new byte[64 * 1024 * 1024];
      }
      System.gc();
  }
  ```

  执行结果

  ```shell
  [GC 66846K->65888K(125632K), 0.0009397 secs]
  [Full GC 65888K->65746K(125632K), 0.0051574 secs]
  ```

  加上花括号之后,超出了作用域,应当内存被回收,但是由于复用的情况并没有回收.

  接着修改:

  ```java
  public static void main(String[] args)() {
      {
          byte[] placeholder = new byte[64 * 1024 * 1024];
      }
      int a = 0;
  	System.gc();
  }
  ```

  ```shell
  [GC 66401K->65778K(125632K), 0.0035471 secs]
  [Full GC 65778K->218K(125632K), 0.0140596 secs]
  ```

  加上一个临时变量后,就被回收掉了,这种情况相当于使用临时变量打断了GC root与placeholder的连接.使其被回收.

+ 操作数栈

  也叫做**操作栈**,是一个后入先出的栈.与局部变量表一样,操作数栈最大深度在编译时写入到Code属性中的`max_stacks`数据项中.操作数栈每一个元素都可以是double/long类型数据.32位数据内存占1个栈容量.64位数据类型栈容量为2.

  方法执行的过程中会有各种字节码指令向操作栈中写入和提取内容.操作数栈中的数据类型必须与字节码指令序列严格匹配,编译器在编译的时候还需要进一步的检查.

  另外,两个不同的栈帧为不同方法的虚拟机栈元素,是独立的,在大多数虚拟机实现中都会进行优化.另两个栈出现重合.当两个栈帧出现重合的时候,可以节约部分空间,重要的是进行方法调用的时候可以共享数据,这样就不用额外的进行参数复制了.

  两个栈帧的数据共享:

  <img src="E:\截图文件\栈帧重合.png" style="zoom:67%;" />

+ 动态连接

  每个栈帧包含一个**指向运行时常量池中该栈帧所属方法引用**,持有这个引用是为了支持方法过程中的**动态链接**.

  class文件中的常量池存在大量符号引用,字节码中方法调用指令以常量池中执行方法的符号作为参数,这些符号引用一部分会在类加载阶段转换为**直接引用**.另一部分在运行期间转化为直接引用,这部分叫做动态链接.

+ 方法返回地址

  方法开始执行之后可以有两种方式退出

  + 执行引擎遇到任意一个方法返回字节码指令,这种方式叫做**正常调用完成**
  + 方法执行过程中遇到了异常,这个异常没有在方法体中得到妥善处理.称作**异常调用完成**.不会给上层调用者提供任何返回值.

  无论哪种方式,方法退出后,必须返回到最初方法调用的位置,程序才可以继续进程.

#### 方法调用

##### 解析

可以在类加载阶段被转换为直接引用的方法的调用叫做**解析**.这些方法,在程序写好,编译器进行编译的时候就确定下来,主要有**静态方法**,**私有方法**,**实例构造器**,**父类方法**,以及**final修饰的方法**.对应的字节码指令为`invokestatic`,`invokespecial`,`invokevirtual`,`invokeinterface`

实例代码:

```java
/**
* 方法静态解析演示
**
*/
public class StaticResolution {
    public static void sayHello() {
    	System.out.println("hello world")
    }
    public static void main(String[] args) {
    	StaticResolution.sayHello();
    }
}
```

使用javap指令查看程序对应的字节码可以反向,是听过`invokestatic`调用的sayHello方法

```shell
javap -verbose StaticResolution
public static void main(java.lang.String[]);
    Code:
        Stack=0, Locals=1, Args_size=1
        0: invokestatic #31; //Method sayHello:()V
        3: return
    LineNumberTable:
        line 15: 0
        line 16: 3
```

解析调用一定是一个静态过程,编译期间就会确定.类加载的解析阶段就会将符号引用转换为直接引用.不需要到运行期间完成.

##### 分派

+ 静态分配

  所有依赖今天类型决定方法执行的分配动作,叫做静态分派.典型的示例为方法重载,发生在编译阶段.因此确定今天分配的动作不是由虚拟机执行的,有时候会被划分到解析阶段.

  示例:

  ```java
  package org.fenixsoft.polymorphic;
  /**
  * 方法静态分派演示
  */
  public class StaticDispatch {
      static abstract class Human {
      } 
      static class Man extends Human {
      } 
      static class Woman extends Human {
      } 
      public void sayHello(Human guy) {
      	System.out.println("hello,guy!");
      } 
      public void sayHello(Man guy) {
      	System.out.println("hello,gentleman!");
      }
      public void sayHello(Woman guy) {
      	System.out.println("hello,lady!");
      } 
      public static void main(String[] args) {
          Human man = new Man();
          Human woman = new Woman();
          StaticDispatch sr = new StaticDispatch();
          sr.sayHello(man);
          sr.sayHello(woman);
      }
  }
  ```

  执行结果:

  ```shell
  hello,guy!
  hello,guy!
  ```

  两条指令都是编译器加载的,所以都是Human类型.

  编译器选择重载的版本不一定是唯一的,会在重载列表中选择一个合适的方法载入.

  例如:

  ```java
  public class Overload {
      public static void sayHello(Object arg) {
      	System.out.println("hello Object");
      } 
      public static void sayHello(int arg) {
      	System.out.println("hello int");
      } 
      public static void sayHello(long arg) {
      	System.out.println("hello long");
      } 
      public static void sayHello(Character arg) {
      	System.out.println("hello Character");
      } 
      public static void sayHello(char arg) {
      	System.out.println("hello char");
      } 
      public static void sayHello(char... arg) {
      	System.out.println("hello char ...");
      } 
      public static void sayHello(Serializable arg) {
      	System.out.println("hello Serializable");
      } 
      public static void main(String[] args) {
      	sayHello('a');
      }
  }
  ```

  输出结果:

  ```shell
  hello char
  ```

  但是当注释掉`void sayHello(char arg)`方法的时候,会选择去重载版本`void sayHello(int arg)`,输出结果为:

  ```shell
  hello int
  ```

  继续注释

  ```shell
  hello long
  ```

  继续注释

  ```shell
  hello Character
  ```

  继续注释

  ```shell
  hello Serializable
  ```

  继续注释

  ```shell
  hello Object
  ```

  重载的顺序为char-> int -> long -> Character -> Serializable -> Object

  选择的顺序时子类-> 父类,范围小的基本数据类型-> 范围大的数据类型

+ 动态分配

  动态分配重要体现在**重写**.

  示例:

  ```java
  public class DynamicDispatch {
      static abstract class Human {
          protected abstract void sayHello();
      } 
      static class Man extends Human {
          @Override
          protected void sayHello() {
              System.out.println("man say hello");
          }
      } 
      static class Woman extends Human {
          @Override
          protected void sayHello() {
       	   System.out.println("woman say hello");
          }
      } 
      public static void main(String[] args) {
          Human man = new Man();
          Human woman = new Woman();
          man.sayHello();
          woman.sayHello();
          man = new Woman();
          man.sayHello();
      }
  }
  ```

  运行结果

  ```java
  man say hello
  woman say hello
  woman say hello
  ```

  main方法的字节码文件

  ```java
  public static void main(java.lang.String[]);
  Code:
  Stack=2, Locals=3, Args_size=1
  0: new #16; //class org/fenixsoft/polymorphic/DynamicDispatch$Man
  3: dup
  4: invokespecial #18; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man."<init>":()V
  7: astore_1
  8: new #19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman
  11: dup
  12: invokespecial #21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman."<init>":()V
  15: astore_2
  
  16: aload_1
  17: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
  20: aload_2
  21: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
  24: new #19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman
  27: dup
  28: invokespecial #21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman."<init>":()V
  31: astore_1
  32: aload_1
  33: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
  36: return
  ```

  0-15是准备动作,创建man和woman的内存空间,调用man和woman的示例构造器.对应于java中的.

  ```java
  Human man = new Man();
  Human woman = new Woman();
  ```

  16,20将创建的两个对象压入栈定,17和21行是方法调用指令.虽然都是sayHello()方法,但是与最终知晓的目标方法并不相同.需要明确`invokevirtual`的指令

  这个指令解析过程分为如下几步:

  + 找到操作数栈的第一个元素知晓的对象的实际类型,记做C
  + 如果类型C中找到与常量中描述符和简单名称相符的方法,则进行访问权限校验,如果通过,则返回这个直接引用,否则抛出异常.
  + 否则按照继承关系搜索C的父类
  + 一直找不到则抛出异常

  由于`invokevirtual`指令的存在,方法可能存在有虚的,所以方法可以多态.但是字段是不存在有虚的,所以不存在多态.

  示例:

  ```java
  public class FieldHasNoPolymorphic {
      static class Father {
          public int money = 1;
          public Father() {
              money = 2;
              showMeTheMoney();
          } 
          public void showMeTheMoney() {
              System.out.println("I am Father, i have $" + money);
          }
      } 
      static class Son extends Father {
          public int money = 3;
          public Son() {
              money = 4;
              showMeTheMoney();
          } 
          public void showMeTheMoney() {
              System.out.println("I am Son, i have $" + money);
          }
      } 
      public static void main(String[] args) {
          Father gay = new Son();
          System.out.println("This gay has $" + gay.money);
      }
  }
  ```

  执行结果为:

  ```shell
  I am Son, i have $0
  I am Son, i have $4
  This gay has $2
  ```

+ 单分配和多分配

  方法的接受者和方法的参数统称为方法的宗量.根据分派基于多少中宗量,可以划分为单分派和多分派,单分派是一个宗量对目标方法的选择,多分派是根据多余一个宗量对目标方法进行选择.

  示例: 单分派和多分派

  ```java
  public class Dispatch {
  static class QQ {}
  static class _360 {}
      public static class Father {
          public void hardChoice(QQ arg) {
              System.out.println("father choose qq");
          } 
          public void hardChoice(_360 arg) {
              System.out.println("father choose 360");
          }
      }
      
      public static class Son extends Father {
          public void hardChoice(QQ arg) {
          	System.out.println("son choose qq");
      	} 
          public void hardChoice(_360 arg) {
              System.out.println("son choose 360");
              }
      }
      
      public static void main(String[] args) {
          Father father = new Father();
          Father son = new Son();
          father.hardChoice(new _360());
          son.hardChoice(new QQ());
      }
  }
  ```

  运行结果:

  ```shell
  father choose 360
  son choose qq
  ```

  这里调用了两次hardChoice方法,首先关注静态分派过程.

+ 虚拟机动态分配的实现