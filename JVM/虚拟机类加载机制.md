**类加载机制**

---

#### 类加载的时机

一个类型被加载到虚拟机内存开始,到卸载出内存为值,整个声明周期经历了:

**加载**--> **验证** --> **准备** --> **解析** --> **初始化** --> **使用** --> **卸载**阶段

其中验证,准备和解析的过程称为**连接**.

如图:

<img src="E:\截图文件\类声明周期.png" style="zoom:67%;" />

其中加载，验证，准备，初始化和卸载五个阶段顺序时确定的，类型的记载必须瑶族顺序要求。**但是解析阶段则不一定。在某些情况下可以在初始化阶段之后进行，这个是为了支持java语言的运行时绑定**。

遇到六种情况，必须要对类型进行初始化:

> 1.  遇到new,getstatic,putstatic或者invokestatic四条字节码指令的时候,如果类型没有进过初始化,则需要进行初始化,生成这样指令的java常见为:
>    + 使用new关键字实例化对象
>    + 读取或者设置一个类型的静态字段(被final修饰,已在编译期把结果放入常量池的静态字段除外)
>    + 调用静态方法的时候
> 2. 使用`java.lang.reflect`包对类型进程反射的时候,如果类型没有进过初始化,需要先初始化
> 3. 初始化类的时候,发现父类还没有初始化,则现需要初始化父类
> 4. 虚拟机启动的时候,用户需要指定一个要执行的主类(包含main的类),虚拟机会初始化这个类
> 5. 当使用JDK 7新加入的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStaticREF_newInvokeSpecial四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化 
> 6. 当一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现类发生了初始化， 那该接口要在其之前被初始化。 

处理上述会主动引起类初始化的情况下,还有一些被动触发的示例:

```java
/**
* 被动使用类字段演示一：
* 通过子类引用父类的静态字段， 不会导致子类初始化
**/
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    } 
    public static int value = 123;
} 

public class SubClass extends SuperClass {
    static {
	    System.out.println("SubClass init!");
    }
} 
/
**
* 非主动使用类字段演示
**/
public class NotInitialization {
    public static void main(String[] args) {
    	System.out.println(SubClass.value);
    }
}
```

这里只会输出`SuperClass init`.对于静态子弹,只有直接定义这个字段才会被初始化,因此使用子类引用父类中的静态字段,只会触发父类初始化.至于子类是否实现,在hotspot下需要通过`-XX:TraceClassLoading`参数观察.

案例2:

```java
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    } 
    public static int value = 123;
} 

public class SubClass extends SuperClass {
    static {
	    System.out.println("SubClass init!");
    }
} 
/**
* 被动使用类字段演示二：
* 通过数组定义来引用类， 不会触发此类的初始化
*/
public class NotInitialization {
    public static void main(String[] args) {
    	SuperClass[] sca = new SuperClass[10];
    }
}
```

执行代码，没有`superclass init`输出,说明没有触发`SuperClass`的初始化阶段,但是触发了另一个`SuperClass`的初始化阶段,这个对于用户来说不是一个合法的类型名称,是由虚拟机生成的,继承于boject,由字节码指令`newarray`触发.

案例3:

```java
**
* 被动使用类字段演示三：
* 常量在编译阶段会存入调用类的常量池中， 本质上没有直接引用到定义常量的类， 因此不会触发定义常量的
类的初始化
**/
public class ConstClass {
    static {
        System.out.println("ConstClass init!");
    } 
    public static final String HELLOWORLD = "hello world";
} 
/**
* 非主动使用类字段演示
**/
public class NotInitialization {
    public static void main(String[] args) {
    	System.out.println(ConstClass.HELLOWORLD);
    }
}
```

初始化结果没有输出`ConstClass init`,虽然应用了`HELLOWORLD`这个常量,但是编译阶段以及将常量值存储在常量池中,以后就对这个常数进行引用,也就是最后转换为常量池的引用了.常量池中没有这个类的引用入口,编译完成后是梁凯内容.

+ 接口加载

  与类加载稍有不同,接口也有初始化过程,与类一致,但是不能使用static代码块初始化信息.单编译器会为接口生成`<clint>`类构造器.一个接口需要初始化的时候,并不是需要父接口全部初始化,只需要真正引用父接口才需要初始化.

#### 类加载过程

1. 加载

   加载时类加载的一个阶段,java虚拟机需要完成三件事情:

   + 通过一个类的**全限定名**获取这个类的二进制字节流
   + 将字节流代表的静态存储结构转化为运行时数据结构
   + 在内存中生成一个代表这个类的`java.lang.Class`对象.作为方法区这个类的各种数据访问入口.

   虚拟机规范对这三个要求定义的不是非常具有,所以可以产生多种实现方式.

   相对于类加载的其他节点,非数组类型的加载阶段(加载阶段获取类的二进制流的动作),是开发任务可控性最强的阶段.开发人员通过自定义的类加载器去控制字节量的获取方式(重写findClass和loadClass方法).实现程序运行的动态性.

   对于数组来说,情况有所不同,数组本身不通过类加载器创建,而是由java虚拟机直接在内存中构造出来.但是数组类与类加载器还是有关系的,数组的元素类型最终还是需要通过类加载器完成.一个数组类创建过程遵循如下规则:

   >+ 如果数组是**组件类型**(去掉一个维度,是一个引用)
   >
   >  递归采用加载过程方式加载这个组件,数组C将被标识加载该组件类型的类加载器的**类名称空间**上.
   >
   >+ 如果数组的组件类型是基本类型,虚拟机会将数组C标记与引导类加载器关联
   >
   >+ 数组类的可访问性与组件类型一致,如果组件类型不是引用,访问性默认为public,可以被所有类和接口访问

   加载结束之后,虚拟机外部的二进制流就按照虚拟机设置的格式存储在**方法区**中,方法区中数据存储格式由虚拟机自定义.

   类型数据处理完毕之后,会在java堆内存中实例化一个`java.lang.Class`对象.

   加载阶段与连接节点部分动作是交叉的(字节码校验工作),加载阶段未完成,连接阶段可能已经开始了.但是重合阶段的动作依旧由连接阶段的内容.

2. 验证

   验证是连接的第一步,目的是确保class文件的字节流包含虚拟机规范要求的全部要求.

   java在遇到数组越界,对象转型失败,jump到不存在的代码行的情况下,编译器会直接抛出异常.如果不设置校验,就可以通过设置底层机器码设置从而影响java的安全性.

   主要包含四个检验动作:

   + 文件格式验证
   + 元数据验证
   + 字节码验证
   + 符号引用验证

   > 相关源码位置: `src\hotspot\share\classfile\classFileParser.cpp`

3. 准备

   准备阶段是证实给类中定义的变量(静态变量)分配内存,并设置类变量初始值的阶段;从概念上将,这些变量所使用的的内存都应当在方法区中分配,但是方法区生死一个逻辑上的区域.

   准备阶段,还有两个容易混淆的概念,首先是这时候进行内存分配的仅仅包含类变量,不包括实例变量,实例变量会在对象实例化的时候分配到java堆中.

   ```java
   public static int value = 123;
   ```

   这个值准备阶段是0,这是会执行任何的java方法,赋值为123是在`putstatic`执行之后赋值.存放在<client>()方法中.

4. 解析

5. 初始化