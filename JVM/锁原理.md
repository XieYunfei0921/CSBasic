#### 偏向锁(BiasedLocking)

##### 相关参数

| 参数名称                | 介绍                                                        |
| ----------------------- | ----------------------------------------------------------- |
| _biased_locking_enabled | 默认false，可以设置JVM参数开启                              |
| BiasedLocking           | 偏向锁计数器**BiasedLockingCounters**，用于记录偏向锁统计值 |
| _preserved_oop_stack    | 持有的oop栈                                                 |
| _preserved_mark_stack   | 持有的标记栈                                                |

##### 偏向锁开启

```markdown
如果开启了偏向锁,调度任务就会花费一段时间去开启偏向锁.(对于所有的并发加载类和异步任务).这是对启动时间退化的变通处理.因为虚拟机启动的时候会获取许多的安全点信息,这个信息主要用于偏向撤回操作.理想情况下,会使用较低的代价进行偏向撤回.
```

##### 偏向锁的几种状态

| 状态名称         | 介绍           |
| ---------------- | -------------- |
| HR_NOT_BIASED    | 无偏向锁       |
| HR_SINGLE_REVOKE | 单个偏向锁撤销 |
| HR_BULK_REBIAS   | 批量重偏向设定 |
| HR_BULK_REVOKE   | 批量撤销       |


注意到,偏向锁可以在虚拟机的安全点处进行撤回

```c++
void BiasedLocking::revoke_at_safepoint(Handle h_obj) {
  // 在安全点处进行偏向锁回收，断言操作
  assert(SafepointSynchronize::is_at_safepoint(), "must only be called while at safepoint");
  oop obj = h_obj();
  HeuristicsResult heuristics = update_heuristics(obj, false);
  if (heuristics == HR_SINGLE_REVOKE) {
      // 当偏向锁撤销为单个撤销的时候
    revoke_bias(obj, false, false, NULL);
  } else if ((heuristics == HR_BULK_REBIAS) ||
             (heuristics == HR_BULK_REVOKE)) {
      // 如果是批量撤销/重偏向,则在安全点进行操作
    bulk_revoke_or_rebias_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), false, NULL);
  }
  clean_up_cached_monitor_info();
}
```

##### 基本偏向锁撤销

```c++
/*
@obj 需要撤销偏向锁的对象
@allow_rebias 是否允许重偏向
@is_bulk 是否批量设置
@requesting_thread 请求线程引用
*/
static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread) {
  markOop mark = obj->mark();
  // 无偏向锁检定
  if (!mark->has_bias_pattern()) {
    if (TraceBiasedLocking) {
      ResourceMark rm;
      tty->print_cr("  (Skipping revocation of object of type %s because it's no longer biased)",
                    obj->klass()->external_name());
    }
    return BiasedLocking::NOT_BIASED;
  }

  // 获取对象的标记属性,并设置偏向年龄信息
  uint age = mark->age();
  markOop   biased_prototype = markOopDesc::biased_locking_prototype()->set_age(age);
  markOop unbiased_prototype = markOopDesc::prototype()->set_age(age);

  if (TraceBiasedLocking && (Verbose || !is_bulk)) {
    ResourceMark rm;
    tty->print_cr("Revoking bias of object " INTPTR_FORMAT " , mark " INTPTR_FORMAT " , type %s , prototype header " INTPTR_FORMAT " , allow rebias %d , requesting thread " INTPTR_FORMAT,
                  p2i((void *)obj), (intptr_t) mark, obj->klass()->external_name(), (intptr_t) obj->klass()->prototype_header(), (allow_rebias ? 1 : 0), (intptr_t) requesting_thread);
  }

  // 匿名偏向锁检定,如果是匿名偏向锁,在任何位置都可以获取
  JavaThread* biased_thread = mark->biased_locker();
  if (biased_thread == NULL) {
    if (!allow_rebias) {
      obj->set_mark(unbiased_prototype);
    }
    if (TraceBiasedLocking && (Verbose || !is_bulk)) {
      tty->print_cr("  Revoked bias of anonymously-biased object");
    }
    return BiasedLocking::BIAS_REVOKED;
  }

  // Handle case where the thread toward which the object was biased has exited
  bool thread_is_alive = false;
  if (requesting_thread == biased_thread) {
    thread_is_alive = true;
  } else {
    for (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread->next()) {
      if (cur_thread == biased_thread) {
        thread_is_alive = true;
        break;
      }
    }
  }
  // 请求线程死亡,则表示偏向解除
  if (!thread_is_alive) {
    if (allow_rebias) {
      obj->set_mark(biased_prototype);
    } else {
      obj->set_mark(unbiased_prototype);
    }
    if (TraceBiasedLocking && (Verbose || !is_bulk)) {
      tty->print_cr("  Revoked bias of object biased toward dead thread");
    }
    return BiasedLocking::BIAS_REVOKED;
  }

  // 持有偏向锁的线程存活,检查时候当前持有锁,如果持有,将需要的头部信息写入线程栈帧.否则,将对象头部恢复为未加锁或者为偏向状态
  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_thread);
  BasicLock* highest_lock = NULL;
  for (int i = 0; i < cached_monitor_info->length(); i++) {
    MonitorInfo* mon_info = cached_monitor_info->at(i);
    // 检定到缓存的监视信息是当前obj的,则直接从缓存中获取锁信息,并设置这个锁信息为指定(null)
    if (mon_info->owner() == obj) {
      if (TraceBiasedLocking && Verbose) {
        tty->print_cr("   mon_info->owner (" PTR_FORMAT ") == obj (" PTR_FORMAT ")",
                      p2i((void *) mon_info->owner()),
                      p2i((void *) obj));
      }
      // Assume recursive case and fix up highest lock later
      markOop mark = markOopDesc::encode((BasicLock*) NULL);
      highest_lock = mon_info->lock();
      highest_lock->set_displaced_header(mark);
    } else {
      if (TraceBiasedLocking && Verbose) {
        tty->print_cr("   mon_info->owner (" PTR_FORMAT ") != obj (" PTR_FORMAT ")",
                      p2i((void *) mon_info->owner()),
                      p2i((void *) obj));
      }
    }
  }

  if (highest_lock != NULL) {
    // 高位锁非空,即没有使用缓存锁信息更新,则将锁的header设置为未偏向锁的信息
    highest_lock->set_displaced_header(unbiased_prototype);
    // 将对象头部指针重置到mark位置处.
    obj->release_set_mark(markOopDesc::encode(highest_lock));
    assert(!obj->mark()->has_bias_pattern(), "illegal mark state: stack lock used bias bit");
    if (TraceBiasedLocking && (Verbose || !is_bulk)) {
      tty->print_cr("  Revoked bias of currently-locked object");
    }
  } else {
    // 如果高位锁为空,根据偏向信息,设置其为偏向还是非偏向
    if (TraceBiasedLocking && (Verbose || !is_bulk)) {
      tty->print_cr("  Revoked bias of currently-unlocked object");
    }
    if (allow_rebias) {
      obj->set_mark(biased_prototype);
    } else {
      // Store the unlocked value into the object's header.
      obj->set_mark(unbiased_prototype);
    }
  }
  // 偏向撤销完成
  return BiasedLocking::BIAS_REVOKED;
}
```



##### 重偏向操作

```c++
/**
使用对象类中的端点(epoch),显式地撤销所有对象的偏向锁,强行让其重新获取.但是,也需要遍历所有线程栈且需要更新轻量级锁(这些对象都是持有当前端点的偏向锁).
*/
if (klass->prototype_header()->has_bias_pattern()) {
     // 更新header中的端点信息(epoch)
      int prev_epoch = klass->prototype_header()->bias_epoch();
      klass->set_prototype_header(klass->prototype_header()->incr_bias_epoch());
      int cur_epoch = klass->prototype_header()->bias_epoch();
	// 遍历所有线程栈,调整偏向锁的端点(epoch)
      for (JavaThread* thr = Threads::first(); thr != NULL; thr = thr->next()) {
        GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);
        for (int i = 0; i < cached_monitor_info->length(); i++) {
          MonitorInfo* mon_info = cached_monitor_info->at(i);
          oop owner = mon_info->owner();
          markOop mark = owner->mark();
          if ((owner->klass() == k_o) && mark->has_bias_pattern()) {
              // 断言遇到了之前的就偏向信息/新偏向信息,无论如何设置偏向信息的epoch为新值,完成偏向信息更新
            assert(mark->bias_epoch() == prev_epoch || mark->bias_epoch() == cur_epoch, "error in bias epoch adjustment");
            owner->set_mark(mark->set_bias_epoch(cur_epoch));
          }
        }
      }
    }

	// 调整偏向锁头部信息,使其完成重偏向的操作
    revoke_bias(o, attempt_rebias_of_object && klass->prototype_header()->has_bias_pattern(), true, requesting_thread);
```

#### 锁膨胀

