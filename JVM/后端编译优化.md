**后端编译优化**

---

#### 即时编译器

java程序最初都是通过解释器解释执行的，当虚拟机发现某个方法或者代码块运行特别频繁的时候，就会将这些代码视作**热点代码**。运行的时候，虚拟机将把这些代码编译成**本地机器码**。

1.  解释器和编译器

   主流虚拟机(HotSpot)内部同事包含解释器和编译器,解释器和编译器各有优势.

   如果成行需要迅速启动和执行的时候,解释器首先发挥总有,省去编译时间,立即运行.

   程序启动之后,随着时间的推移,编译器逐渐发挥作用,将代码编译成本地代码,这样可以减少解释器中间损耗,获取更高的执行效率.

   当内存资源限制比较大的时候,可以使用解释器节约执行内存.

   <img src="img\解释器和编译器的交互过程.png" style="zoom:67%;" />

   HotSpot虚拟机中存在两个/三个即时编译器,其中两个存在已久,叫做**客户端编译器**和**服务端编译器**.简称C1和C2编译器.第三个是Graal编译器,jdk 10出现.

   分层编译工作模式出现以前,HotSpot虚拟机通常采用解释器与其中一个编译器搭配的方式工作.程序使用的编译器取决于虚拟机运行的模式.当然用户可以通过,`-client`或者`-server`参数指定虚拟机的模式.

   解释器和编译器共同在虚拟机中使用称作**混合模式**.用户可以使用参数`-Xint`指定运行在解释器上.使用参数`-Xcomp`强制运行在**编译模式**下.

   > **分层编译**:
   >
   > +  程序纯解释执行,并且解释器不开启性能监控功能(**Profiling**)
   > +  使用客户端编译器将字节码编译成本地代码运行,进行简单可靠的优化,不开启性能监控
   > +  使用客户端编译器执行,仅仅开启方法和**回边次数统计**等有限的性能统计工作
   > +  使用客户端编译器执行,开启全部性能监控,处还会收集分支跳转,虚方法调用版本的全部统计信息.
   > +  使用服务端编译器将字节码编译成本地代码,相比于客户端编译器,服务端编译器会启动更多的编译耗时,还会对性能监控信息进行一些不可靠的优化.

   实施分层编译之后，解释器和客户端就会同时工作，热点代码会被多次编译，从而客户端获取更高的编译速度。

   <img src="img\分层编译.png" style="zoom:67%;" />

2. 编译对象和触发条件

   热点代码主要包含两类

   +  多次调用的方法
   +  多次执行的循环体

   对于这两种情况，编译的目标对象是整个方法体，而不是单个循环体。第一种情况，用于是依靠方法调用触发的编译，那么编译器理所当然应当将整个方法作为编译对象。后者原理类似，指示执行入口点发送了变化。

   **热点探测**用于探测热点代码，主要判断原则有：

   + 基于采样的热点探测

     这种方法的虚拟机会周期性的检查各个线程的调用栈顶,如果发现某个方法经常出现在栈顶,就认作热点方法.基于采样的热点探测简单高效,但是容易受到线程阻塞的影响扰乱热点探测.

   + 基于计时器的热点探测

     这种方法会给每个方法(代码块)建立计数器,统计方法的执行次数,如果超出移动次数就认为是热点方法.

   HotSpot虚拟机采样了基于计数器的热点探测,引入了两个计数器: **方法调用计数器**和**回边计数器**.

   方法调用计数器用于统计方法被调用的次数:

   <img src="img\方法调用计数器的处理过程.png" style="zoom:67%;" />

   回边计数器,作用是统计一个方法中循环体代码的执行次数.

   <img src="img\回边计数器处理过程.png" style="zoom:67%;" />

   回边计数器没有计数热度的衰减过程,因此循环体是循环的是绝对次数.可以从`Method.hpp`中观察java方法在虚拟机中的布局.

3.  编译过程

   默认条件下,无论是方法调用产生的标准编译请求,还是栈上替换编译请求,虚拟机在编译器未完成编译之前,都将按照解释方式执行代码,编译动作在后台线程中执行.可以通过`-XX:-BackgroundCompilation`禁止后台编译.

   对于客户端编译器来说,是一个三段式编译器:

   第一阶段: 一个平台独立的前端将字节码构造成高级中间表示代码(HIR).使用静态单分配来表示码值.

   第二阶段: 一个平台相关的后端从HIR中产生低级中间表示代码(LIR).在HIR基础上进行优化(空值检查,范围检查消除)

   第三阶段: 使用平台相关的后端使用**线性扫描算法**在LIR上分配寄存器,并在LIR上做优化,产生极其代码.

   <img src="img\即时编译器编译过程.png" style="zoom:67%;" />

   常用的经典优化动作:

   +  无用代码消除
   +  循环展开
   +  循环表达式外提
   +  消除公共子表达式
   +  常量传播
   +  基本块重排序
   +  范围检查消除
   +  空值检查消除
   +  守护内联
   +  峰值频率预测

#### 提前编译器

> **提前编译器的优势**：
>
> 提前编译没有执行时间和资源限制的压力，在即时编译器比较耗时的过程间分析，编译器缓存加速的优化手段中。起到了对重负载的优化作用。
>
> **即时编译器的优势**：
>
> +  性能分析制导优化
> +  激进预测性优化
> +  链接时优化 

#### 编译器优化技术

常见的优化方法

+ 方法内联

  方法内联的优化行为，就是把目标方法的代码原封不动的复制到发起调用的方法中，避免真实的方法调用。

  为了解决虚方法内联的问题，java虚拟机引入了**继承关系分析**的技术。这是整个应用程序范围内的类型分析技术，用于确定目前已经加装的类中，某个接口是否有多余一种的实现，某个类是否存在子类。某个子类是否覆盖了父类的某个虚方法。

  编译器在内联期间会选择不同的处理方法，如果是非虚方法，则直接进行内联即可。

  如果是虚方法，则使用继承关系分析查询当前程序是否有多个版本选择，如果查询到，则进行内联，称作**守护内联**。这个是由java程序动态链接的，如果CHA分析发送变化，就需要抛弃编译的代码进行重新编译。

  如果存在有多个版本可以选择，那么编译器将尽最大努力，是由内联缓存的方式减少方法调用开销。

  内联缓存是建立在目标方法正常入口之前的缓存，工作原理：

  > 方法为发生调用之前，内联缓存状态为空，第一次调用发生之后，缓存记录下方法接受者的版本信息。并且每次方法调用的时候都比较接受者的版本，如果和方法接受者的版本是一致的，那么就是一种**单态内联缓存**。

  这种做法比使用不内联的非虚方法调用，多路一次类型判断的开销。但是如果出现了方法接受者不一致的情况，说明遇到了虚方法的多态特性。这个时候会退化成超多态内联缓存，开销相当于真正查找虚方法来进行方法分派。

+ 逃逸分析

  + **逃逸分析原理**：

    > 分析对象动态作用域，当一个对象在方法里面被定义之后，可能被外部方法引用，作为调用参数传递到其他方法中，这种称作**方法逃逸**。
    >
    > 甚至可以被外部线程访问到，称作**线程逃逸**。

  如果能够证明一个对象不会逃逸到方法或者线程之外，或者逃逸程度较低，这个对象实例采样不同程度的优化。

  1.  栈上分配

     如果确定一个对象不会逃逸出线程之外，那么在栈上分配内存是个不错的主意，对象所占用内存空间会随着出栈而销毁。

     栈上分配可以支持方法逃逸，但是不能支持线程逃逸。

  2.  标量替换

     如果一个数据已经无法再次分解了(int,long,reference类型),这些数据叫做**标量**.相对的,如果数据可以进一步分解,就称作聚合量.如果把java对象拆散,根据程序访问的情况,将其使用到的成员变量恢复为原始类型访问,这个过程叫做**标量替换**.

     假如逃逸分析能够证明一个对象不会被方法外部访问,并且这个对象可以拆开,程序真正执行的时候可能不会去创建这个对象,改为直接创建这个若干个方法使用的成员变量代替.

     对逃逸程度要求高,不允许对象逃逸出方法范围之外.

  3.  同步消除

     线程同步是一个耗时的过程,如果逃逸分析能够确定一个变量不会逃逸出线程,无法被其他线程访问,那么这个变量的读写一定不会存在竞争,同步措施可以安全的移除掉.

  优化示例:

  ```java
  class Point{
      int x;
      int y;
  }
  // 完全未优化的代码
  public int test(int x) {
      int xx = x + 2;
      Point p = new Point(xx, 42);
      return p.getX();
  }
  ```

  + 将point的构造函数和getX()方法进行内联优化

    ```java
    // 步骤1： 构造函数内联后的样子
    public int test(int x) {
        int xx = x + 2;
        Point p = point_memory_alloc(); // 在堆中分配P对象的示意方法
        p.x = xx; // Point构造函数被内联后的样子
        p.y = 42
        return p.x; // Point::getX()被内联后的样子
    }
    ```

  + 经过逃逸分析,Ponit对象不会发生逃逸,可以对其进行标量替换,如下:

    ```java
    // 步骤2： 标量替换后的样子
    public int test(int x) {
        int xx = x + 2;
        int px = xx;
        int py = 42
        return px;
    }
    ```

  + 通过数据流分析,发现py这个参数不会对方法产生任何影响,将无效代码消除,得到:

    ```java
    // 步骤3： 做无效代码消除后的样子
    public int test(int x) {
    	return x + 2;
    }
    ```

+ 公共子表达式消除

  公共子表达式是一种经典的编译器优化技术.含义是: 如果表达式E之前已经被计算过了,并且之前计算的E的所有变量值都没有发生变化,那么E称作公共子表达式.

  罪域这种表达式,没有必要重新计算,只需要使用上次计算的结果即可.如果表达式限于局部,称**作局部公共子表达式消除**,使用在多个基本块中,叫做**全局公共子表达式消除**.

  ```java
  int d = (c * b) * 12 + a + (a + b * c);
  ```

  交给编译器会生成如下字节码

  ```asm
  iload_2 // b
  imul // 计算b*c
  bipush 12 // 推入12
  imul // 计算(c * b) * 12
  iload_1 // a
  iadd // 计算(c * b) * 12 + a
  iload_1 // a
  iload_2 // b
  iload_3 // c
  imul // 计算b * c
  iadd // 计算a + b * c
  iadd // 计算(c * b) * 12 + a + a + b * c
  istore 4
  ```

  这段代码进入即时编译器之后,会进行如下优化,检测到c * b和b * c是一个表达式之后,可以视作:

  ```java
  int d = E * 12 + a + (a + E);
  ```

  这时候编译器可能进行代数式简化

  ```java
  int d = E * 13 + a + a;
  ```

+ 数组边界检查消除

  ```java
  if (foo != null) {
  	return foo.value;
  }else{
  	throw new NullPointException();
  }
  ```

  使用隐式异常优化之后,虚拟机的执行伪代码如下:

  ```java
  try {
  	return foo.value;
  } catch (segment_fault) {
  	uncommon_trap();
  }
  ```

  虚拟机会注册一个Segment Fault信号的异常处理器,这里指的是进程层面的异常处理器.

