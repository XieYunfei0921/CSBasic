**内存模型与线程**

---

#### 内存模型

1.  主存与工作内存

   java内存模型主要目的是定义程序中各种变量访问规则，即关注内存存储和从内存获取变量值的底层细节。此处的变量，包括**实例字段**，**静态字段**和**构成数组对象的元素**，不包括局部变量和方法参数。因为后者时线程私有的，不会被共享，当然不存在竞争问题。

   java内存模型中规定了所有变量都存储在主存中，每条线程拥有自己的工作内存，工作内存中保存了该线程使用变量的主内存副本，线程中对变量的操作必须在工作内存中进行，不能直接对主存进行读写。不同的线程之间服务直接访问对方工作内存中的变量，线程间变量值传递需要通过主内存完成。

   <img src="E:\截图文件\主存与工作内存关系.png" style="zoom:67%;" />

2. 内存间的交互

   主内存与工作内存的交互协议,即变量如何从主内存拷贝到工作内存,如果从工作内存同步到主内存,java定义8种操作来完成.java虚拟机必须保证下述的操作是原子的,不可再分的.

   + lock(锁定): 作用于主内存的变量,标志着一条线程的独占状态
   + unlock(解锁): 作用于主内存变量，将一个处于锁定状态的变量释放出来，释放出来的变量才可以被其他线程锁定
   + read(读取): 作用于主存的变量,把一个变量的值从主内存传输到线程的工作内存中
   + load(载入): 作用于主存的变量,把read操作从主内存中的到的变量值放入工作内存的变量副本中.
   + use(使用): 用于工作内存变量,将工作内存的一个变量的值传递给执行引擎,每当虚拟机遇到一个需要使用变量值的字节码指令的时候,就会执行这个操作.
   + assign(赋值): 用于工作内存变量,从执行引擎接受的值赋予工作内存变量,当虚拟机遇到变量赋值的字节码指令时执行该操作.
   + store: 作用于工作内存变量,把工作内存中一个变量的值传送到主内存中,以便缩合的write操作.
   + write: 作用于主存,将store操作从工作内存得到变量的值放到主存中.

   如果需要把主存拷贝到工作内存,就需要按照read->load操作,如果需要同步回主存,需要按照store-> write的操作.注意到顺序是这样的但是中间可以插入其他操作.

   另外做出如下规定:

   + 不允许read&load,store&write单独出现
   + 不允许一个线程丢弃最近的assign操作
   + 不允许线程无原因地将数据从线程的工作内存同步回主存
   + 新的变量只能在主内存中产生,不允许工作内存中使用未初始化的变量,也就是变量在use,store操作之前,必须执行assign和load操作.
   + 一个变量同一个时刻只允许一条线程对其进行lock操作,但是lock操作可以被一条线程重复执行.
   + 如果对一个变量进行lock操作,将会清空工作内存中变量的值,在执行引擎使用变量之前,需要重新执行load和assign操作,用于初始化变量值.
   + 如果没有lock就不能对其进行unlock操作,不允许unlock一个没有锁定的变量
   + 对一个变量进行unlock操作之前,必须将变量同步回主存

3. volatile变量特殊规则

4. long/double的特殊规则

5. 原子性可见性与有序性

6. 先行发生原则

#### 线程

#### 协程