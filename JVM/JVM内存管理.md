### **自动内存管理**

---

1. [运行时数据区域](# 运行时数据区域)
2. [HotSpot虚拟机探秘](# HotSpot虚拟机探秘)
3. [OOM异常](# OOM异常)

---

####  运行时数据区域

1. [程序计数器](# 程序计数器)

2. [java虚拟栈](# 虚拟栈)

3. [本地方法栈](# 本地方法栈)

4. [java堆](# java堆)

5. [方法区](# 方法区)

6. [运行时常量池](# 运行时常量池)

7. [直接内存](# 直接内存)

   ---

   ###### 程序计数器

   > 定义: 程序计数器是一块较小的内存空间,可以看做当前线程所执行的字节码的**行号指示器**.
   >
   > 字节码解释器的功能是通过改变这个**行号指示器**从而确定下一个需要执行的字节码指令,也是程序控制流的指示器,分支,循环,跳转,异常处理线程恢复等等基础功能都要通过这个**行号指示器**完成.

   java虚拟机中多线程是通过线程轮流切换,分区处理器的执行时间的方式来进行的.任意确定的时刻,一个处理器都只会执行一条线程的指令.

   因此,为了使得线程恢复到正确的位置,每个线程都需要设置一个程序计数器,用于存储每个线程的**行号计数器**.因此线程之间的程序计时器之间是没有关系的.

   >如果线程中执行的是一个java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址,如果这个执行的是本地方法,这个计数器的值为空(Undefined).这个内存区域时没有规定OOM的区域.

   ##### 虚拟栈

   > 与程序计数器类似,java虚拟机栈也是线程私有的.生命周期同线程.虚拟机栈描述了java执行的线程内存模型.
   >
   > 当每个方法被执行的时候,java虚拟机都会创建一个**栈帧**.主要的目的是存储**局部变量表**,**操作数栈**,**动态链接**,**方法出口**等信息.
   >
   > 每个方法被调用直至执行完成的过程,就对应栈帧在虚拟机栈中从入栈到出栈的过程.
   >
   > 通常将java内存区域粗略的使用**堆内存**和**栈内存**划分,直接继承了C/C++ 的内存划分方法.通常java中的栈指的是虚拟机栈.

   **局部变量表**存放了编译期间各种java虚拟机的基本数据类型(boolean,byte,char,short, int,float,long,double),对象引用(reference类型， 它并不等同于对象本身， 可能是一个指向对象起始地址的引用指针， 也可能是指向一个代表对象的句柄或者其他与此对象相关的位置 )和**返回地址**(指向一条字节码指令的地址).

   这些数据类型在**局部变量表**中的存储空间以**局部变量槽**(slot的形式表示).其中64位长度的long类型和double类型会占用两个变量槽,其余类型只会占用一个变量槽.**局部变量表**的内存空间在编译期间完成分配.方法运行期间不会改变局部变量表的大小.这里的"大小"指的是变量槽的数量,具体关于虚拟机真正到底使用了多少的内存空间(1槽=32/64B)需要有具体的虚拟机决定.

   >在java虚拟机规范中,内存区域定义了两种形式的异常:
   >
   >如果线程请求的栈深度大于虚拟机允许的最大深度,将抛出@StackOverflowError 异常.如果java虚拟机站容量可以动态扩展,当无法再进行扩展的时候,则会抛出@OutOfMemoryError 异常.

   ##### 本地方法栈

   > **本地方法栈**与虚拟机栈的作用是相似的,指示虚拟机栈为虚拟机执行java方法服务,而本地栈为本地(Native)方法服务.

   ##### java堆

   > java堆是虚拟机管理的内存中最大的一块.java对是被所有线程所共享的一块内存区域.在虚拟机启动的时候创建.这个内存区域的唯一目的就是存放对象实例,java中的几乎所有对象实例都存放在这里.
   >
   > java虚拟机规范中指出,所有对象实例以及数组都应当在堆上分配.
   >
   > 这里使用了"几乎"这个词,表示随着java的发展,现在已经能够开到之后可能会出现**值支持**类型的支持,由于编译技术进步,尤其是**逃逸分析**技术的进步,**栈上分配**,**标量替换**等优化手段已经导致了变化.所以说堆上分配实例已经不是绝对.

   java堆是垃圾收集器管理的内存区域.一些资料中称为GC堆,从回收内存的角度来看,由于现代大多数垃圾收集器基于**分代收集理论**设计的.所以java堆中经常出现的`新生代`,`老年代`,`永久代`,`Eden空间`,`From Survivor空间`,`To Survivor空间`.作为主流的HotSpot虚拟机,内部的垃圾收集器全部基于**经典分代**设计.

   如果从分配内存的角度来看,所有线程共享的java堆中可以划分为多个线程西游的分配缓冲区(TLAB: Thread Local Allocation Buffer ).设置这个用于提示分配时的效率,无论通过什么角度,都不会改变java堆中存储内容的共享,无论什么区域存储的都是对象实例.将java堆细分的目的只是为了更好的分配和释放内存.

   根据java虚拟机规范中指定,java堆可以处于无论上不连续的内存空间中.但是在逻辑上视作连续的.对于大的对象(数组对象),多数虚拟机处于实现简单,存储高效的考虑,会要求连续的内存空间.

   java的堆大小可以为固定的,也可以设置为可以扩展的(-Xmx和-Xms设定).如果java堆没有完成实例内存的分配,且堆也没有办法进行扩展的时候,会抛出@OutOfMemoryError 异常.

   ##### 方法区

   > 与java对类似,是各个线程共享的部分,由于存储已经被虚拟机加载的类型信息,常量,静态变量,即时编译器编译后的代码缓存等数据.虽然java虚拟机将其描述为一个逻辑部分,别名非堆(Non-Heap).目的是与java堆分开.

   java虚拟机规范中对方法区的约束比较宽松,除了和java堆一样不需要连续的内存和可以选择固定大小或者可扩展的情况之外.甚至可以选择不实现垃圾收集.所以,垃圾收集在这个区域来说时比较少出现的.(但是并不是意味着进入了永久代了).

   ##### 运行时常量池

   **运行时常量池**(Runtime Constant Pool)是方法区的一部分.class文件除了有**类的版本**,**字段**,**方法**,**接口**等描述信息之外,还有一项信息是**常量池表**.用于存放编译器的各种字面量和符号引用.这部分是在类加载之后放到方法区的运行时常量池中.

   java虚拟机对于class文件的每一部分(包括常量池),有这严格的格式规定.如每一个字节用于存储哪种数据都必须符合规范才会被虚拟机认可,并加载执行.但是对于运行时常量池,并没有任何细节的要求,不同供应商的虚拟机提供的方式不同.一般的,除了保存class文件外,还会把符号引用翻译出来的直接引用存储在运行时常量池中.

   > 运行时常量池相对于class文件常量池的另一个特征为具备动态性.java语言不要求常量池必须要编译器才能产生.也就是,并非置入calss文件中的常量池才能进入方法区运行时常量池.运行期间也可以将新的常量放入池中.这种应用最广泛的是String.intern()
   >
   > 既然运行时常量池是方法区的一部分,自然会受到方法区内存的限制.当没有内存分配的时候便会OOM.

   ##### 直接内存

   >  **直接内存**并不是虚拟机运行时数据区的一部分,也不是java虚拟机规范中定义的内存区域.这部分内存也会被频繁使用,且可能导致OOM的发生.
   >
   > JDK1.4之后,引入了NIO,引入了基于通道和缓冲区的IO方式,可以使用本地函数库直接分配堆外内存.通过一个java堆中的@DirectByteBuffer对象作为内存引用进行操作.这样可以提供性能,避免java堆和native堆的数据拷贝.
   >
   > 本机的直接内存分配不会受到java堆大小的限制,但是会受到本机总内存的影响.

   ---

   **基本概念总结**

   java虚拟机在执行java程序的过程中会把它管理的内存划分为多个不同区域.用途不同,创建和销毁的时间不同.总体来说可以使用下图来描述:

   <img src="E:\截图文件\JVM结构.png" style="zoom:67%;" />

#### HotSpot虚拟机对象探秘

#### OOM异常