**线程安全与锁优化**

---

**线程安全**

+ 线程安全

  1.  不可变

     不可变的对象一定是安全的,无论是对象的方法实现还是方法的调用者,都不需要进行任何的安全保障措施.

     例如,final关键字构建的不可变对象,只要正确构建处理,外部可见状态从来都不会改变.

     实现的方式有多种,一种是使用final修饰,第二种类似Integer,内部value使用final保障

  2.  绝对的线程安全

     绝对线程安全定义为:不管运行环境怎样,都不需要添加任何同步措施

     但是真实的绝对安全是不存在的,例如:

     ```java
     private static Vector<Integer> vector = new Vector<Integer>();
     public static void main(String[] args) {
         while (true) {
             for (int i = 0; i < 10; i++) {
             	vector.add(i);
             } 
             Thread removeThread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     for (int i = 0; i < vector.size(); i++) {
                     	vector.remove(i);
                 	}
             	}
             });
             Thread printThread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     for (int i = 0; i < vector.size(); i++) {
                     	System.out.println((vector.get(i)));
                     }
                 }
         });
         removeThread.start();
         printThread.start();
         //不要同时产生过多的线程， 否则会导致操作系统假死
         while (Thread.activeCount() > 20);
         }
     }
     ```

     执行结果为：

     ```shell
     Exception in thread "Thread-132" java.lang.ArrayIndexOutOfBoundsException:
     ```

     尽管get,remove和size方法都是同步的,但是在多线程环境下,如果不使用额外的同步措施,代码依旧是不安全的.

     ```java
     private static Vector<Integer> vector = new Vector<Integer>();
     public static void main(String[] args) {
         while (true) {
             for (int i = 0; i < 10; i++) {
             	vector.add(i);
             } 
             Thread removeThread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     synchronized (vector) {
                         for (int i = 0; i < vector.size(); i++) {
                             vector.remove(i);
                         }
                     }
             	}
             });
             Thread printThread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     synchronized (vector) {
                         for (int i = 0; i < vector.size(); i++) {
                             System.out.println((vector.get(i)));
                         }
                     }
                 }
         });
         removeThread.start();
         printThread.start();
         //不要同时产生过多的线程， 否则会导致操作系统假死
         while (Thread.activeCount() > 20);
         }
     }
     ```

  3.  相对的线程安全

     相对线程安全就是通常意义上的线程安全，一般情况下不需要额外的保障措施，但是对于特定的连续调用，需要调用的时候使用同步手段保障正确性。

  4.  线程兼容

     线程兼容本身不是线程安全的，但是可以调用端正确使用同步措施保障在并发情况下安全可用。也是通常情况下的线程不安全。

  5.  线程对立

     不管调用端采用何种同步措施都无法再并发环境中使用，这类代码更少，应尽量避免。

+ 线程安全的实现

  1.  互斥同步
  2.  非阻塞同步
  3.  无同步方案

**锁优化**