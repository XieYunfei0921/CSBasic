**线程安全与锁优化**

---

#### **线程安全**

+ 线程安全

  1.  不可变

     不可变的对象一定是安全的,无论是对象的方法实现还是方法的调用者,都不需要进行任何的安全保障措施.

     例如,final关键字构建的不可变对象,只要正确构建处理,外部可见状态从来都不会改变.

     实现的方式有多种,一种是使用final修饰,第二种类似Integer,内部value使用final保障

  2.  绝对的线程安全

     绝对线程安全定义为:不管运行环境怎样,都不需要添加任何同步措施

     但是真实的绝对安全是不存在的,例如:

     ```java
     private static Vector<Integer> vector = new Vector<Integer>();
     public static void main(String[] args) {
         while (true) {
             for (int i = 0; i < 10; i++) {
             	vector.add(i);
             } 
             Thread removeThread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     for (int i = 0; i < vector.size(); i++) {
                     	vector.remove(i);
                 	}
             	}
             });
             Thread printThread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     for (int i = 0; i < vector.size(); i++) {
                     	System.out.println((vector.get(i)));
                     }
                 }
         });
         removeThread.start();
         printThread.start();
         //不要同时产生过多的线程， 否则会导致操作系统假死
         while (Thread.activeCount() > 20);
         }
     }
     ```

     执行结果为：

     ```shell
     Exception in thread "Thread-132" java.lang.ArrayIndexOutOfBoundsException:
     ```

     尽管get,remove和size方法都是同步的,但是在多线程环境下,如果不使用额外的同步措施,代码依旧是不安全的.

     ```java
     private static Vector<Integer> vector = new Vector<Integer>();
     public static void main(String[] args) {
         while (true) {
             for (int i = 0; i < 10; i++) {
             	vector.add(i);
             } 
             Thread removeThread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     synchronized (vector) {
                         for (int i = 0; i < vector.size(); i++) {
                             vector.remove(i);
                         }
                     }
             	}
             });
             Thread printThread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     synchronized (vector) {
                         for (int i = 0; i < vector.size(); i++) {
                             System.out.println((vector.get(i)));
                         }
                     }
                 }
         });
         removeThread.start();
         printThread.start();
         //不要同时产生过多的线程， 否则会导致操作系统假死
         while (Thread.activeCount() > 20);
         }
     }
     ```

  3.  相对的线程安全

     相对线程安全就是通常意义上的线程安全，一般情况下不需要额外的保障措施，但是对于特定的连续调用，需要调用的时候使用同步手段保障正确性。

  4.  线程兼容

     线程兼容本身不是线程安全的，但是可以调用端正确使用同步措施保障在并发情况下安全可用。也是通常情况下的线程不安全。

  5.  线程对立

     不管调用端采用何种同步措施都无法再并发环境中使用，这类代码更少，应尽量避免。

+ 线程安全的实现

  1. 互斥同步
  
     互斥同步是最常见的并发正确性保证手段。同步时多个线程并发访问共享数据的时候，保证共享数据只被一个线程使用。常见的**临界区**,**互斥量**,和**信号量**是常见的互斥实现方式.
  
     java中常见的互斥同步手段是synchronized关键字,编译时会生成monitorenter和monitorexit两条指令,这两个字节码指令都需要一个reference参数指明需要锁定的对象.如果指明了对象参数,就使用这个引用作为reference,否则使用synchronized修饰的方法类型,来确定代码所在的对象实例还是类型对应的class对象作为线程持有的锁.
  
     根据java虚拟机规范的要求,执行monitorenter指令时,需要尝试获取对象的锁,如果对象没有被锁定或者当前线程持有该对象的锁,这个锁的计数器值加1.在执行monitorexit指令时,计数器值减一.(CountDownLatch).一旦计数器的值为0,锁就会被释放.
  
     针对上述描述,可以得到synchronized两条推论:
  
     + 被synchronized修饰的同步块对同一个线程来说是可重入的,意味着同一个线程反复进入同一个同步块,都不会将自己锁死
     + synchronized修饰的同步块在持有锁的线程执行完毕之前,会无条件的阻塞后面的其他线程进入.
  
     重入锁是Lock最常见的一种实现,与synchronized是可重入的,基本语法上,重入锁`ReentrantLock`与synchronized相似.此外添加了三项额外的功能:
  
     + 等待可中断
  
       当持有锁的线程长期不释放锁的时候,可以选择放弃等待.
  
     + 公平锁
  
       多个线程等待同一个锁的时候,必须按照申请顺序来获取锁
  
     + 锁绑多个条件
  
       一个重入锁可以绑定多个Condition对象
  
  2. 非阻塞同步
  
     **悲观锁**: 总是认为只要不去进行正确的同步措施,就一点会出现问题,无论是否真的会出现竞争都会进行加锁.互斥同步就是一种悲观锁策略.
  
     **乐观锁**: 基于冲突检查,无论风险如何,都进行操作,如果没有两个线程共享数据,操作成功.如果确实发生了冲突,则使用其他措施进行补偿.常用的补偿就是不断的重试,直到没有资源竞争为止.
  
     硬件保证某些语义看起来需要执行多次,但其实一条处理器指令即可完成,包括:
  
     + 测试并设置
     + 获取并添加
     + 交换
     + 比较并交换(CAS)
     + 加载链接/条件存储(LL/SC)
  
     其中IA64,x86指令集中cmp xchg指令完成了CAS功能,在ARM和PowerPC架构下,需要使用ldrex/strex完成LL/SC功能.
  
     **CAS指令**包含三个操作数,分别是内存位置V,旧值A和新值B.CAS指令执行的时候,只有V满足条件A时才会使用B更新V的值,否则不更新.但是无论如何,都会返回V的旧值,是一个原子操作.
  
     **CAS指令的ABA问题**:
  
     当变量V初次读取的时候是A,并在准备赋值的时候仍然是A,但是不一定期间值没有改变过.例如:这段期间曾经被改成B,后来又变成A,那么CAS认为其没有发送改变.
  
     JUC为了解决这个问题,引入了AtomicStampedReference 控制变量值的版本保证CAS正确性.
  
  3. 无同步方案
  
     **可重入代码:**  可以在代码执行期间任意时间去中的,转而执行其他代码,控制权返回之后,原来的程序不会出现任何措施
  
     可重入代码的特征是: 输入相同的数据,返回的结果是可以预测的.

#### **锁优化**

常见的锁优化措施:

**适应性自旋**,**锁消除**,**锁膨胀**,**轻量级锁**,**偏向锁**

+ 自旋锁

  **定义**: 在共享数据锁定的期间内,本应当被阻塞的处理机不放弃执行时间,而是转换为等待一段时间.为了让这个线程等待,必须让线程执行一个忙循环(自旋),这个就是自旋锁.

  自旋锁在JDK6之后默认存在,自旋默认次数为10,这个参数不宜过大,太大则会消耗处理机的资源.

+ 锁消除

  **锁消除**指的是虚拟机在即时编译器运行的时候,对一些代码要求同步,但是对被检测到的不可能存在数据竞争的锁进行消除.锁消除主要依据逃逸分析,如果一段代码中堆上所有数据都不会逃逸出去,那么可以当做栈上数据对待认为线程私有,就不需要同步.

+ 锁粗化

  如果频繁的对同一个对象进行反复加锁,或者加锁出现在循环体中,即使没有线程竞争也会导致不必要的性能损耗.所以将锁的范围扩展到操作序列之外.

+ 轻量级锁

  轻量级锁是用于替代重量级锁的，减少操作系统互斥量产生的性能消耗。

  HotSpot虚拟机对象的对象头中包含两个部分，第一部分存储自身运行时的数据，比如哈希码GC分代年龄等待，这部分占用32/64bit.称作Mark Word.这部分是实现轻量级锁和偏向锁的关键.另一个部分用于存储对象类型数据的指针.

  考虑到java虚拟机的空间使用效率,MarkWord设计成一个非固定动态数据结构,以便在小的空间存储更多的信息.

  <img src="E:\截图文件\MarkWord.png" style="zoom:67%;" />

  **轻量级锁的工作过程**:

  当代码进入同步块的时候,如果同步对象没有被锁定(01),虚拟机首先将线程的栈帧建立一个**锁记录**空间,用于存储锁对象目前的MarkWord的拷贝.

  虚拟机使用CAS操作吧对象Mark Word更新为Lock Record指针,如果更新成功,就代表线程拥有了对象的锁,并且对象MarkWord锁标志位变为00.

  如果更新操作失败,意味着有至少一个线程参与竞争,虚拟机会检查对象的MW是否执行当前线程的栈帧,如果是则表示获取了对象的锁,进入同步块执行即可.否则表示已经被其他线程抢占了.如果对两条以上线程竞争一个锁,轻量级锁就不再有效了,必须使用重量级锁.

+ 偏向锁

  偏向锁目的消除数据在无竞争的情况下的同步原语,进一步提高程序运行性能.偏向锁相对于轻量级锁来说,消除同步原语时可以不使用CAS.

  **工作原理**:

  假设虚拟机启动了偏向锁,当锁对象第一次被线程获取的时候,虚拟机会把对象头中的标志位设置为01,表示进入偏向模式.同时使用CAS操作将获取到这个锁的线程ID记录在MW中,如果CAS成功,持有偏向锁的线程进入同步块中,虚拟机不会进行任何同步操作.

  但是一旦有另一个线程尝试去获取这个锁的情况,偏向模式就会马上接受.撤销偏向设置,恢复到未锁定(01)或者轻量级锁定(00)中.

  <img src="E:\截图文件\偏向锁的解除.png" style="zoom:67%;" />

  绝大多数对象的hashcode返回的是一致性哈希码,这个值强制保证不变.因此,当一个对象计算过一致性哈希码之后,就无法进入偏向锁状态了,当一个对象处于偏向锁状态,有收到计算一致性哈希码请求时,偏向状态会被撤销,锁会变成重量级锁.在重量级锁中,对象头执行了重量级锁的位置.

  