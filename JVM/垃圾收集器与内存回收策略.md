**垃圾收集器与内存分配策略**

---

#### 对象存活的判断

##### 引用计数法

在对象中添加一个应用计数器,当有一个地方需要应用的时候,计数器值就加1.引用失败的时候,计数器值就减一.任何时刻计时器为0的对象就不能够再被使用.

可观来说引用计数虽然需要一定的内存空间进行计数(就是这个计数值,其中使用int类型所占空间要小于long).但是java虚拟机并没有使用这种内存管理方法,主要原因是看似简单的算法有许多的例外需要考虑.必须处理边界情况才能正常工作,例如,难以接口对象直接相互引用的情况.

例如:

```java
public class ReferenceCountGC{
    public Object instance=null;
    private static final int _1MB=1024*1024;
    // 这个属性用于查看日志是否有回收过，占用内存2MB，实际占用2M*byte类型的长度
    private byte[] bigSize=new byte[2*_1MB];
    public static void test(){
        ReferenceCountGC obja=new ReferenceCountGC();
        ReferenceCountGC objb=new ReferenceCountGC();
        // 两个实例的循环引用
        obja.instance=objb;
        objb.instance=obja;
        // 释放内存
        obja=null;
        objb=null;
        // GC,查看两个实例是否被回收
        System.GC();
    }
}
```

结果:

```shell
[Full GC (System) [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)]
Heap
```

可以看到内存分配量由4603减少到210,即这两个对象被回收了,说明java虚拟机不是通过引用计数来判断对象是否存活的.

##### 可达性分析算法

主流的程序语言的内存管理子系统使用的都是可达性分析法判断对象是否存活,这个算法的基本思路通过一些了称为`GC Root`的根对象作为起始节点集.从这些节点开始,根据引用关系(图的拓扑关系,单向边).所有过的**路径**称作**引用链**.如果某个对象到达`GC Roots`之间没有任何引用链,name就认为这个对象已经死亡,需要进行回收,具体实现可以求以`GC Roots`为一个顶点的连通图,不在该连通图中的节点需要进行回收.

例如:

<img src="E:\截图文件\可达性算法.png" style="zoom:67%;" />

java虚拟机中,可以作为GC Roots的对象(一定不会被回收的对象)

- 虚拟机栈(栈帧本地变量表)中引用的对象,例如各个线程被调用方法对象中使用的参数,局部变量,临时变量等.
- 方法区中类静态属性引用对象,譬如java类的引用类型静态变量.
- 方法区中常量引用对象,例如**字符串常量池**的引用
- 本地方法栈中JNI(native方法)引用的对象
- java虚拟机的内部引用,如基本数据类型对应的class对象.溢写常驻内存的异常(NullPointExcepiton,OutOfMemoryError ),还有系统类加载器
- 被同步锁持有的对象
- 反应java虚拟机内部的JMXBean,HVM TI注册的回调,本地代码缓存等.

除了固定的GC Roots集合之外,根据用户选择的垃圾收集器,以及当前回收的内存区域不同,可以有其他对象临时性的加入,共同构成GC Roots.

最新几款垃圾收集器无一例外使用了局部回收的特征.

##### 引用

jdk1.2之后,java对引用的概念进行扩充,分为强引用,软引用,弱引用,和虚引用.四种引用轻度逐渐减弱.

+ **强引用**: 传统引用定义,指代码中的普遍的引用复制,例如`Person p=new Person()`.无论何时只要强引用关系还在,垃圾回收器就不会回收.(可以设置`p=null`取消引用的实例).
+ **软引用**: 描述一些可以使用,但是非必须的对象.被软引用关联的对象,在系统发生内存溢出之前,会把对象回收范围进行二次回收(**对软引用的回收**),如果二次回收还是不能保证足够内存.才会抛出异常.使用`SoftReference`类实现.
+ **弱引用**: 用于描述非必须的对象，强度比**软引用**弱，被弱引用关联的对象只能生存岛下一次垃圾收集发送为止。当垃圾收集器开始龚总，无论当前内存是否足够，都会回收掉**弱引用**的对象。使用`WeakReference`类实现.
+ **虚引用**: 最弱的引用关系,一个对象是否有虚引用不会对生存时间产生影响,页无法通过虚引用取得对象实例.使用`PhantomReference `类实现.

##### 存活状态判断

即使在可达性分析中判定为不可达到的对象,也不一定必须要释放内存.一个对象需要释放内存的需要两个过程.

1. 可达性分析中发现指定对象无法到达GC Roots,将会被一次标记.
2. 进行一次筛选,条件为该对象是否有必要执行@finalize()方法.如果没有覆盖@finialize()或者这个方法已经被虚拟机调用过,则说明该对象不需要释放内存.

如果确实需要执行这个方法,将会将对象放在@F-Queue队列中,并在稍后,有一个虚拟机自动建立,低调度优先级的@Finalizer线程,执行finalize方法.这里的执行值得是这个方法开始运行,但是不必要等待运行结束(异步执行).@finalize方法是对象避免被释放前的最后一次机会,收集器对队列中的对象进行第二次小规模标记.如果这期间连接到引用链name就可以被移除回收队列.

演示一次对象的自我拯救过程:

```java
/*
	这个代码演示了两个方面
	1. 对象可以在GC期间自动回收
	2. 机会只有一次,因为一个对象至多调用一次@finalize()
*/
public class FinalizeEscapeGC{
    public static FinalizeEscapeGC SAVE_HOOK=null;
    public void isAlive(){
        System.out.println("Current State is Alive");
    }
    
    @override
    protected void finalize() throw Throwable{
        super.finalize();
        System.out.println("Finalize Method has executed");
        // 设置保存点
        FinalizeEscapeGC.SAVE_HOOK=this;
    }
    
    public static void main(String[] args) throws Throwable{
        // 
        SAVE_HOOK=new FinalizeEscapeGC();
        // 置空,等待回收
        SAVE_HOOK=null;
        // 进行回收,由于finalize方法优先级第,所以需要等待到其执行
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
	        SAVE_HOOK.isAlive();
        } else {
    	    System.out.println("no, i am dead :(");
        }
        
        // 第二次置空等待回收
        SAVE_HOOK=null;
        // 由于finalize只会调用一次,所以恢复失败,被回收
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
	        SAVE_HOOK.isAlive();
        } else {
    	    System.out.println("no, i am dead :(");
        }
    }
}
```

当然上述是一个演示程序,不建议使用finalize方法,因为运行代价大,不确定性高.无法保证对象的调用顺序.

##### 回收方法区

方法区垃圾收集器性价比比较低,java堆中尤其在新生代中,对于一次性垃圾回收可以回收70-99%的内存空间.相比直线,方法区内存回收判定条件苛刻,回收比低.

方法区垃圾回收主要回收两个部分,废弃的常量和不再使用的类型.回收废弃常量与回收堆内存相似.判定一个常量是否"废弃"的条件如下:

+ 该类所有的实例都被回收(java堆中不存在该类以及其任何子类)
+ 加载该类的类加载器已经被回收(很难达成,除非使用精心设计的可替换类加载器,例如OSGi,JSP等)
+ 该类的`java.lang.Class`对象没有在其他地方引用.无法再任何地方通过反射访问.

满足上述三个条件,才可能被回收,关于是否需要回收,虚拟机提供了`-Xnoclassgc`参数控制.可以使用`-verbose:class`,以及`-XX: +TraceClass-Loading``-XX: +TraceClassUnloading`加载类属性.

在大量使用反射,动态代理,CGLib等字节码框架中,动态生成JSP以及OSGo这类频繁自动以类加载器的场景中,需要java虚拟机具有类型卸载的能力.

#### 垃圾收集算法

垃圾收集算法可以分为`引用计数垃圾收集`和`追踪式垃圾收集器`两大类.分别称作**直接垃圾收集**和**间接垃圾收集**.下面着重介绍**追踪式垃圾收集器**.

##### 分代收集理论

##### 标记-清除算法

##### 标记-复制算法

##### 标记-整理算法



#### HotSpot算法实现细节

##### 根节点枚举

##### 安全点

##### 安全区域

##### 记忆集与卡表

##### 写屏障

##### 并发的可达性分析

#### 经典的垃圾收集器

##### Serial收集器

##### ParNew收集器

##### Parallel Scavenge收集器

##### Serial Old收集器

##### Parallel Old 收集器

##### CMS收集器

##### Garbage First收集器



#### 低延迟垃圾收集器

##### Shenandoah收集器

##### ZGC收集器



#### 垃圾收集器的选择

##### Eplilon收集器

##### 收集器的权衡

##### 虚拟机以及垃圾收集器日志

##### 垃圾收集器参数总结



#### 内存分配与回收策略

##### 对象优先在Eden分配

##### 大对象直接进入老年代

##### 长期存活的对象进入老年代

##### 动态对象年龄判定

##### 空间分配担保