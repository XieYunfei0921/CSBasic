**垃圾收集器与内存分配策略**

---

#### 对象存活的判断

##### 引用计数法

在对象中添加一个应用计数器,当有一个地方需要应用的时候,计数器值就加1.引用失败的时候,计数器值就减一.任何时刻计时器为0的对象就不能够再被使用.

可观来说引用计数虽然需要一定的内存空间进行计数(就是这个计数值,其中使用int类型所占空间要小于long).但是java虚拟机并没有使用这种内存管理方法,主要原因是看似简单的算法有许多的例外需要考虑.必须处理边界情况才能正常工作,例如,难以接口对象直接相互引用的情况.

例如:

```java
public class ReferenceCountGC{
    public Object instance=null;
    private static final int _1MB=1024*1024;
    // 这个属性用于查看日志是否有回收过，占用内存2MB，实际占用2M*byte类型的长度
    private byte[] bigSize=new byte[2*_1MB];
    public static void test(){
        ReferenceCountGC obja=new ReferenceCountGC();
        ReferenceCountGC objb=new ReferenceCountGC();
        // 两个实例的循环引用
        obja.instance=objb;
        objb.instance=obja;
        // 释放内存
        obja=null;
        objb=null;
        // GC,查看两个实例是否被回收
        System.GC();
    }
}
```

结果:

```shell
[Full GC (System) [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)]
Heap
```

可以看到内存分配量由4603减少到210,即这两个对象被回收了,说明java虚拟机不是通过引用计数来判断对象是否存活的.

##### 可达性分析算法

主流的程序语言的内存管理子系统使用的都是可达性分析法判断对象是否存活,这个算法的基本思路通过一些了称为`GC Root`的根对象作为起始节点集.从这些节点开始,根据引用关系(图的拓扑关系,单向边).所有过的**路径**称作**引用链**.如果某个对象到达`GC Roots`之间没有任何引用链,name就认为这个对象已经死亡,需要进行回收,具体实现可以求以`GC Roots`为一个顶点的连通图,不在该连通图中的节点需要进行回收.

例如:

<img src="E:\截图文件\可达性算法.png" style="zoom:67%;" />

java虚拟机中,可以作为GC Roots的对象(一定不会被回收的对象)

- 虚拟机栈(栈帧本地变量表)中引用的对象,例如各个线程被调用方法对象中使用的参数,局部变量,临时变量等.
- 方法区中类静态属性引用对象,譬如java类的引用类型静态变量.
- 方法区中常量引用对象,例如**字符串常量池**的引用
- 本地方法栈中JNI(native方法)引用的对象
- java虚拟机的内部引用,如基本数据类型对应的class对象.溢写常驻内存的异常(NullPointExcepiton,OutOfMemoryError ),还有系统类加载器
- 被同步锁持有的对象
- 反应java虚拟机内部的JMXBean,HVM TI注册的回调,本地代码缓存等.

除了固定的GC Roots集合之外,根据用户选择的垃圾收集器,以及当前回收的内存区域不同,可以有其他对象临时性的加入,共同构成GC Roots.

最新几款垃圾收集器无一例外使用了局部回收的特征.

##### 引用

jdk1.2之后,java对引用的概念进行扩充,分为强引用,软引用,弱引用,和虚引用.四种引用轻度逐渐减弱.

+ **强引用**: 传统引用定义,指代码中的普遍的引用复制,例如`Person p=new Person()`.无论何时只要强引用关系还在,垃圾回收器就不会回收.(可以设置`p=null`取消引用的实例).
+ **软引用**: 描述一些可以使用,但是非必须的对象.被软引用关联的对象,在系统发生内存溢出之前,会把对象回收范围进行二次回收(**对软引用的回收**),如果二次回收还是不能保证足够内存.才会抛出异常.使用`SoftReference`类实现.
+ **弱引用**: 用于描述非必须的对象，强度比**软引用**弱，被弱引用关联的对象只能生存岛下一次垃圾收集发送为止。当垃圾收集器开始龚总，无论当前内存是否足够，都会回收掉**弱引用**的对象。使用`WeakReference`类实现.
+ **虚引用**: 最弱的引用关系,一个对象是否有虚引用不会对生存时间产生影响,页无法通过虚引用取得对象实例.使用`PhantomReference `类实现.

##### 存活状态判断

即使在可达性分析中判定为不可达到的对象,也不一定必须要释放内存.一个对象需要释放内存的需要两个过程.

1. 可达性分析中发现指定对象无法到达GC Roots,将会被一次标记.
2. 进行一次筛选,条件为该对象是否有必要执行@finalize()方法.如果没有覆盖@finialize()或者这个方法已经被虚拟机调用过,则说明该对象不需要释放内存.

如果确实需要执行这个方法,将会将对象放在@F-Queue队列中,并在稍后,有一个虚拟机自动建立,低调度优先级的@Finalizer线程,执行finalize方法.这里的执行值得是这个方法开始运行,但是不必要等待运行结束(异步执行).@finalize方法是对象避免被释放前的最后一次机会,收集器对队列中的对象进行第二次小规模标记.如果这期间连接到引用链name就可以被移除回收队列.

演示一次对象的自我拯救过程:

```java
/*
	这个代码演示了两个方面
	1. 对象可以在GC期间自动回收
	2. 机会只有一次,因为一个对象至多调用一次@finalize()
*/
public class FinalizeEscapeGC{
    public static FinalizeEscapeGC SAVE_HOOK=null;
    public void isAlive(){
        System.out.println("Current State is Alive");
    }
    
    @override
    protected void finalize() throw Throwable{
        super.finalize();
        System.out.println("Finalize Method has executed");
        // 设置保存点
        FinalizeEscapeGC.SAVE_HOOK=this;
    }
    
    public static void main(String[] args) throws Throwable{
        // 
        SAVE_HOOK=new FinalizeEscapeGC();
        // 置空,等待回收
        SAVE_HOOK=null;
        // 进行回收,由于finalize方法优先级第,所以需要等待到其执行
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
	        SAVE_HOOK.isAlive();
        } else {
    	    System.out.println("no, i am dead :(");
        }
        
        // 第二次置空等待回收
        SAVE_HOOK=null;
        // 由于finalize只会调用一次,所以恢复失败,被回收
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
	        SAVE_HOOK.isAlive();
        } else {
    	    System.out.println("no, i am dead :(");
        }
    }
}
```

当然上述是一个演示程序,不建议使用finalize方法,因为运行代价大,不确定性高.无法保证对象的调用顺序.

##### 回收方法区

方法区垃圾收集器性价比比较低,java堆中尤其在新生代中,对于一次性垃圾回收可以回收70-99%的内存空间.相比直线,方法区内存回收判定条件苛刻,回收比低.

方法区垃圾回收主要回收两个部分,废弃的常量和不再使用的类型.回收废弃常量与回收堆内存相似.判定一个常量是否"废弃"的条件如下:

+ 该类所有的实例都被回收(java堆中不存在该类以及其任何子类)
+ 加载该类的类加载器已经被回收(很难达成,除非使用精心设计的可替换类加载器,例如OSGi,JSP等)
+ 该类的`java.lang.Class`对象没有在其他地方引用.无法再任何地方通过反射访问.

满足上述三个条件,才可能被回收,关于是否需要回收,虚拟机提供了`-Xnoclassgc`参数控制.可以使用`-verbose:class`,以及`-XX: +TraceClass-Loading``-XX: +TraceClassUnloading`加载类属性.

在大量使用反射,动态代理,CGLib等字节码框架中,动态生成JSP以及OSGo这类频繁自动以类加载器的场景中,需要java虚拟机具有类型卸载的能力.

#### 垃圾收集算法

垃圾收集算法可以分为`引用计数垃圾收集`和`追踪式垃圾收集器`两大类.分别称作**直接垃圾收集**和**间接垃圾收集**.下面着重介绍**追踪式垃圾收集器**.

##### 分代收集理论

1. **弱分代假说**: 绝大多数对象都是朝生夕灭的.
2. **强分代假说**: 经过多次垃圾回收过程的对象,就难以消亡.
3. **跨代引用假说**: 跨代引用相对于同代引用来说占少数

根据前两种垃圾收集器,收集器应当将java堆划分为不同区域.然后回收对象根据年龄(经过垃圾收集器的次数),分配到不同的区域中存储.显然的,如果区域中大多数对象是朝生夕灭的,难以通过垃圾回收的话,那么把它们集中放在一起, **每次回收只会关注少量存活的部分**,这些就可以提升回收的效率.如果剩下的都是难以消亡的对象,将它们集中在一起,虚拟机便可以使用较低的效率来回收这个区域.

java对区域划分完毕之后,垃圾收集器才可以每次只回收其中某个/部分的区域.因此,有了**MinorGC**,**Major GC**,**Full GC**这样回收类型的划分.页才能针对不同区域安排与内部存储对象特征相关的垃圾收集算法.

因此出现了,**标记复制法**,**标记清除法**,**标记整理法**的垃圾收集算法.

将分代收集理论具体到商用Java虚拟机中,设置值至少需要划分**新生代**和**老年代**.新生代中,对象有大批死去,每次回收后存活有少量的对象,将会逐步晋升为老年代.在HotSpot源码中,会发现*Generation*相关的实现,其中有`DefNewGeneration`和`ParNewGeneration`等,这就是HotSpot分代垃圾收集器框架.

> 考虑如下情况:
>
> 存在有相互引用的两个对象,倾向于同时生存和同时消亡.例如,某个新生代对象存在有跨代引用,由于老年代对象难以消亡,该引用会使得新生代对象在收集的时候**能够存活**.进而使之进入老年代,进入老年代之后,由于不是跨代引用所以跨代引用也会消除(变成了普通引用).

这里对于Minor GC相关概念作出如下定义:

> 部分收集(Partial GC) 目标不是收集完整java堆的垃圾收集
>
> + 新生代收集(Minor GC/Young GC)
> + 老年代收集(Major GC/Old GC)
> + 混合收集(Mixed GC)
>
> 整堆收集(Full GC)

##### 标记-清除算法

最早出现的垃圾收集算法时**标记清除**算法,分为标记和清除两个阶段.

> 缺陷:
>
> 1.  执行效率不稳定,如果java堆中大量对象都需要进行回收,这时候必须要进行大量的清除动作.标记和回收的时间消耗就会增大.
> 2. 存在有内存碎片,标记清除之后会存在有大量的内存碎片,内存碎片过多可能在之后分配大内存的时候不够分配,进而可能导致OOM的发生.但是如果对其进行有效的内存紧缩,那么是存在有足够空间用于分配的.

标记分配清除算法的原理图:

<img src="E:\截图文件\标记清除法.png" style="zoom:67%;" />

以最简单的分配实例,即分配回收的都是同样大小的数据块.(例如int类型,4字节)

对其部分内容进行回收,假设回收出来的内存碎片分布相当不均匀,分配完毕之后需要分配一个16字节类型的内存块.但是假定内存剩余量大于16字节,但是不存在有连续的内存块使得满足16块分配大小,那么这样就无法分配这16字节的数据,到时内存溢出,所以清理完毕之后需要对内存空间进行紧缩,以便下次分配.

扩展来说,当内存分配的内存数据块大小都不一致的时候,进行内存紧缩算法的时间复杂度更高,上述实例可以使用内存首地址+内存块大小(不变的量)的方式进行分配,而不同状态下设置的话,内存块大小是可变的.那么就需要使用一个链表(队列)对内存块信息进行管理,每次清除的时候,需要对相邻的碎片内存块进行合并.具体算法这里不做详述.

##### 标记-复制算法

将可用的内按大小分为响应的两块,每次只使用其中的一块,当这一块内存使用完毕,就将存活的对象复制到另外一块上面,然后把已经使用过的内存空间一次清理完毕.

+ 如果内存中多数对象都是存活的,这种算法会产生大量的内存间复制开销.
+ 对于多数对象都是可以回收的情况下,算法需要复制的就是占少量的存活对象.

由于每次分配都是针对于半个区域进行内存回收,分配时也就不需要考虑到内存碎片的问题.只需要移动堆顶指针即可.

>  缺陷明显,就是可分配的内存减少为原来的一把.

> 总体来说,这个方法清理方便.不需要考虑内存碎片,且复制的时候进行了内存紧缩.

如果内存中多数对象都是存活的,这种算法会产生大量的内存间复制开销.那是对于多数对象都是可以回收的情况下,算法需要复制的就是占少量的存活对象.

原理图

<img src="E:\截图文件\标记复制.png" style="zoom:67%;" />

##### 标记-整理算法

从上述两种算法可以看出如果需要移动内存块，就会使得空间使用量降低，不移动就会使得大量内存碎片的产生。

**标记整理**的方法，在回收的情况下依旧与**标记清除方法**一致，但是下一步不是直接回收内存，而是将离散的内存块进行合并,移除合并完的内存块,使得剩余的内存区域连续.这个过程称作**内存紧缩**.

原理图:

<img src="E:\截图文件\标记整理.png" style="zoom:67%;" />

#### HotSpot算法实现细节

##### 根节点枚举

可达性分析算法中从GC Roots集合中寻找引用链这个操作作为示例.固定可以作为GC Roots的节点主要在全局性引用中(常量/静态属性)与执行上下文(栈帧中的本地变量表)中,尽管目标明确,但是查找的高效性是一个问题.按照现在java应用的大小,方法区的大小通常就有上百上千兆,想要查找的时间复杂度相当高.

收集器从根节点枚举步骤时,都必须暂停用户线程(需要更多的系统资源执行计算).可达性分析算法已经可以和用于线程并发执行,但是根节点枚举还是必须保证一致性快照中才能执行(执行过程中引用关系不会发生变化,做不到这一点,分析结果无法保证正确性,这就是垃圾收集过程中必须停止用于线程的原因).即使是CMS,G1,ZGC这样的收集器也是需要在枚举根节点的时候停顿.

目前虚拟机中使用准确式垃圾收集器,所以当用于线程停顿下来之后,并不需要检查完所有执行上下文和全局变量的引用位置,虚拟机应当直接获得哪些地方存放着对象引用的.

一旦类加载动作完成的时候,虚拟机就会把对象内什么偏移量位置上的类型数据计算处理,即时编译中也会在特定位置记录栈中和寄存器中哪些位置是引用的信息记录起来.并不是需要从GC Roots查找.

下面是虚拟机客户端模式下,生成的一段String::hashCode()本地代码,可以看到0x026eb7a9 地址上call指令有OopMap记录.指明了EBX寄存器和栈中偏移量为16的内存区域,有宇哥普通对象直至的引用.有效范围为0x026eb730 +142(OopMap记录偏移量)-> 0x026eb7be 

```assembly
[Verified Entry Point]
0x026eb730: mov %eax,-0x8000(%esp)
…………
;; ImplicitNullCheckStub slow case
# 起始地址,寄存器ebx装载Oop,栈内偏移量16.记录偏移量142,结束地址0x026eb7a9+142
0x026eb7a9: call 0x026e83e0 ; OopMap{ebx=Oop [16]=Oop off=142}
; *caload
; - java.lang.String::hashCode@48 (line 1489)
; {runtime_call}
0x026eb7ae: push $0x83c5c18 ; {external_word}
0x026eb7b3: call 0x026eb7b8
0x026eb7b8: pusha
0x026eb7b9: call 0x0822bec0 ; {runtime_call}
0x026eb7be: hlt
```

##### 安全点

在OopMap的协助下,可以快速的完成GC Roots的枚举,但是可能导致引用关系的编号,或者说OopMap内容编号的指令非常多,但是每条指令都会生成对应的OopMap,会查产生大量的额外存储空间.

> 实际上OopMap没有为每条指令生成OopMap,指示在特定位置会生成,这些位置称作**安全点.**有了这个安全点,用于程序执行的时候并非在代码执行流的任意位置都能够执行垃圾收集.而是强制到安全点位置才能进行暂停.
>
> 安全点的选择既不能太少，会导致收集器等待时间过程，也不能过于频繁，这样会增大内存负荷。选择标准是**是否具有让程序长时间执行的特征**。因为每条指令的时间都是非常短暂的，但是不能使用指令流长度定义这个，长时间执行明显特征就是指令的复用，例如**方法调用**，**循环跳转**，**异常跳转**等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。

对于安全点，需要考虑的另一个问题是，如何在垃圾收集发生的时候让所有线程都到安全点，然后停顿下来，有两种方案：

1. 抢先式中断

   不需要线程的执行代码主动配合，在垃圾收集发生的时候，系统首先将用户线程全部中断，如果发现用户线程不在安全点上则恢复线程，过一会重新中断，直到运行到安全点上.(几乎没有虚拟机采样抢先式中断暂停线程响应GC事件)

2. 主动式中断

   >  垃圾收集器需要中断线程的时候,不直接对线程操作,仅仅设置一个标志位.
   >
   > 各个线程会不停地去轮询这个表示,一旦返现中断标志为真的时候,就在自己最近的安全点主动中断挂起.
   >
   > 轮询标志的位置和安全点是重合的.
   >
   > 另外还要加上所有创建对象和其他需要java堆上分配内存的地方作为安全点.这是为了检查是否即将发生垃圾回收,避免没有足够内存分配新对象的情况.

由于轮询操作在代码中会经常的出现,必须满足高效性,HotSpot使用内存保护陷阱的方式,使用一条汇编指令精简轮询操作.

```assembly
0x01b6d627: call 0x01b2b210 ; OopMap{[60]=Oop off=460}
; *invokeinterface size
; - Client1::main@113 (line 23)
; {virtual_call}
0x01b6d62c: nop ; OopMap{[60]=Oop off=461}
; *if_icmplt
; - Client1::main@118 (line 23)
# 将0x160100内存页设置为不可读,当执行测试指令是就会产生一个自陷移除信号,探后在预设的异常处理器中挂起,等待线程实现等待.这样就触发了安全的轮询和触发线程中断
0x01b6d62d: test %eax,0x160100 ; {poll}
0x01b6d633: mov 0x50(%esp),%esi
0x01b6d637: cmp %eax,%esi
```

##### 安全区域

安全点机制保证了程序的执行,在不太长的时间遇到垃圾收集过程的安全点,在程序不执行的时候,这些线程无法响应虚拟机的中断请求,不能到安全的地方将自己挂起,虚拟机也不可能持续等待线程重新被激活分配处理器时间.对于这种情况,需要引入**安全区域**的概念.

**安全区域**是值能够确保在一定代码片段中,引用关系不发生变化,因此在任务地方开始垃圾回收都是安全的.可以将安全区域视作安全点的扩展.

> 置于在非安全区域回收内存空间会发生什么 --> 可能会造成悬空访问的情况,且指向的引用已经被回收.

当用户线程进入到安全区域内部执行代码的时候,首先标识自己进入了安全区域,那样当这段时间内虚拟机发起垃圾回收的时候,就不需要声明自己处于安全区域内的线程了.

当线程离开安全区域的时候,需要检查虚拟机是否完成了根节点的枚举.如果完成了,线程就继续执行,否则就需要等待到可以离开安全区域的信号位置.

##### 记忆集与卡表

为了解决对象跨代引用的问题,垃圾收集器在新生代中建立了**记忆集**(Remembered Set)的数据结构,用于避免把整个老年代加入GC Roots的扫描范围.

事实上,不仅仅新生代和老年代会发生跨代引用的问题.所有涉及部分GC的垃圾收集器都会面临这个问题.所以需要明白记忆集的原理和实现方式.

> **记忆集**: 一种弄用于记录从非收集区指向收集区域的指针集合的抽象数据结构.
>
> 不考虑效率和成本的情况下,
>
> 最简单的实现可以使用非收集区域中所含有的跨代引用的对象数组来实现这个数据结构
>
> ```java
> class RemerberSet{
>  Object[] set[OBJECT_RERERENCE_GENETATION_CROSS_SIZE]; 
> }
> ```
>
> 这种记录全部汉跨点引用对象的实现,空间使用了和维护成本都非常的高.在垃圾收集器的场景中,收集器通过记忆集判断出一块非收集区域是否存在指向收集区域指针就行了.不需要指明跨代指针的全部细节.
>
> 可以设置下述的记录精度:
>
> + 字长精度 : 每个记录精确到一个机器字长,包含了跨代指针
> + 对象精度: 每个记录精确到一个对象,对象中包含跨代指针
> + 卡精度" 紧缺的一个内存区域,包含跨代指针
>
> 其中卡精度称作**卡表**,用于实现**记忆集**.也是目前常用的记忆集实现方式.
>
> 最简单得,可以将卡表视作字节数组,HotSpot虚拟机也是这么做的:
>
> ```shell
> CARD_TABLE {this address>>9} = 0
> ```
>
> 字节数组CARD_TABLE每一个元素对应着标识的内存区域一块特定大小的内存块，这个内存块被称作**卡页**。一般来说，卡页的大小为2的n次方。上述代码表示的是一个512字节的内存空间。如果内存起始地址为0x0000的话，数组CARD_TABLE的第0,1,2号元素分别对应内存范围：
>
> 0x0000-0x01FF，0x0200-0x03DD，0x0400-0x05FF的内存区域。

##### 写屏障

上面已经使用记忆集缩减GC Roots扫描范围的问题，但是还是没有解决卡表如何维护的问题.

例如,它们何时变脏,什么使之变脏.

变脏条件很明确-其他分代区域中对象引用本区域对象时，其对应的卡表元素就应该变脏。变脏的时间点原则上应该放手在引用类型字段赋值的一刻。但问题是如何变脏。即如何在对象赋值的时刻去更新维护卡表。

加入是解释执行的字节码，那么相对好处理，虚拟机负责每条字节码指令的执行，有充分的介入空间。

在编译执行场景中，经过及时编译后的代码已经是纯粹的机器指令流了。

在HotSpot虚拟机内，使用**写屏障**计数维护卡表状态。这里的**写屏障**和低延时收集器的**读屏障**需要和解决并发顺序的**内存屏障**区分开来。

协同到可以看做对**引用类型字段赋值**这个动作的AOP切面。在应用对象赋值的时候会产生一个**环形通知**。供程序执行额外的动作，也就是说赋值前后都在写屏障的覆盖范畴内。在赋值前的部分写屏障叫做**写前屏障**，在赋值之后的叫做**写后屏障**。下面是卡表的更新简化逻辑。

```c
void oop_field_store(oop* field, oop new_value) {
    // 引用字段的赋值操作
    *field= new_value;
    // 写后屏障,完成卡表状态的更新
    post_write_barrier(field,new_value);
}
```

应用写屏障之后,虚拟机就会为所有赋值操作生成相应的指令,一旦收集器在写屏障中增加了更新卡表操作,无论更新的是不是老年代对新生代对象的引用.每次只需要对引用进行更新,就会产生额外的开销,不过与Minor GC扫描老年代还是代价低的多的.

除了写屏障开销之外,卡表在高并发场景下还面临着**伪共享**的问题.伪共享是除了并发底层细节进程需要考虑的问题,CPU的缓存系统是以**缓存行**为单位存储,当共享一个缓存行的时候,会彼此影响从而导致性能下降.

##### 并发的可达性分析

可达性分析算法理论要求全过程基于一个能够保证一致性的快照才能够进行分析.意味着需要冻结用于线程的运行.

于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数， 且在各种优化技巧（如OopMap） 的加持下,它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长） 的了 .

可从GC Roots再继续往下遍历对象图,这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了: 堆越大,存储的对象越多,对象图结构越复杂,要标记更多对象而产生的停顿时间自然就更长.

要知道包含标记节点是所有追踪式垃圾收集算法共同特征,这个阶段会随着对变大而等比例增加停顿时间,会波及所有的垃圾收集器.所以应当降低这个停顿时间.

为了解决用户线程停顿问题,需要清除为什么必须在能保证一致性的快照上才能进行对象图的遍历.

引用三色求进行过程演示,其中:

+ 白色: 对象还没有被垃圾收集器访问过,处于可达性分析的开始阶段,如果分析完毕依旧处于白色,则表示不可到达.

+ 黑色: 对象已经被收集器访问过,且这个对象的所有引用都被扫描过,表示对象安全存活.如果有其他对象指向褐色对象,则无需重新扫描.
+ 灰色: 表示对象已经被垃圾收集器访问过,但是这个对象至少存在一个引用还没有被扫描过.

下图演示**对象消失**问题的示意：

<img src="E:\截图文件\收集器扫描图.png" style="zoom:67%;" />

因此，解决对象消失问题的时候，只需破坏这两个条件的一个即可，因此产生了两种方案：

1.  增量更新

   > 增量更新破坏第一个条件,当黑色对象插入指向新的指向白色对象引用关系的时候,就将这个新插入的引用记录下来,等并发扫描结束之后,在将这些记录过的引用关系中黑色对象为根,重新扫描移除(可以理解为插入白色之后变成了灰色对象).

2. 原始快照

   > 破坏的是第二个条件,当灰色对象要删除指向白色对象的引用关系的时候,就将删除引用记录下来.并发扫描之后,将这些记录过的引用关系视作灰色对象的根,重新扫描一次(意味着无论引用关系如何,都会按照刚开始扫描的那一刻对象快照进行搜索)

#### 经典的垃圾收集器

<img src="E:\截图文件\HotSpot垃圾收集器.png" style="zoom:67%;" />

上图展示了七种不同的分代收集器,两两直接存在有连接则表示可以一起使用.所显示去区域分割表示老年代和新生代的分割.

##### Serial收集器

最基础最古老的垃圾收集器,这个收集器是一个单线程工作的收集器,但是并不是说明只会使用一个处理器或者一个处理线程去完成收集工作.强调的是在垃圾收集时必须停止其他所有的工作线程.

这项工作时虚拟机在后台自动发起和完成的,在用户不知道,不可控的情况下将正常工作线程全部暂停.对于用户来说时不可以接受的.

<img src="E:\截图文件\Serial-SerialOld收集器.png" style="zoom:67%;" />

> 优势: 简单而高效,对于内存资源环境受限的情况下,在所有收集器中额外内存消耗最小.
>
> 缺陷: 经常需要停止正常工作线程,进行回收.
>
> 适用于客户端模式下的虚拟机.

##### ParNew收集器

实质上时Serial收集器的多线程并行版本,同时使用多个线程处理垃圾收集.其行为包括所有serial收集器空值的参数(-XX： SurvivorRatio,-XX:PretenureSizeThreshold,-XX:HandlePromotionFailure),收集算法,对象分配规则,对象回收策略.回收过程如下:

<img src="E:\截图文件\Parnew-serialOld收集器.png" style="zoom:67%;" />

适用于jdk 7之前的系统，处理serial之外，只有他可以与CMS收集器配合使用。所以在旧版本的jdk中,可以使用在服务端上.在官方出现了G1收集器之后,将ParNew作为CMS的唯一搭配.

##### Parallel Scavenge收集器

这是一款新生代收集器,同样是基于标记**复制算法**实现的.也是能够进行并行收集的多线程收集器.

这个收集器关注的点与其他收集器不同,CMS关注缩短垃圾收集用户线程的等待时间.而**Parallel Scavenge** 关注的是一个可控制的吞吐量.所谓的吞吐量四处理器用于运行用户代码的时间与处理器总消耗时间的比值.即

> 吞吐量= 运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)

收集器提供两个参数用于精确控制吞吐量,分别是控制最大垃圾收集停顿时间

`-XX:MaxGCPauseMills`以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数

由于与吞吐量密切相关,Parrallel Scanvenge收集器也就做**吞吐量优先收集器**.这里还有一个参数需要注意,就是`-XX:UseAdaptiveSizePolicy`.这是一个开关参数,激活之后,就不需要人工指定新生代大小`-Xmn`,Eden与Survivor区比例参数(`-XX:SurvivorRatio`),晋升到老年代大小(`-XX:PretenureSizeThreshold`)等细节参数.虚拟机会根据当前运行情况收集性能监控参数,动态调整这些参数,以获取最大吞吐量,这个叫**自适应的条件策略**.如果对于收集器运行不太了解,可以使用这个策略进行设置.

##### Serial Old收集器

是Serial收集器的老年代版本,是一个单线程收集器.使用标记整理算法.主要用于客户端的虚拟机使用,在服务器状态下,jdk5之前使用Parralel Scavenge收集器搭配使用.另一种就是作为CMS的后备选择.

<img src="E:\截图文件\Serial-SerialOld收集器.png" style="zoom:67%;" />

##### Parallel Old 收集器

Parallel Scaveng 收集器的老年代版本,支持多线程并发收集,基于标记整理算法实现.jdk 6开始使用,这个组合注重吞吐量,适合处理器资源比较稀缺的场合.

<img src="E:\截图文件\ParralleScanvage收集器.png" style="zoom:67%;" />

##### CMS收集器

CMS收集器是一种旨在获取最短回收停顿时间为目标的收集器.基于标记清除算法实现,相对于前面的收集器运行过程较多,一般地:

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

其中初始标记和重新标记仍然需要停止用户线程.初始标记仅仅标记一下GC Roots就能够直接关联到对象,速度很快.

并发标记阶段就是遍历整个图,进行标记.这个过程消耗的时间长,但是不需要中断用户线程.可以与垃圾收集线程一起并发运行.

重新标记阶段是为了修正并发标记期间,因用户程序继续运行而导致标记变动的那一部分对象的标记记录(增量更新).这个阶段会比初始阶段长一些,但是远远小于并发标记阶段.

清理删除标记阶段,判断处于死亡状态的对象,由于不需要移除存活对象,所以这个阶段是可以和用户线程同时进行的.

整个过程中并发标记和并发清除阶段中,垃圾收集器都是可以与用户线程一起工作,占了绝大多数运行时间.

<img src="E:\截图文件\ConcurrentMarkSweep收集器.png" style="zoom:67%;" />

> 缺陷:
>
> 1.  CMS收集器对处理器资源非常敏感
> 2.  由于CMS收集器无法处理“浮动垃圾”(Floating Garbage),有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生
> 3. 收集结束时会有大量空间碎片产生

##### Garbage First收集器

G1收集器被称作**全功能垃圾收集器**.应用于服务端应用的垃圾收集器.JDK 9发布之后,成为服务器端的默认垃圾收集器,如果使用CMS将会受到一条警告信息.

```shell
# VM Args -XX:UseConcMarkSweepGC(开启CMS收集器)
Java HotSpot(TM) 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 
```

作为CMS的替代产品,希望建立起**停顿时间模型**的收集器,这个模型支持在指定长度为M毫秒的时间片段内,消耗在垃圾收集的时间不超过N毫秒的目标,已经成为实时kava中软实时垃圾收集器特征了.

为了实现这个目标,需要作出思想的改变.在G1收集器之前的收集器中,垃圾收集的目标是整个新生代.要么是整个老年代.要么就是整个java堆.而G1跳出了这个范畴,使用面向堆内存任何部分进行回收(CSet).衡量的标准不再是哪个恩待,而是那块内存中存放的垃圾最多,回收收益最多,也就是G1收集器中Mixed GC的模式.

G1收集器开创了基于Region的堆内存布局,使得能够实现区域回收的功能.虽然G1遵守分代回收理论,但是堆内存布局和其他收集器有相当的不同.不再坚持固定大小和固定数量的分代区域划分.而是把多个连续的java堆划分出多个大小相等的Region区域,每个Region区域都可以根据需要,扮演新生代的Eden空间,Survivor空间或者老年代空间.

收集器对扮演不同教师的Region采样不同策略处理,这样无论新建对象韩式已经存活一段时间,熬过多次收集的就对象都可以获取很好的收集效果.

在Region区域内部有一类特殊的Humongoous区域，专门用于存储大对象。G1只要再大小超过Region容量一般的对象即可被判断为大对象。每个Region区域可以通过`-XX:G1HeapRegionSize`设定,取值范围为1-32MB,应当取值为2的n次方.对于超过整个region容量的大对象,将会被存储到n个连续的区域中.G1大多行为把Humongous Region作为老年代一部分看到.

虽然G1仍然保留新生代和老年代概念,但是新生代和老年代不是固定的,都是一系列区域的动态集合.G1收集器可以建立可预测的停顿时间模型,因为将Region作为单次回收的最小单元,即每次回收都是Region大小的整数倍.可以有计划的避免java堆的全区域垃圾回收.

具体来说,使用G1收集器跟踪各个Region里面垃圾堆积"价值"的大小.这里的价值指的是回收获取空间大小以及回收所需时间的经验值.

在后台维护一个优先级列表,根据用户设定的收集停顿时间`-XX:MaxGCPauseMills`指定,默认为200ms.优先处理回收价值最大的region.

<img src="E:\截图文件\G1收集器Region分区.png" style="zoom:67%;" />

G1收集器的运行过程大致可以分为如下4个步骤:

+ 初始标记: 仅仅标记一下GC Roots能够直接关联的对象,**并且修改TAMS指针的值**,让下一个阶段用户线程并发执行.这个阶段需要短暂的停止用户线程.
+ 并发标记: 从GC Roots开始对堆中的对象进行可达性分析.找出需要回收对象,可以与用户线程并发执行.对象图扫描完成之后,还有重新处理SATB.记录并发时有变动的对象.
+ 最终标记: 用于线程短暂暂停,用于**处理并发执行阶段遗留的少量STAB记录**(这部分记录无法再并发阶段标记)
+ 筛选回收: 负载更新Region的统计数据,对各自Region进行回收价值和成本进行排序.根据用户所期望的停顿时间制定回收计划,可以自由选择任意多个region构成回收集合.然后将存活的对象复制到空的region中,再清理掉旧的regoin区域.(必须暂停用户线程)

由上面的过程可知,G1收集器除了并发标记之外,其余阶段都是停止用户线程的,所以G1并非完全追求低延时.官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量. 

由于回收阶段设计成与用户程序同时执行比较麻烦.考虑到G1只是回收一部分region,停顿是用户可控的,所以不需要特别地去实现.把这个特性放置到ZGC中处理.

<img src="E:\截图文件\G1收集器.png" style="zoom:67%;" />

> **优势**:
>
> 1. 基于标记整理算法,局部上来看(两个region区域)上是基于标记复制算法.无论如何都不会产生内存碎片.
>
> 确定:
>
> 1. 垃圾回收中的内存占用以及额外执行的负载都比CMS高.
>    + G1的卡表设计的更为复杂,且每个region都必须要有一份卡表
>    + G1使用写后屏障的同时,还需要实现快照搜索算法(SATB).需要使用写前屏障跟踪并发时指针的位置.

#### 低延迟垃圾收集器

垃圾回收三个指标:

+ 内存占用
+ 吞吐量
+ 延迟

##### Shenandoah收集器

1.  工作流程

   + **初始标记**：标记与GC Roots直接关联对象，需要停止所有用户线程，停顿时间只和GC Roots关联。
   + **并发标记**：与G1一样，变量对象图，标记处全部可达到的对象，与用户并发执行。执行时间如图的结构有关。
   + **最终标记**： 处理剩余的SATB扫描，统计出回收价值最高的Region。使得这些Region构建成一个回收集。这个阶段需要停止用户线程，防止对SATB的修改。
   + **并发清理**： 用于清理整个区域内一个存活对象都没有找到的region
   + **并发回收**： 这个阶段，将回收集中的存活对象复制一份到其他没有被使用的region中。需要在并发的情况下进行移动。在移动的时候用户线程可能对其进行访问。这个回收器会同步**读取屏障**(用于处理并发顺序)和被称为**Brooks Pointers**来解决。
   + **初始引用更新**：并发回收阶段结束之后，需要把堆中所有指向旧对象的引用指向复制后的地址，这个叫做引用更新.(修改指针指向,在释放原有引用的内存空间).这里建立一个线程集合点(Hook),确保所有回收线程都完成对象的移动.
   + **并发引用更新**: 开始进行更新操作,与用户线程并发,时间长短取决于内存中涉及引用数量.不需要再使用图结构搜索进行处理.只需要按照内存物理地址的顺序,线性搜索即可.
   + **最终引用更新**: 解决堆中引用更新之后,处理GC Roots中的引用,中断用户线程.
   + **并发清理**： 经过并发回收和引用更新之后， 整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了,最后再调用一次并发清理过程来回收
     这些Region的内存空间,供以后新对象分配使用 

   重要的三个阶段为**并发标记**,**并发回收**,**并发引用更新**.

   <img src="E:\截图文件\Shoadho运行过程.png" style="zoom:67%;" />

   **Brook Pointer**

   使用转发指针实现对象移动与用户程序并发的一种解决方案.在需要移动的对象设置**保护陷阱**.一旦用户程序访问到属于旧对象的内存就会产生自陷.进入预先设置的异常处理,在由其中代码逻辑将访问转发到复制后的对象上.但是如果操作系统如果不提供直接支持,会导致从用户态频繁的切换到核心态.代价非常大.不建议频繁执行.

   Brooks提出的新方案不需要用到内存保护陷阱, 而是在原有对象布局结构的最前面统一增加一个
   新的引用字段, 在正常不处于并发移动的情况下,该引用指向对象自己 .这个设置页导致了会出现线程间竞争的问题,如果读取的时候可以使用普通的共享锁读取,但是涉及到并发写入,就必须保证写操作只能发生在新复制的对象上,而不是写入到旧对象的内存中.

   > 假设:
   >
   > 1. 收集器线程复制了新的对象副本
   > 2. 用户线程更新对象某个字段
   > 3. 收集器线程更新转发指针指向新的副本地址
   >
   > 如果不做保护措施,用户会对旧的对象进行变更.所以必须对转发指针访问进行同步,

   收集器通过CAS操作保证并发访问的正确性.

##### ZGC收集器

​	ZGC在尽可能保证吞吐量的情况下实现任务堆内存大小下把垃圾回收的停顿时间限制在10ms之内。

1. ZGC收集器的布局

   与G1和Shenandoah收集器一样，是基于Region的堆内存布局，但是ZGC的Region具有一定的动态性。动态的创建和销毁,以及动态区域容量大小.在x64硬件平台下,ZGC的Region可以分配如下三种类型:

   + 小型Region: 固定容量2MB,防止小于256K的小对象
   + 中型Region: 固定容量32MB,返回值256K-4MB的对象
   + 大型Region: 容量不固定,可以动态变化,但是必须是2MB的整数倍,用于存放4MB以上的大对象.
   
2. ZGC核心问题-并发整理算法

   ZGC使用了读取屏障，但是使用了另一种对指针的处理--**染色指针技术**(Tag Point).以前需要在对象上存储一些额外的,只供收集器使用,或者虚拟机本身使用的数据,通常会在对象头中添加额外的存储字段.如对象的哈希码、 分代年龄、 锁记录等就是这样存储的信息.

3. 染色指针技术

4. ZGC的工作方式

   + 并发标记

     并发标记是遍历对象图做可达性分析的阶段.前后需要进过初始化标记,并发标记,最终标记的过程.

   + 并发预备重分配

     根据特定的查询条件统计得出本次收集过程中需要清理哪些Region。将这些Region重组成分配集。重新注册的分配集与G1收集器有些区别。ZGC每次会回收会扫描所有的Region，用范围更大的扫描省去G1记忆集的维护成本。

   + 并发重分配
   
     将重分配集中存活对象复制到新的Region上，并为每个Region维护一个转发表，记录旧对象到新对象的转向关系。
   
     由于染色指针的支持，ZGC收集器仅仅从引用上就可以得知一个对象是否处于新对象的转向关系中。
   
     如果用户线程此时并发访问了位于重分配集中的对象， 这次访问将会被预置的内存屏障所截获， 然后立即根据Region上的转发表记录将访问转发到新复制的对象上， 并同时修正更新该引用的值， 使其直接指向新对 ，这个叫做指针的自愈
   
   + 并发重映射
   
     重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用， 这一点从目标角度看是与Shenandoah并发引用更新阶段一样的， 但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，即使是旧的指针也是可以自愈的。
   
     ZGC很巧妙地把并发重映射阶段要做的工作， 合并到了下一次垃圾收集循环中的并发标记阶段里去完成， 反正它们都是要遍历所有对象的， 这样合并就节省了一次遍历对象图[9]的开销。 

#### 垃圾收集器的选择

##### Eplilon收集器

##### 收集器的权衡

##### 虚拟机以及垃圾收集器日志

##### 垃圾收集器参数总结



#### 内存分配与回收策略

##### 对象优先在Eden分配

##### 大对象直接进入老年代

##### 长期存活的对象进入老年代

##### 动态对象年龄判定

##### 空间分配担保



**其他**

1. [三色标记法](https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking)