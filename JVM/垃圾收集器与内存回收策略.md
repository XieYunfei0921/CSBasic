**垃圾收集器与内存分配策略**

---

#### 对象存活的判断

##### 引用计数法

在对象中添加一个应用计数器,当有一个地方需要应用的时候,计数器值就加1.引用失败的时候,计数器值就减一.任何时刻计时器为0的对象就不能够再被使用.

可观来说引用计数虽然需要一定的内存空间进行计数(就是这个计数值,其中使用int类型所占空间要小于long).但是java虚拟机并没有使用这种内存管理方法,主要原因是看似简单的算法有许多的例外需要考虑.必须处理边界情况才能正常工作,例如,难以接口对象直接相互引用的情况.

例如:

```java
public class ReferenceCountGC{
    public Object instance=null;
    private static final int _1MB=1024*1024;
    // 这个属性用于查看日志是否有回收过，占用内存2MB，实际占用2M*byte类型的长度
    private byte[] bigSize=new byte[2*_1MB];
    public static void test(){
        ReferenceCountGC obja=new ReferenceCountGC();
        ReferenceCountGC objb=new ReferenceCountGC();
        // 两个实例的循环引用
        obja.instance=objb;
        objb.instance=obja;
        // 释放内存
        obja=null;
        objb=null;
        // GC,查看两个实例是否被回收
        System.GC();
    }
}
```

结果:

```shell
[Full GC (System) [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)]
Heap
```

可以看到内存分配量由4603减少到210,即这两个对象被回收了,说明java虚拟机不是通过引用计数来判断对象是否存活的.

##### 可达性分析算法

主流的程序语言的内存管理子系统使用的都是可达性分析法判断对象是否存活,这个算法的基本思路通过一些了称为`GC Root`的根对象作为起始节点集.从这些节点开始,根据引用关系(图的拓扑关系,单向边).所有过的**路径**称作**引用链**.如果某个对象到达`GC Roots`之间没有任何引用链,name就认为这个对象已经死亡,需要进行回收,具体实现可以求以`GC Roots`为一个顶点的连通图,不在该连通图中的节点需要进行回收.

例如:

<img src="E:\截图文件\可达性算法.png" style="zoom:67%;" />

java虚拟机中,可以作为GC Roots的对象(一定不会被回收的对象)

- 虚拟机栈(栈帧本地变量表)中引用的对象,例如各个线程被调用方法对象中使用的参数,局部变量,临时变量等.
- 方法区中类静态属性引用对象,譬如java类的引用类型静态变量.
- 方法区中常量引用对象,例如**字符串常量池**的引用
- 本地方法栈中JNI(native方法)引用的对象
- java虚拟机的内部引用,如基本数据类型对应的class对象.溢写常驻内存的异常(NullPointExcepiton,OutOfMemoryError ),还有系统类加载器
- 被同步锁持有的对象
- 反应java虚拟机内部的JMXBean,HVM TI注册的回调,本地代码缓存等.

除了固定的GC Roots集合之外,根据用户选择的垃圾收集器,以及当前回收的内存区域不同,可以有其他对象临时性的加入,共同构成GC Roots.

最新几款垃圾收集器无一例外使用了局部回收的特征.

##### 引用

jdk1.2之后,java对引用的概念进行扩充,分为强引用,软引用,弱引用,和虚引用.四种引用轻度逐渐减弱.

+ **强引用**: 传统引用定义,指代码中的普遍的引用复制,例如`Person p=new Person()`.无论何时只要强引用关系还在,垃圾回收器就不会回收.(可以设置`p=null`取消引用的实例).
+ **软引用**: 描述一些可以使用,但是非必须的对象.被软引用关联的对象,在系统发生内存溢出之前,会把对象回收范围进行二次回收(**对软引用的回收**),如果二次回收还是不能保证足够内存.才会抛出异常.使用`SoftReference`类实现.
+ **弱引用**: 用于描述非必须的对象，强度比**软引用**弱，被弱引用关联的对象只能生存岛下一次垃圾收集发送为止。当垃圾收集器开始龚总，无论当前内存是否足够，都会回收掉**弱引用**的对象。使用`WeakReference`类实现.
+ **虚引用**: 最弱的引用关系,一个对象是否有虚引用不会对生存时间产生影响,页无法通过虚引用取得对象实例.使用`PhantomReference `类实现.

##### 存活状态判断

即使在可达性分析中判定为不可达到的对象,也不一定必须要释放内存.一个对象需要释放内存的需要两个过程.

1. 可达性分析中发现指定对象无法到达GC Roots,将会被一次标记.
2. 进行一次筛选,条件为该对象是否有必要执行@finalize()方法.如果没有覆盖@finialize()或者这个方法已经被虚拟机调用过,则说明该对象不需要释放内存.

如果确实需要执行这个方法,将会将对象放在@F-Queue队列中,并在稍后,有一个虚拟机自动建立,低调度优先级的@Finalizer线程,执行finalize方法.这里的执行值得是这个方法开始运行,但是不必要等待运行结束(异步执行).@finalize方法是对象避免被释放前的最后一次机会,收集器对队列中的对象进行第二次小规模标记.如果这期间连接到引用链name就可以被移除回收队列.

演示一次对象的自我拯救过程:

```java
/*
	这个代码演示了两个方面
	1. 对象可以在GC期间自动回收
	2. 机会只有一次,因为一个对象至多调用一次@finalize()
*/
public class FinalizeEscapeGC{
    public static FinalizeEscapeGC SAVE_HOOK=null;
    public void isAlive(){
        System.out.println("Current State is Alive");
    }
    
    @override
    protected void finalize() throw Throwable{
        super.finalize();
        System.out.println("Finalize Method has executed");
        // 设置保存点
        FinalizeEscapeGC.SAVE_HOOK=this;
    }
    
    public static void main(String[] args) throws Throwable{
        // 
        SAVE_HOOK=new FinalizeEscapeGC();
        // 置空,等待回收
        SAVE_HOOK=null;
        // 进行回收,由于finalize方法优先级第,所以需要等待到其执行
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
	        SAVE_HOOK.isAlive();
        } else {
    	    System.out.println("no, i am dead :(");
        }
        
        // 第二次置空等待回收
        SAVE_HOOK=null;
        // 由于finalize只会调用一次,所以恢复失败,被回收
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
	        SAVE_HOOK.isAlive();
        } else {
    	    System.out.println("no, i am dead :(");
        }
    }
}
```

当然上述是一个演示程序,不建议使用finalize方法,因为运行代价大,不确定性高.无法保证对象的调用顺序.

##### 回收方法区

方法区垃圾收集器性价比比较低,java堆中尤其在新生代中,对于一次性垃圾回收可以回收70-99%的内存空间.相比直线,方法区内存回收判定条件苛刻,回收比低.

方法区垃圾回收主要回收两个部分,废弃的常量和不再使用的类型.回收废弃常量与回收堆内存相似.判定一个常量是否"废弃"的条件如下:

+ 该类所有的实例都被回收(java堆中不存在该类以及其任何子类)
+ 加载该类的类加载器已经被回收(很难达成,除非使用精心设计的可替换类加载器,例如OSGi,JSP等)
+ 该类的`java.lang.Class`对象没有在其他地方引用.无法再任何地方通过反射访问.

满足上述三个条件,才可能被回收,关于是否需要回收,虚拟机提供了`-Xnoclassgc`参数控制.可以使用`-verbose:class`,以及`-XX: +TraceClass-Loading``-XX: +TraceClassUnloading`加载类属性.

在大量使用反射,动态代理,CGLib等字节码框架中,动态生成JSP以及OSGo这类频繁自动以类加载器的场景中,需要java虚拟机具有类型卸载的能力.

#### 垃圾收集算法

垃圾收集算法可以分为`引用计数垃圾收集`和`追踪式垃圾收集器`两大类.分别称作**直接垃圾收集**和**间接垃圾收集**.下面着重介绍**追踪式垃圾收集器**.

##### 分代收集理论

1. **弱分代假说**: 绝大多数对象都是朝生夕灭的.
2. **强分代假说**: 经过多次垃圾回收过程的对象,就难以消亡.
3. **跨代引用假说**: 跨代引用相对于同代引用来说占少数

根据前两种垃圾收集器,收集器应当将java堆划分为不同区域.然后回收对象根据年龄(经过垃圾收集器的次数),分配到不同的区域中存储.显然的,如果区域中大多数对象是朝生夕灭的,难以通过垃圾回收的话,那么把它们集中放在一起, **每次回收只会关注少量存活的部分**,这些就可以提升回收的效率.如果剩下的都是难以消亡的对象,将它们集中在一起,虚拟机便可以使用较低的效率来回收这个区域.

java对区域划分完毕之后,垃圾收集器才可以每次只回收其中某个/部分的区域.因此,有了**MinorGC**,**Major GC**,**Full GC**这样回收类型的划分.页才能针对不同区域安排与内部存储对象特征相关的垃圾收集算法.

因此出现了,**标记复制法**,**标记清除法**,**标记整理法**的垃圾收集算法.

将分代收集理论具体到商用Java虚拟机中,设置值至少需要划分**新生代**和**老年代**.新生代中,对象有大批死去,每次回收后存活有少量的对象,将会逐步晋升为老年代.在HotSpot源码中,会发现*Generation*相关的实现,其中有`DefNewGeneration`和`ParNewGeneration`等,这就是HotSpot分代垃圾收集器框架.

> 考虑如下情况:
>
> 存在有相互引用的两个对象,倾向于同时生存和同时消亡.例如,某个新生代对象存在有跨代引用,由于老年代对象难以消亡,该引用会使得新生代对象在收集的时候**能够存活**.进而使之进入老年代,进入老年代之后,由于不是跨代引用所以跨代引用也会消除(变成了普通引用).

这里对于Minor GC相关概念作出如下定义:

> 部分收集(Partial GC) 目标不是收集完整java堆的垃圾收集
>
> + 新生代收集(Minor GC/Young GC)
> + 老年代收集(Major GC/Old GC)
> + 混合收集(Mixed GC)
>
> 整堆收集(Full GC)

##### 标记-清除算法

最早出现的垃圾收集算法时**标记清除**算法,分为标记和清除两个阶段.

> 缺陷:
>
> 1.  执行效率不稳定,如果java堆中大量对象都需要进行回收,这时候必须要进行大量的清除动作.标记和回收的时间消耗就会增大.
> 2. 存在有内存碎片,标记清除之后会存在有大量的内存碎片,内存碎片过多可能在之后分配大内存的时候不够分配,进而可能导致OOM的发生.但是如果对其进行有效的内存紧缩,那么是存在有足够空间用于分配的.

标记分配清除算法的原理图:

<img src="E:\截图文件\标记清除法.png" style="zoom:67%;" />

以最简单的分配实例,即分配回收的都是同样大小的数据块.(例如int类型,4字节)

对其部分内容进行回收,假设回收出来的内存碎片分布相当不均匀,分配完毕之后需要分配一个16字节类型的内存块.但是假定内存剩余量大于16字节,但是不存在有连续的内存块使得满足16块分配大小,那么这样就无法分配这16字节的数据,到时内存溢出,所以清理完毕之后需要对内存空间进行紧缩,以便下次分配.

扩展来说,当内存分配的内存数据块大小都不一致的时候,进行内存紧缩算法的时间复杂度更高,上述实例可以使用内存首地址+内存块大小(不变的量)的方式进行分配,而不同状态下设置的话,内存块大小是可变的.那么就需要使用一个链表(队列)对内存块信息进行管理,每次清除的时候,需要对相邻的碎片内存块进行合并.具体算法这里不做详述.

##### 标记-复制算法

将可用的内按大小分为响应的两块,每次只使用其中的一块,当这一块内存使用完毕,就将存活的对象复制到另外一块上面,然后把已经使用过的内存空间一次清理完毕.

+ 如果内存中多数对象都是存活的,这种算法会产生大量的内存间复制开销.
+ 对于多数对象都是可以回收的情况下,算法需要复制的就是占少量的存活对象.

由于每次分配都是针对于半个区域进行内存回收,分配时也就不需要考虑到内存碎片的问题.只需要移动堆顶指针即可.

>  缺陷明显,就是可分配的内存减少为原来的一把.

> 总体来说,这个方法清理方便.不需要考虑内存碎片,且复制的时候进行了内存紧缩.

如果内存中多数对象都是存活的,这种算法会产生大量的内存间复制开销.那是对于多数对象都是可以回收的情况下,算法需要复制的就是占少量的存活对象.

原理图

<img src="E:\截图文件\标记复制.png" style="zoom:67%;" />

##### 标记-整理算法

从上述两种算法可以看出如果需要移动内存块，就会使得空间使用量降低，不移动就会使得大量内存碎片的产生。

**标记整理**的方法，在回收的情况下依旧与**标记清除方法**一致，但是下一步不是直接回收内存，而是将离散的内存块进行合并,移除合并完的内存块,使得剩余的内存区域连续.这个过程称作**内存紧缩**.

原理图:

<img src="E:\截图文件\标记整理.png" style="zoom:67%;" />

#### HotSpot算法实现细节

##### 根节点枚举

可达性分析算法中从GC Roots集合中寻找引用链这个操作作为示例.固定可以作为GC Roots的节点主要在全局性引用中(常量/静态属性)与执行上下文(栈帧中的本地变量表)中,尽管目标明确,但是查找的高效性是一个问题.按照现在java应用的大小,方法区的大小通常就有上百上千兆,想要查找的时间复杂度相当高.

收集器从根节点枚举步骤时,都必须暂停用户线程(需要更多的系统资源执行计算).可达性分析算法已经可以和用于线程并发执行,但是根节点枚举还是必须保证一致性快照中才能执行(执行过程中引用关系不会发生变化,做不到这一点,分析结果无法保证正确性,这就是垃圾收集过程中必须停止用于线程的原因).即使是CMS,G1,ZGC这样的收集器也是需要在枚举根节点的时候停顿.

目前虚拟机中使用准确式垃圾收集器,所以当用于线程停顿下来之后,并不需要检查完所有执行上下文和全局变量的引用位置,虚拟机应当直接获得哪些地方存放着对象引用的.

一旦类加载动作完成的时候,虚拟机就会把对象内什么偏移量位置上的类型数据计算处理,即时编译中也会在特定位置记录栈中和寄存器中哪些位置是引用的信息记录起来.并不是需要从GC Roots查找.

下面是虚拟机客户端模式下,生成的一段String::hashCode()本地代码,可以看到0x026eb7a9 地址上call指令有OopMap记录.指明了EBX寄存器和栈中偏移量为16的内存区域,有宇哥普通对象直至的引用.有效范围为0x026eb730 +142(OopMap记录偏移量)-> 0x026eb7be 

```assembly
[Verified Entry Point]
0x026eb730: mov %eax,-0x8000(%esp)
…………
;; ImplicitNullCheckStub slow case
# 起始地址,寄存器ebx装载Oop,栈内偏移量16.记录偏移量142,结束地址0x026eb7a9+142
0x026eb7a9: call 0x026e83e0 ; OopMap{ebx=Oop [16]=Oop off=142}
; *caload
; - java.lang.String::hashCode@48 (line 1489)
; {runtime_call}
0x026eb7ae: push $0x83c5c18 ; {external_word}
0x026eb7b3: call 0x026eb7b8
0x026eb7b8: pusha
0x026eb7b9: call 0x0822bec0 ; {runtime_call}
0x026eb7be: hlt
```

##### 安全点

在OopMap的协助下,可以快速的完成GC Roots的枚举,但是可能导致引用关系的编号,或者说OopMap内容编号的指令非常多,但是每条指令都会生成对应的OopMap,会查产生大量的额外存储空间.

> 实际上OopMap没有为每条指令生成OopMap,指示在特定位置会生成,这些位置称作**安全点.**有了这个安全点,用于程序执行的时候并非在代码执行流的任意位置都能够执行垃圾收集.而是强制到安全点位置才能进行暂停.
>
> 安全点的选择既不能太少，会导致收集器等待时间过程，也不能过于频繁，这样会增大内存负荷。选择标准是**是否具有让程序长时间执行的特征**。因为每条指令的时间都是非常短暂的，但是不能使用指令流长度定义这个，长时间执行明显特征就是指令的复用，例如**方法调用**，**循环跳转**，**异常跳转**等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。

对于安全点，需要考虑的另一个问题是，如何在垃圾收集发生的时候让所有线程都到安全点，然后停顿下来，有两种方案：

1. 抢先式中断

   不需要线程的执行代码主动配合，在垃圾收集发生的时候，系统首先将用户线程全部中断，如果发现用户线程不在安全点上则恢复线程，过一会重新中断，直到运行到安全点上.(几乎没有虚拟机采样抢先式中断暂停线程响应GC事件)

2. 主动式中断

   >  垃圾收集器需要中断线程的时候,不直接对线程操作,仅仅设置一个标志位.
   >
   > 各个线程会不停地去轮询这个表示,一旦返现中断标志为真的时候,就在自己最近的安全点主动中断挂起.
   >
   > 轮询标志的位置和安全点是重合的.
   >
   > 另外还要加上所有创建对象和其他需要java堆上分配内存的地方作为安全点.这是为了检查是否即将发生垃圾回收,避免没有足够内存分配新对象的情况.

由于轮询操作在代码中会经常的出现,必须满足高效性,HotSpot使用内存保护陷阱的方式,使用一条汇编指令精简轮询操作.

```assembly
0x01b6d627: call 0x01b2b210 ; OopMap{[60]=Oop off=460}
; *invokeinterface size
; - Client1::main@113 (line 23)
; {virtual_call}
0x01b6d62c: nop ; OopMap{[60]=Oop off=461}
; *if_icmplt
; - Client1::main@118 (line 23)
# 将0x160100内存页设置为不可读,当执行测试指令是就会产生一个自陷移除信号,探后在预设的异常处理器中挂起,等待线程实现等待.这样就触发了安全的轮询和触发线程中断
0x01b6d62d: test %eax,0x160100 ; {poll}
0x01b6d633: mov 0x50(%esp),%esi
0x01b6d637: cmp %eax,%esi
```

##### 安全区域

安全点机制保证了程序的执行,在不太长的时间遇到垃圾收集过程的安全点,在程序不执行的时候,这些线程无法响应虚拟机的中断请求,不能到安全的地方将自己挂起,虚拟机也不可能持续等待线程重新被激活分配处理器时间.对于这种情况,需要引入**安全区域**的概念.

**安全区域**是值能够确保在一定代码片段中,引用关系不发生变化,因此在任务地方开始垃圾回收都是安全的.可以将安全区域视作安全点的扩展.

> 置于在非安全区域回收内存空间会发生什么 --> 可能会造成悬空访问的情况,且指向的引用已经被回收.

当用户线程进入到安全区域内部执行代码的时候,首先标识自己进入了安全区域,那样当这段时间内虚拟机发起垃圾回收的时候,就不需要声明自己处于安全区域内的线程了.

当线程离开安全区域的时候,需要检查虚拟机是否完成了根节点的枚举.如果完成了,线程就继续执行,否则就需要等待到可以离开安全区域的信号位置.

##### 记忆集与卡表

为了解决对象跨代引用的问题,垃圾收集器在新生代中建立了**记忆集**(Remembered Set)的数据结构,用于避免把整个老年代加入GC Roots的扫描范围.

事实上,不仅仅新生代和老年代会发生跨代引用的问题.所有涉及部分GC的垃圾收集器都会面临这个问题.所以需要明白记忆集的原理和实现方式.

> **记忆集**: 一种弄用于记录从非收集区指向收集区域的指针集合的抽象数据结构.
>
> 不考虑效率和成本的情况下,
>
> 最简单的实现可以使用非收集区域中所含有的跨代引用的对象数组来实现这个数据结构
>
> ```java
> class RemerberSet{
>  Object[] set[OBJECT_RERERENCE_GENETATION_CROSS_SIZE]; 
> }
> ```
>
> 这种记录全部汉跨点引用对象的实现,空间使用了和维护成本都非常的高.在垃圾收集器的场景中,收集器通过记忆集判断出一块非收集区域是否存在指向收集区域指针就行了.不需要指明跨代指针的全部细节.
>
> 可以设置下述的记录精度:
>
> + 字长精度 : 每个记录精确到一个机器字长,包含了跨代指针
> + 对象精度: 每个记录精确到一个对象,对象中包含跨代指针
> + 卡精度" 紧缺的一个内存区域,包含跨代指针
>
> 其中卡精度称作**卡表**,用于实现**记忆集**.也是目前常用的记忆集实现方式.
>
> 最简单得,可以将卡表视作字节数组,HotSpot虚拟机也是这么做的:
>
> ```shell
> CARD_TABLE {this address>>9} = 0
> ```
>
> 字节数组CARD_TABLE每一个元素对应着标识的内存区域一块特定大小的内存块，这个内存块被称作**卡页**。一般来说，卡页的大小为2的n次方。上述代码表示的是一个512字节的内存空间。如果内存起始地址为0x0000的话，数组CARD_TABLE的第0,1,2号元素分别对应内存范围：
>
> 0x0000-0x01FF，0x0200-0x03DD，0x0400-0x05FF的内存区域。

##### 写屏障

上面已经使用记忆集缩减GC Roots扫描范围的问题，但是还是没有解决卡表如何维护的问题.

例如,它们何时变脏,什么使之变脏.

变脏条件很明确-其他分代区域中对象引用本区域对象是,对于卡表元素变脏.

##### 并发的可达性分析

#### 经典的垃圾收集器

##### Serial收集器

##### ParNew收集器

##### Parallel Scavenge收集器

##### Serial Old收集器

##### Parallel Old 收集器

##### CMS收集器

##### Garbage First收集器



#### 低延迟垃圾收集器

##### Shenandoah收集器

##### ZGC收集器



#### 垃圾收集器的选择

##### Eplilon收集器

##### 收集器的权衡

##### 虚拟机以及垃圾收集器日志

##### 垃圾收集器参数总结



#### 内存分配与回收策略

##### 对象优先在Eden分配

##### 大对象直接进入老年代

##### 长期存活的对象进入老年代

##### 动态对象年龄判定

##### 空间分配担保