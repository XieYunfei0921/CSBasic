#### **设备管理**

---

1.  [IO系统](# IO系统)
2.  [IO控制方式](# IO控制方式)
3.  [缓冲管理](# 缓冲管理)
4.  [设备分配](# 设备分配)
5.  [设备处理](# 设备处理)
6.  [磁盘存储器管理](# 磁盘存储器管理)

---

#### IO系统

+  IO设备

  1. IO设备类型

     + 按照传输速率分类

       按照传输速度的高低，将IO设备分为3类

       1.  低速设备

          键盘，鼠标，语音输入输出设备

       2.  中速设备(1000KB+ --> 10000KB+)

          行式打印机,激光打印机

       3.  高速设备(100KB+ --> 10MB+ )

          磁带机，磁盘机，光盘机

     + 按照信息交换单位分类

       1.  块设备

          信息存储以数据块为单位，典型块设备是磁盘。每个盘块大小512B - 4KB。特征是传输速率高，通常每秒钟为几兆位。另一特征为可寻址，即可对其进行随机读写。

       2.  字符设备

          用于数据的输入输出，基本单位为字符，故称作字符设备

     + 按照设备共享属性分类

       1.  独占设备
       2.  共享设备
       3.  虚拟设备

  2. 设备与控制器之间的接口

     <img src="E:\截图文件\设备与控制器之间的接口.png" style="zoom:67%;" />

+  设备控制器

  1.  设备控制器的基本功能

     +  接收和识别命令
     +  数据交换
     +  标识和报告设备状态
     +  地址识别
     +  数据缓冲
     +  差错控制

  2.  设备控制器的组成

     <img src="E:\截图文件\设备控制器组成.png" style="zoom:67%;" />

   数据寄存器，控制/状态寄存器，IO逻辑，控制器与设备接口

+ IO通道 

  1.  IO通道的引入

     实际上，IO通道是一种特殊的处理机。具有执行IO指令的能力,并通过执行通道IO程序来控制IO操作。但是IO通道与一般处理机不同的如下:

     +  指令类型单一，主要局限于IO操作有关的指令
     +  通道没有自己的内存，通道所指向的通道程序是放在内存中的，换言之，通道与CPU共享内存

  2.  通道类型

     +  字节多路通道

       <img src="E:\截图文件\字节多路通道.png" style="zoom:67%;" />
     
     + 数组选择通道(Block Selector Channel)
     
       字节多路通道不适应于连接高速设备，这推动了数组方式进行数据传送的**数组选择通道**的形成。这种通道虽然可以连接多台高速设备，由于只含有一个分配子通道，在一段时间内只能执行一个通道程序，控制数据传送，致使某一台设备占用之后便由其独占,即使没有数据传送也不会让出通道，这种通道利用率较低。
     
     +  数组多路通道
     
       数组多路通道时间数组选择通道传输速率高和字节多路通道中子设备可以并行传输的优点相结合的处理方案。因而这种通道既具有很高的数据传输速率，又能获得令人满意的通道利用率。也正因此，才使该通道能被广泛地用于连接多台高、中速的外围设备，其数据传送是按数组方式进行的。
     
  3.   单通路IO系统瓶颈问题
  
      一个控制器只收到一个通道的数据
  
      <img src="E:\截图文件\单通道IO.png" style="zoom:67%;" />
      
      采用多通道IO系统，控制器可以获取多个通道的数据来源
      
      <img src="E:\截图文件\多通道IO.png" style="zoom:67%;" />
  
  4.  总线系统
  
     + 总线型IO系统结构
  
       1. ISA和EISA总线
  
          +  ISA总线
  
            总线的带宽为8位，最高传输速率为2 Mb/s
  
          +  EISA总线
  
            带宽为32位，总线的传输速率高达32 Mb/s，同样可以连接12台外部设备
  
       2.  局部总线
  
          +  VESA总线
          +  PCI总线

#### IO控制方式

+ 程序IO方式

  程序IO方式中，由于CPU高速性和IO设备的低速性，使得CPU大部分时间处于等待IO设备完成数据IO的循环测试，造成CPU极大浪费。该方式中，CPU之所以要不断的测试IO设备状态，是因为CPU中无中断机构,使得IO设备无法向CPU报告已经完成一个字符的输入操作。

+ 中断驱动IO控制方式

  I/O设备输入每个数据的过程中，由于无须CPU干预，因而可使CPU与I/O设备并行工作。**仅当输完一个数据时，才需CPU花费极短的时间去做些中断处理**。可见，这样可使CPU和I/O设备都处于忙碌状态，从而提高了整个系统的资源利用率及吞吐量。

+ 直接存储器访问DMA IO控制方式

  1.  DMA控制方式引入

     该方式有如下特点

     +  数据传输基本单位为数据块，即CPU与IO设备之间，每次至少传送一个数据块
     +  所传送的数据时长设备直接送入到内存，或者反向
     +  仅仅在传送数据块开始和结束时，才需要CPU参与，这个数据块传送时再控制器控制的情况下完成。

     综上，DMA方式比较与中断驱动方式，又减少了CPU对IO的干预,进一步提高CPU与IO设备的并行操作程度。

  2.  DMA控制器组成

     <img src="E:\截图文件\DMA控制器结构.png" style="zoom:67%;" />

  为了实现主机与控制器之间块数据的直接交换，必须在DMA控制器中设置下述寄存器:

  +  命令/状态寄存器	用于接受CPU发送来的IO命令或有关控制信息(或设备状态)

  +  内存地址寄存器MAR  

    输入时，存放把数据从设备传送到起始目标地址，输出时，存放设备的内存源地址

  +  数据寄存器DR

    暂存设备到内存，或者内存到设备的数据

  +  数据计数器DC

    存放CPU要读取或写出的字节数

  3.  DMA控制流程

     <img src="E:\截图文件\DMA控制流程.png" style="zoom:67%;" />

+ IO通道控制方式

  1.  IO通道控制方式的引入

     IO通道方式时DMA方式的发展,可以进一步的减少CPU干预，即对一个数据块读写的干预，减少一组数据块读写及有关控制和管理范围干预。同时又可以实现CPU,通道和IO设备三者的并行操作,从而更有效的提高整个系统的资源利用率。

     例如，当CPU要完成一组相关的读(或写)操作及有关控制时，只需向I/O通道发送一条I/O指令，以给出其所要执行的通道程序的首址和要访问的I/O设备，通道接到该指令后，通过执行通道程序便可完成CPU指定的I/O任务。 

  2.  通道程序

     +  操作码
     +  内存地址
     +  计数
     +  通道程序结束位P
     +  记录结束标志R

#### 缓冲管理

+ 缓冲的引入

  主要解决的问题

  +  缓和CPU与IO设备速度不匹配的矛盾
  +  减少CPU中断频率，放宽CPU中断响应时间的限制
  +  提高CPU与IO设备并行性

  利用缓冲寄存器实现缓冲

  <img src="E:\截图文件\利用缓冲寄存器进行缓冲.png" style="zoom:67%;" />

+ 单缓冲和双缓冲

  1.  单缓冲

     工作示意图:

     <img src="E:\截图文件\单缓冲工作示意图.png" style="zoom:67%;" />

  2.  双缓冲

     工作示意图

     <img src="E:\截图文件\双缓冲示意图.png" style="zoom:67%;" />
     
     + 双机通信时缓冲区的设置
     
       <img src="E:\截图文件\双机缓冲区设置.png" style="zoom:67%;" />

  3. 循环缓冲

     + 循环缓冲的组成

       <img src="E:\截图文件\循环缓冲器示意图.png" style="zoom:67%;" />

     + 循环缓冲的使用

       1.  Getbuff过程
       2.  Releasebuff过程

     + 进程同步

       1.  Nexti指针追赶上Nextg指针
       2.  Nextg指针追赶上Nexti指针

  4.  缓冲池

     + 缓冲池组成
     
       既可以用于输入，也可以用于输出的公用缓冲池，其中至少需要包含如下三类:
     
       1.  空缓冲区
       2.  满输入缓冲区
       3.  满输出缓冲区
     
       为了方便管理，设置如下三个队列:
     
       1.  空缓冲队列
       2.  输入队列
       3.  输出队列
     
     + Getbuf过程和Putbuf过程
     
       ```markdown
       // 使用读写者模型解决读写缓冲区的线程同步问题
       Procedure Getbuff(type)
       	begin
       		Wait(RS(type))
       		Wait(MS(type))
       		// 获取缓冲数据
       		B(number)∶[KG-*3]=Takebuf(type)
       		Signal(MS(type))
       	end
       Procedure Putbuf(type,number)
       	begin
       		Wait(MS(type))
       		// 添加数据到缓冲
       		Addbuf(type,number)
       		Signal(MS(type))
       		Signal(RS(type))
       	end
       ```
     
       
     
     + 缓冲池工作方式
     
       <img src="E:\截图文件\缓冲区工作方式.png" style="zoom:67%;" />

#### 设备分配

+ 设备分配中的数据结构

  1.  设备空值表DCT

     <img src="E:\截图文件\设备控制表模型.png" style="zoom:67%;" />
  
  2.  控制器控制表COCT,通道控制表CHCT和系统设备表SDT
  
     <img src="E:\截图文件\其他类型控制表.png" style="zoom:67%;" />
  
+ 设备分配时需要考虑的因素

  1.  设备固有属性
     +  独享设备
     + 共享设备
     + 虚拟设备
  2.  设备分配算法
     +  先来先服务
     +  优先级高优先
  3.  设备分配中的安全性
     +  安全分配方式
     +  不安全分配方式

+ 设备独立性

  1.  设备独立性概念
     应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了**逻辑设备**和**物理设备**这两个概念。在应用程序中，使用**逻辑设备名称**来请求使用某类设备；而系统在实际执行时，
     还必须使用**物理设备名称**。因此，系统须具有将逻辑设备名称转换为某物理设备名称的功能，这非常类似于存储器管理中所介绍的逻辑地址和物理地址的概念。

  2.  设备独立性软件

     +  对独立设备的分配与回收
     +  将逻辑设备名映射为物理设备名，进一步找到物理设备驱动程序
     +  对设备进行保护，禁止用户直接访问设备
     +  缓冲管理，即对字符设备和块设备的缓冲区进行有效的管理， 以提高I/O的效率
     +  差错控制

     由于在I/O操作中的绝大多数错误都与设备无关，故主要由设备驱动程序处理，而设备独立性软件只处理那些设备驱动程序无法处理的错误。

+ 独占设备的分配程序

  1. 基本设备分配程序
     +  分配设备
     +  分配控制器
     +  分配通道
  2.  设备分配程序中的改进
     +  增加设备独立性
     +  考虑多通路情况

+ SPOOLing 技术

#### 设备处理

+  设备驱动程序功能和特点
+  设备驱动程序的处理过程 

#### 磁盘存储器管理

+  磁盘性能简述
+  磁盘调度
+  磁盘高速缓存
+  提高IO速度的其他方法