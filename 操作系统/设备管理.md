#### **设备管理**

---

1.  [IO系统](# IO系统)
2.  [IO控制方式](# IO控制方式)
3.  [缓冲管理](# 缓冲管理)
4.  [设备分配](# 设备分配)
5.  [设备处理](# 设备处理)
6.  [磁盘存储器管理](# 磁盘存储器管理)

---

#### IO系统

+  IO设备

  1. IO设备类型

     + 按照传输速率分类

       按照传输速度的高低，将IO设备分为3类

       1.  低速设备

          键盘，鼠标，语音输入输出设备

       2.  中速设备(1000KB+ --> 10000KB+)

          行式打印机,激光打印机

       3.  高速设备(100KB+ --> 10MB+ )

          磁带机，磁盘机，光盘机

     + 按照信息交换单位分类

       1.  块设备

          信息存储以数据块为单位，典型块设备是磁盘。每个盘块大小512B - 4KB。特征是传输速率高，通常每秒钟为几兆位。另一特征为可寻址，即可对其进行随机读写。

       2.  字符设备

          用于数据的输入输出，基本单位为字符，故称作字符设备

     + 按照设备共享属性分类

       1.  独占设备
       2.  共享设备
       3.  虚拟设备

  2. 设备与控制器之间的接口

     <img src="E:\截图文件\设备与控制器之间的接口.png" style="zoom:67%;" />

+  设备控制器

  1.  设备控制器的基本功能

     +  接收和识别命令
     +  数据交换
     +  标识和报告设备状态
     +  地址识别
     +  数据缓冲
     +  差错控制

  2.  设备控制器的组成

     <img src="E:\截图文件\设备控制器组成.png" style="zoom:67%;" />

   数据寄存器，控制/状态寄存器，IO逻辑，控制器与设备接口

+ IO通道 

  1.  IO通道的引入

     实际上，IO通道是一种特殊的处理机。具有执行IO指令的能力,并通过执行通道IO程序来控制IO操作。但是IO通道与一般处理机不同的如下:

     +  指令类型单一，主要局限于IO操作有关的指令
     +  通道没有自己的内存，通道所指向的通道程序是放在内存中的，换言之，通道与CPU共享内存

  2.  通道类型

     +  字节多路通道

       <img src="E:\截图文件\字节多路通道.png" style="zoom:67%;" />
     
     + 数组选择通道(Block Selector Channel)
     
       字节多路通道不适应于连接高速设备，这推动了数组方式进行数据传送的**数组选择通道**的形成。这种通道虽然可以连接多台高速设备，由于只含有一个分配子通道，在一段时间内只能执行一个通道程序，控制数据传送，致使某一台设备占用之后便由其独占,即使没有数据传送也不会让出通道，这种通道利用率较低。
     
     +  数组多路通道
     
       数组多路通道时间数组选择通道传输速率高和字节多路通道中子设备可以并行传输的优点相结合的处理方案。因而这种通道既具有很高的数据传输速率，又能获得令人满意的通道利用率。也正因此，才使该通道能被广泛地用于连接多台高、中速的外围设备，其数据传送是按数组方式进行的。
     
  3.   单通路IO系统瓶颈问题
  
      一个控制器只收到一个通道的数据
  
      <img src="E:\截图文件\单通道IO.png" style="zoom:67%;" />
      
      采用多通道IO系统，控制器可以获取多个通道的数据来源
      
      <img src="E:\截图文件\多通道IO.png" style="zoom:67%;" />
  
  4.  总线系统
  
     + 总线型IO系统结构
  
       1. ISA和EISA总线
  
          +  ISA总线
  
            总线的带宽为8位，最高传输速率为2 Mb/s
  
          +  EISA总线
  
            带宽为32位，总线的传输速率高达32 Mb/s，同样可以连接12台外部设备
  
       2.  局部总线
  
          +  VESA总线
          +  PCI总线

#### IO控制方式

+ 程序IO方式

  程序IO方式中，由于CPU高速性和IO设备的低速性，使得CPU大部分时间处于等待IO设备完成数据IO的循环测试，造成CPU极大浪费。该方式中，CPU之所以要不断的测试IO设备状态，是因为CPU中无中断机构,使得IO设备无法向CPU报告已经完成一个字符的输入操作。

+ 中断驱动IO控制方式

  I/O设备输入每个数据的过程中，由于无须CPU干预，因而可使CPU与I/O设备并行工作。**仅当输完一个数据时，才需CPU花费极短的时间去做些中断处理**。可见，这样可使CPU和I/O设备都处于忙碌状态，从而提高了整个系统的资源利用率及吞吐量。

+ 直接存储器访问DMA IO控制方式

  1.  DMA控制方式引入

     该方式有如下特点

     +  数据传输基本单位为数据块，即CPU与IO设备之间，每次至少传送一个数据块
     +  所传送的数据时长设备直接送入到内存，或者反向
     +  仅仅在传送数据块开始和结束时，才需要CPU参与，这个数据块传送时再控制器控制的情况下完成。

     综上，DMA方式比较与中断驱动方式，又减少了CPU对IO的干预,进一步提高CPU与IO设备的并行操作程度。

  2.  DMA控制器组成

     <img src="E:\截图文件\DMA控制器结构.png" style="zoom:67%;" />

  为了实现主机与控制器之间块数据的直接交换，必须在DMA控制器中设置下述寄存器:

  +  命令/状态寄存器	用于接受CPU发送来的IO命令或有关控制信息(或设备状态)

  +  内存地址寄存器MAR  

    输入时，存放把数据从设备传送到起始目标地址，输出时，存放设备的内存源地址

  +  数据寄存器DR

    暂存设备到内存，或者内存到设备的数据

  +  数据计数器DC

    存放CPU要读取或写出的字节数

  3.  DMA控制流程

     <img src="E:\截图文件\DMA控制流程.png" style="zoom:67%;" />

+ IO通道控制方式

  1.  IO通道控制方式的引入

     IO通道方式时DMA方式的发展,可以进一步的减少CPU干预，即对一个数据块读写的干预，减少一组数据块读写及有关控制和管理范围干预。同时又可以实现CPU,通道和IO设备三者的并行操作,从而更有效的提高整个系统的资源利用率。

     例如，当CPU要完成一组相关的读(或写)操作及有关控制时，只需向I/O通道发送一条I/O指令，以给出其所要执行的通道程序的首址和要访问的I/O设备，通道接到该指令后，通过执行通道程序便可完成CPU指定的I/O任务。 

  2.  通道程序

     +  操作码
     +  内存地址
     +  计数
     +  通道程序结束位P
     +  记录结束标志R

#### 缓冲管理

+ 缓冲的引入

  主要解决的问题

  +  缓和CPU与IO设备速度不匹配的矛盾
  +  减少CPU中断频率，放宽CPU中断响应时间的限制
  +  提高CPU与IO设备并行性

  利用缓冲寄存器实现缓冲

  <img src="E:\截图文件\利用缓冲寄存器进行缓冲.png" style="zoom:67%;" />

+ 单缓冲和双缓冲

  1.  单缓冲

     工作示意图:

     <img src="E:\截图文件\单缓冲工作示意图.png" style="zoom:67%;" />

  2.  双缓冲

     工作示意图

     <img src="E:\截图文件\双缓冲示意图.png" style="zoom:67%;" />
     
     + 双机通信时缓冲区的设置
     
       <img src="E:\截图文件\双机缓冲区设置.png" style="zoom:67%;" />

  3. 循环缓冲

     + 循环缓冲的组成

       <img src="E:\截图文件\循环缓冲器示意图.png" style="zoom:67%;" />

     + 循环缓冲的使用

       1.  Getbuff过程
       2.  Releasebuff过程

     + 进程同步

       1.  Nexti指针追赶上Nextg指针
       2.  Nextg指针追赶上Nexti指针

  4.  缓冲池

     + 缓冲池组成
     
       既可以用于输入，也可以用于输出的公用缓冲池，其中至少需要包含如下三类:
     
       1.  空缓冲区
       2.  满输入缓冲区
       3.  满输出缓冲区
     
       为了方便管理，设置如下三个队列:
     
       1.  空缓冲队列
       2.  输入队列
       3.  输出队列
     
     + Getbuf过程和Putbuf过程
     
       ```markdown
       // 使用读写者模型解决读写缓冲区的线程同步问题
       Procedure Getbuff(type)
       	begin
       		Wait(RS(type))
       		Wait(MS(type))
       		// 获取缓冲数据
       		B(number)∶[KG-*3]=Takebuf(type)
       		Signal(MS(type))
       	end
       Procedure Putbuf(type,number)
       	begin
       		Wait(MS(type))
       		// 添加数据到缓冲
       		Addbuf(type,number)
       		Signal(MS(type))
       		Signal(RS(type))
       	end
       ```
     
       
     
     + 缓冲池工作方式
     
       <img src="E:\截图文件\缓冲区工作方式.png" style="zoom:67%;" />

#### 设备分配

+ 设备分配中的数据结构

  1.  设备空值表DCT

     <img src="E:\截图文件\设备控制表模型.png" style="zoom:67%;" />
  
  2.  控制器控制表COCT,通道控制表CHCT和系统设备表SDT
  
     <img src="E:\截图文件\其他类型控制表.png" style="zoom:67%;" />
  
+ 设备分配时需要考虑的因素

  1.  设备固有属性
     +  独享设备
     + 共享设备
     + 虚拟设备
  2.  设备分配算法
     +  先来先服务
     +  优先级高优先
  3.  设备分配中的安全性
     +  安全分配方式
     +  不安全分配方式

+ 设备独立性

  1.  设备独立性概念
     应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了**逻辑设备**和**物理设备**这两个概念。在应用程序中，使用**逻辑设备名称**来请求使用某类设备；而系统在实际执行时，
     还必须使用**物理设备名称**。因此，系统须具有将逻辑设备名称转换为某物理设备名称的功能，这非常类似于存储器管理中所介绍的逻辑地址和物理地址的概念。

  2.  设备独立性软件

     +  对独立设备的分配与回收
     +  将逻辑设备名映射为物理设备名，进一步找到物理设备驱动程序
     +  对设备进行保护，禁止用户直接访问设备
     +  缓冲管理，即对字符设备和块设备的缓冲区进行有效的管理， 以提高I/O的效率
     +  差错控制

     由于在I/O操作中的绝大多数错误都与设备无关，故主要由设备驱动程序处理，而设备独立性软件只处理那些设备驱动程序无法处理的错误。

+ 独占设备的分配程序

  1. 基本设备分配程序
     +  分配设备
     +  分配控制器
     +  分配通道
  2.  设备分配程序中的改进
     +  增加设备独立性
     +  考虑多通路情况

+ SPOOLing 技术

  1.  SPOOLing 技术

     为了缓和CPU高速性和IO设备低速性的矛盾,引入了**脱机输入,脱机输出技术**.该技术时利用**专门外围控制机**,将低速IO设备上数据传送到告诉磁盘上(或者相反的传输方向).

     事实上,系统引入多道程序技术后,完全可以利用其中一道程序,来模拟脱机输入的外围控制机内容.把低速IO设备上的数据传送到高速磁盘上,再利用另一道程序来模拟脱机输出时外围控制器的功能.把数据从磁盘传送到低速输出设备上.这样便可以再主机的直接控制下,实现脱机输入输出.

     此时外围操作与CPU对数据处理同时进行,这种联机情况下实现同时外围操作称为SPOOLing,或称作**伪脱机操作**.

  2.  SPOOLing 系统组成

     <img src="E:\截图文件\SPooling技术.png" style="zoom:67%;" />

  3.  共享打印机

      共享打印机技术已经广泛的用于**多用户系统**和**局域网络**.当用户进程请求打印输出时,SPOOLing系统同意为它打印输出,但并不真正的把打印机分配给该用户进程,而只进行如下操作:

     +  由输出进程再输出井中为之申请一个空闲磁盘块区,并将要打印的数据送入其中.
     +  输出进程再为用户进程申请一张空白的用户请求打印表,并将用户打印要求填入其中.将该表挂到请求打印队列上.

  4.  SPOOLing 系统的特点

     +  提高IO速度
     +  将独占设备改造为共享设备
     +  实现了虚拟设备功能

#### 设备处理

+ 设备驱动程序功能和特点

  1.  设备驱动程序功能
     +  接受IO进程发来的命令和参数,并将命令中的抽象要求 转换为 具体要求.例如,将磁盘块号 转换为 磁盘盘面,磁道号及扇区号.
     +  检查用户IO请求合法性,了解IO设备状态,传递有关参数,设置设备工作方式.
     +  发出IO命令,如果设备空闲,便立即启动IO设备去完全IO操作.如果处于忙碌状态, 则将请求者的请求块 挂再设备队列上等待.
     +  及时响应由控制器或通道发来的中断请求,并根据中断类型调用相应中断处理程序进行处理.
     +  对于设置由通道的计算机系统,驱动程序 还应当能够 根据用户的IO请求,自动构成 通道程序.
  2.  设备处理方式
     +  为每一类设备设置一个进程,专门用于执行这个设备IO操作.
     +  再整个系统中设置一个IO进程,专门用于执行系统1中所有各类设备的IO操作.
     +  不设置专门的 设备处理程序, 而只为 各类设备设置相应的设备处理程序(模块) .供用户进程或者系统进程调用.
  3.  设备驱动程序特点
     +  驱动程序主要指在请求IO进程与设备控制器之间的一个通信和转换程序.
     +  驱动程序和设备控制器和IO设备的硬件特性紧密相关,因而对不同类型的设备应配置不同
     +  驱动程序 与 IO设备所采用的IO空值方式紧密相关.
     +  用于驱动程序 与 硬件紧密相关, 因而其中一部分必须使用汇编语言书写.

+ 设备驱动程序的处理过程

  1.  将抽象要求 转换为 具体要求
  2.  检查IO请求的合法性
  3.  读出和检查设备的状态
  4.  传送必要的参数
  5.  工作方式设置
  6.  启动IO设备

  中断现场保护示意图:

  <img src="E:\截图文件\中断保护现场.png" style="zoom:67%;" />

  中断处理流程

  <img src="E:\截图文件\中断处理流程.png" style="zoom:67%;" />

#### 磁盘存储器管理

+ 磁盘性能简述

  1.  数据组织和格式

     <img src="E:\截图文件\数据组织格式.png" style="zoom:67%;" />

  2.  磁盘类型

     +  固定头磁盘

        这种磁盘在每条磁道上都有一读/写磁头，所有的磁头都被装在一刚性磁臂中。通过这些磁头可访问所有各磁道，并进行并行读/写，有效地提高了磁盘的I/O速度。
       这种结构的磁盘主要用于大容量磁盘上。

     +  移动头磁盘

       每一个盘面仅配有一个磁头，也被装入磁臂中。为能访问该盘面上的所有磁道，该磁头必须能移动以进行寻道。可见，移动磁头仅能以串行方式读/写，致使其I/O速度较慢；但由于其结构简单，故仍广泛应用于中小型磁盘设备中。 

  3.  磁盘访问时间

     +  寻道时间

       ​	指把磁臂(磁头)移动到指定磁道上所经历的时间

       ​	时间是启动磁臂的时间s与磁头移动*n*条磁道所花费的时间之和，即

       ​	Ts= m * n +s

     +  旋转延迟时间

       这是指定扇区移动到磁头下面所经历的时间。

       对于硬盘平均旋转延迟时间*T*τ为5.55 ms

       对于软盘平均Tτ为50~100 ms

     +  传输时间

       这是指把数据从磁盘读出或向磁盘写入数据所经历的时间。 *T**t*的大小与每次所读/写的字节数*b*和旋转速度有关：

       ​	Tt = b / r * N

+ 磁盘调度

  1.  先来先服务 FCFS

     <img src="E:\截图文件\FCFS磁盘调度.png" style="zoom:67%;" />

  2.  最短寻道时间优先 SSTF

     <img src="E:\截图文件\SSTF.png" style="zoom:67%;" />

  3.  扫描(SCAN)算法

     SSTF 算法虽然获取了较好的寻道性能，可能导致某个进程**饥饿现象**。因为只要不断有新进程请求到达，且磁道与磁头当前所在磁道距离较近。这种新进程IO请求必须优先满足，对SSTF算法略加修改后形成SCAN算法，即可方式老进程出现饥饿现象。(不执行)

     <img src="E:\截图文件\SCAN算法.png" style="zoom:67%;" />

  4. 循环扫描(CSCAN)算法

     <img src="E:\截图文件\循环扫描.png" style="zoom:67%;" />

  5.  N-Step-SCAN算法

     N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列。

     而每处理一个队列时又是按SCAN算法，对一个队列处理完后，再处理其他队列。

     当正在处理某子队列时，如果又出现新的磁盘I/O请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。

     当N值取得很大时，会使N步扫描法的性能接近于SCAN算法的性能；当N=1时， N步SCAN算法便蜕化为FCFS算法。 

  6.  FSCAN算法

     FSCAN算法实际上是N步SCAN算法的简化，即当FSCAN只将磁盘请求队列分成两个子队列。

     一个是由当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理。

     在扫描期间，将新出现的所有请求磁盘I/O的进程，放入另一个等待处理的请求队列。

     这样，所有的新请求都将被推迟到下一次扫描时处理。

+ 磁盘高速缓存

  1.  磁盘高速缓存形式

     利用内存存储空间，来暂存从磁盘中读出一系列盘块中信息。因此，高速缓存时一组逻辑上属于磁盘，而物理上是驻留在内存中的盘块。可以分为两种形式:

     +  在内存中开辟一个单独存储空间作为磁盘高速缓存，大小固定，不会受到应用程序多少的影响。
     +  把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘IO共享。

     此时高速缓存大小，显然不再是固定的，当磁盘IO频率较高，缓冲池可能包括更多的内存空间。当应用程序运行较多时，缓冲池可能只剩下较少的内存空间。

  2.  数据交付方式

     +  数据交付

       直接将高速缓存中数据，传送到请求者进程的内存工作区中。

     +  指针交付

       只将高速缓存中某个区域指针，交付给请求者进程。

     后一种需要传送数据量少，剑圣了数据藏磁盘高速缓存存储空间到内存工作区的时间。

  3.  置换算法

     由于请求调页中的联想存储器和高速缓存工作情况不同，使得在置换算法中考虑问题有所差异。因此，现在不少系统在设计其高速缓存的置换算法时，除了考虑到最近最久未使用这一原则外，还考虑了以下几点：

     +  访问频率
     +  可预见性
     +  数据一致性

  4.  周期性地写回磁盘

     在UNIX系统中专门增设了一个修改(update)程序，使之在后台运行，该程序周期性地调用一个系统调用SYNC。该调用的主要功能是强制性地将所有在高速缓存中已修改的盘块数据写回磁盘。

     一般是把两次调用SYNC的时间间隔定为30 s。这样，因系统故障所造成的工作损失不会超过30 s的劳动量。

     只要高速缓存中的某盘块数据被修改，便立即将它写回磁盘，并将这种高速缓存称为“写穿透、高速缓存”(write-through cache)。MS-DOS所采用的写回方式，几乎不会造成数据的丢失，但须频繁地启动磁盘。 

+ 提高IO速度的其他方法

  1.  提前读取(Read-Ahead)
  2.  延迟写
  3.  优化物理块分布
  4.  虚拟盘

+   廉价磁盘冗余阵列

   1.  并行交叉存取

      <img src="E:\截图文件\磁盘并行交叉存取.png" style="zoom:67%;" />

   2.  RAID分级

      +  RAID 0级
      +  RAID 1级
      +  RAID 3级
      +  RAID 5级
      +  RAID 6级和RAID 7级

   3.  RAID 优点

      +  可靠性高
      +  磁盘IO速度高
      +  性价比高