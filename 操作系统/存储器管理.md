#### **存储器管理**

---

1.  [程序的装入与链接](#  程序的装入与链接)
2.  [连续分配方式](# 连续分配方式)
3.  [基本分页存储管理方式](# 基本分页存储管理方式)
4.  [基本分段存储管理方式](# 基本分段存储管理方式)
5.  [虚拟存储器基本概念](# 虚拟存储器基本概念)
6. [请求分页存储管理方式](# 请求分页存储管理方式)
7.  [页面置换算法](# 页面置换算法)
8.  [请求分段存储管理方式](# 请求分段存储管理方式)

---

#### 程序的装入与链接

​	用户程序处理步骤:

+  编译程序产生目标模块
+  链接程序
+  装入模块
+  装入程序

1. 程序的装入

   +  绝对装入方式

     程序中所使用的的绝对地址，既可以在编译或者汇编时给出，也可以有程序员直接赋值。但是程序员直接赋值时，不仅仅需要熟悉内存使用情况，而且一旦数据或者程序发生了修改，可能要改变程序的所有地址，因此令可在程序中采用符号地址，然后编译或者汇编时，将这些符号地址转化为绝对地址。

   + 可重定位装入方式

     <img src="E:\截图文件\可重装式.png" style="zoom:50%;" />

   + 动态运行装入方式

     动态运行时装入程序，把装入模块装入内存后，并不立即把装入模块的相对地址转换为绝对地址。这种操作需要延时到程序真正执行时才进行。因此，装入内存后所有地址都是相对地址。

2.  程序的链接

   + 静态链接方式
   
     <img src="E:\截图文件\静态链接方式.png" style="zoom:67%;" />
   
     如图所示，当需要装配一个模块时，需要解决下面两个问题:
   
     1.  对相对地址进行修改 (B,C块的地址)
     2.  变换外部调用符合 B --> JSR "L"
   
   + 装入时动态链接
   
     优点:
   
     1.  便于修改和更新
     2.  便于实现对目标模块的共享
   
   + 运行时动态链接
   
     这种链接模式对默写模块链接要到执行时在执行(懒加载),即在执行过程中，当发现摸个被调用模块尚未装入内存，立即使用OS找到相应的模块并装入内存，把它链接到调用者模块上。法师执行过程中未使用到的目标模块，都不会被调入内存，和链接到装入模块中，这样加快了程序的装入过程，且节省大量内存空间。

#### 连续分配方式

1.  单一连续分配

   最简单的一种存储管理方式，只能用于单用户，单任务的操作系统中。采用这种存储管理方式时，可以把**系统区**和**用户区**两个部分，系统区仅仅提供给OS使用，通常处于内存的低地址区域，用户区为系统区以外的区域，供给用户使用。

2.  固定分区分配

   +  划分分区的方法

     1.  分区大小相等(所有分区内存大小相等)
     2.  分区大小不等

   + 内存分配 

     <img src="E:\截图文件\内存分配图示.png" style="zoom:67%;" />

3.  动态分区分配

   +  分区分配中使用的数据结构

     1.  空闲(可利用)分区表
     2.  空闲分区链表(队列)

   +  分区分配算法

     1.  首次适应算法FF
     2.  循环首次适应算法
     3.  最佳适应算法

   +  分区分配流程

     <img src="E:\截图文件\分配流程.png" style="zoom:67%;" />

4.  可重定位分区分配

   + 内存紧凑

     <img src="E:\截图文件\动态内存分配.png" style="zoom:67%;" />

   +  动态重定位的实现

     <img src="E:\截图文件\动态重定位效果.png" style="zoom:50%;" />
   
   +  动态重定位分区分配算法
   
     <img src="E:\截图文件\动态重定位分区算法流程.png" style="zoom:50%;" />
   
5. 对换

   +  对换的引入

     把内存中暂时不能运行的进程或者暂时不用的程序和数据，调到外存上，以便腾出足够的内存空间。再把已经具备运行条件的进程或进程需要的程序和数据,调入内存。对换时提高内存利用率的有效措施。

   +  对换空间的管理

     除了对对换区的空闲盘块进行管理，系统中配置相应的数据结构，已记录外存的使用情况。其形式与内存再动态分区分配方式中所有数据结构相似，同样可以空闲分区表和空闲分区链表。在空闲分区表中包含两项，即对换区**首地址**即**分区大小**。

   +  进程的换出和换入

     1.  进程的换出

        当进程由于创建子进程需要更多的内存空间，但又没有足够的内存空间等情况发生时。应当将某个进程换出。

        过程:

        系统首先选择处于阻塞状态，且优先级最低的进程作为换出进程，然后启动盘块，将进程的程序和数据传送到磁盘的对换区上。若传送过程中未出现错误，便可以回收该进程所占用的内存空间，并对该该进程PCB做出相应修改。

     2.  进程的换入

        系统提示查看所有进程状态，从中找出就绪状态，但是已经活出的进程，将其中换出时间最久的进程作为换入进程,并将其换入,直至无可以换入的进程或者无可换出的进程为止。

#### 基本分页存储管理方式

1.  页面与页表

   +  页面

     分页存储管理,是将一个进程的逻辑地址空间分割成若干个大小相等的片(称作**页面**/页)。并个各个页加上编号，从0开始。相应的内存空间分成与页面大小相同大小的若干存储卡，称作**物理块**/**页框**，也同样为其加上编号#0,#1...。为进程分配内存时，以块为单位将进程的若干页分别装入到多个不相邻的物理块中。由于进程中一页经常装不满，而形成了不可利用区域，称作为**页面碎片**。

     分页系统中页面大小应当适中,页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存.此外，还会降低页面换进换出的效率。

     如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。

     页面的大小应选择得适中，且页面大小应是2的幂，通常为512 B~8 KB(8192B).

   +  地址结构

     分页地址中地址结构如下:

     31-12 位	页号P

     11-0 位	偏移量W

     对于某个特定机器，地址结构是一定的。给定逻辑地址空间地址为A，页面大小为L，则页号P和页内地址d可以按照如下方式求解:

     ```markdown
     P= INT[A/L]
     d=[A] mod L
     ```

   +  页表

     页表处理页号与内存块之间的映射关系

     <img src="E:\截图文件\页表.png" style="zoom:67%;" />

2. 地址变换机构

   + 基本地址变换机构

     通过给定的页信息(页起始地址，页表长度)去页表中找到对应的物理地址。当然这其中需要对输入的业信息进行判断，主要判断其是否在页表运行的页范围内，页内地址是否符合要求(小于页长度)。

     如图所示:

     <img src="E:\截图文件\分页机制.png" alt="分页机制" style="zoom:67%;" />

   + 具有快表地址变换机构

     具有快表地址的变换机构在上面描述的结构中，加上了一个快表，这个快表可以通过输入寄存器提供的页号直接查找到对应的物理块号。
     
     如图所示：
     
     ​	<img src="E:\截图文件\快表.png" style="zoom:50%;" />

3.  两级和多级页表

   大多数现代计算机系统中，支持非常大的逻辑地址空间(2^32-2^64).这样的环境下，页表就变得非常的大，需要占用相当大的内存空间。
   
   例如，对于一个具有32位逻辑地址空间的分页系统，规定页面大小为4 KB即212B，则在每个进程页表中的页表项可达1兆个之多。又因为每个页表项占用一个字节，故每个进程仅仅其页表就要占用4KB的内存空间，而且还要求是连续的。 
   
   可以采用如下两个方法解决这一问题:
   
   1.  采用离散分配方式解决难以找到一块连续的大内存内存空间问题
   2.  只将当前需要部分页表调入内存，其余页表内容驻留在磁盘上，需要时再调用(spark)
   
   + 两级页表
   
     两级页表的逻辑结构由: 外层页号,外层页内地址,页内地址(双层映射，可以处理更大的存储空间)
   
     <img src="E:\截图文件\两级页表.png" style="zoom:67%;" />
     
     两级映射内存映射表:
     
     <img src="E:\截图文件\两级页表映射图.png" style="zoom:67%;" />
     
     两级页表地址变换机构简介:
     
     <img src="E:\截图文件\两级页表地址变换机构.png" style="zoom:67%;" />
     
   + 多级页表
   
     对于32位机器,采用两级页表结构是合适的.但是对于64位机器,如果页面仍采用4 KB(即2^12B).那么还剩余52位.假定仍按物理块的大小(2^12位)来划分页表,将剩余42位在外层页号,四十外层页表中可能含有4096G的页表项.需要占用16384G的连续内存空间.
   
     所以必要采用多级页表,对外层页表再进行划分.将各分页离散地址装入到不相邻的物理块中,再使用2级页表映射关系.

#### 基本分段存储管理方式

1.  分段存储管理方式引入

   引入分段存储管理方式,主要是满足如下需求

   +  方便编程
   +  信息共享
   +  信息保护
   +  动态增长
   +  动态链接

2.  分段系统基本原理

   +  段地址的结构

     段号 + 段内地址

     <img src="E:\截图文件\分段地址结构.png" style="zoom:67%;" />
   
   +  段表
   
     段表处理了段号和端信息(起始地址和段长)之间的关系.
   
     <img src="E:\截图文件\段地址.png" style="zoom:67%;" />
   
   +  地址变换结构模型
   
     地址定位先获取段号对应的段基址,获取段长度用以确定段范围
   
     <img src="E:\截图文件\段变换机构.png" style="zoom:67%;" />
   
   +  分页和分段的区别
     1.  页时信息的物理单位，分页时实现离散分配方式，用于消减内存外零头，提高内存利用率。段时信息的逻辑单位，含有一组相对完整的信息，主要是满足用户的需求。
     2.  页的大小固定且由系统决定，系统把逻辑地址划分为页号和页内地址两部分，有机器硬件实现，因此系统中只能使用一种大小的页面。但是段长度不固定，决定于用户编写程序，通常由编译程序对源程序进行编译，根据信息的性质进行划分。
     3.  分页作业地址空间时一维的，即单一线性的地址空间(获取到页号对应的页起始地址)。而段的作业地址时二维的(既需要给定段名，又需要给定段内地址，才能准确定位段内信息)
   
3. 信息共享

   分页系统中两个进程信息共享图:

   <img src="E:\截图文件\信息共享.png" style="zoom:67%;" />

   分段系统中两个进程共享图

   <img src="E:\截图文件\分段系统共享.png" style="zoom:67%;" />

4. 段页式存储管理方式

   +  地址结构

     段号S + 段内页号 P + 段内地址W

     作业空间地址
     
     <img src="E:\截图文件\作业地址空间.png" style="zoom:67%;" />
     
     地址结构
     
     <img src="E:\截图文件\地址结构.png" style="zoom:67%;" />

   +  段页式地址映射图

     <img src="E:\截图文件\段页式.png" style="zoom:67%;" />

5. 地址变换过程

   <img src="E:\截图文件\段页式地址变换.png" style="zoom:67%;" />

#### 虚拟存储器基本概念

1.  虚拟存储器的引入

   + 常规存储器管理方式特征

     1.  一次性
     2.  驻留性

   +  局部性原理

     1.  程序执行时，处理少部分转移和过程调用指令，大多数都是顺序执行的
     2.  过程调用将程序执行归集由一部分区域转移到另一部分区域。
     3.  过程中存在许多循环节后，多次执行。
     4.  程序中包含许多对数据结构处理。

     局限性表现在时间和空间两个维度

     1.  时间局限性

        如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作。

     2.  空间局限性

        一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。

   +  虚拟存储器定义

     是指具有请求调入功能，和置换功能，对逻辑上内存容量进行扩充的存储器系统。其逻辑容量为内存容量与外存容量之和，运行速度接近于内存速度。但是每位成本接近于外存。**虚拟存储技术**是一种性能优越的存储器管理技术。

2.  虚拟存储器的实现方法

   +  分页请求系统

     1.  硬件支持

        1.  请求分页的页表机制，在纯分页的页表机制的基础上，添加若干项形成，作为请求分页的数据结构。

        2.  缺页中断机制

           当请求页面尚未调入内存，便产生缺页中断。请求OS将缺页调入。

        3.  地址变换机构

           在分页地址变换机构基础上形成

     2.  实现请求分页的软件

3.  虚拟存储器特征

   +  多次性
   +  对换性
   +  虚拟性

#### 请求分页存储管理方式

1.  请求分页硬件支持

   +  页表机制

     页号	物理块号	状态位P	访问字段A	修改位M	外存地址

   +  缺页中断机构

   +  地址变换机构

     1.  检测页号是否大于页表长度,是则抛出异常，否则JMP 2
     2.  CPU检测快表，检查页表项首存在于快表中，是则JMP 3,否则JMP 4 
     3.  修改访问位和修改位，形成物理地址，地址便函结束
     4.  访问页表，确认页表是否在内存中，存在于内存中则JMP 5，否则引发缺页中断请求，调取外存上的页面JMP 6
     5.  修改快表, JMP 3
     6.   保留CPU现场，从外存中找到缺页，检查内存剩余容量是否满足缺页大小要求，满足则JMP 7，否则JMP 9
     7.  OS 命令CPU从外存调取页面到内存
     8.  修改页表信息，JMP 2
     9.  选取一页换出，检查该换取出来的页面是否被修改。如果被修改JMP 10，否则JMP 7。
     10.  将修改过的页面写回外存，JMP 7。

     图示:

     <img src="E:\截图文件\地址变换过程.png" style="zoom:67%;" />

2.  内存分配策略与分配算法

   +  最小物理块数确定

     最小物理块数是保证进程能够正常运行所需要的最小物理块数。当系统未经常分配物理块数少于这个数值的时候，进程无法运行。这个歌数据域硬件结构有关，取决于指令的格式，功能和寻址方式。

     对于简单地址指令，采用直接寻址方式，所需最少物理块数为2。一块存储存放指令的页面，另一块存放数据的页面。如果支持间接寻址方式，则需要再加上一块。

     对于功能性较强的机器，指令长度肯时两个或者是多于两个字节，因此指令本身可能会出现跨页面的情况，且源地址和目的地址所涉及的区域也可能块两个页面。

   +  物理块的分配策略

     可采用两类策略，意识全局置换，另一种时局部置换

     1.  固定分配局部置换
     2.  可变分配全局置换
     3.  可变分配局部置换

   +  物理块分配算法

     1.  平均分配算法

        将系统中所有可以分配的物理块，平均的分配到各个进程中。

        例如，当系统中有100个物理块，有5个进程在运行时，每个进程可分得20个物理块。这种方式貌似公平，但实际上是不公平的，因为它未考虑到各进程本身的大小。

        如有一个进程其大小为200页，只分配给它20个块，这样，它必然会有很高的缺页率；而另一个进程只有10页，却有10个物理块闲置未用。

     2.  按比例分配算法

        根据进程的大小按比例分配物理块的算法。如果系统中共有*n*个进程，每个进程的页面数为*S*i，则系统中各进程页面数的总和为：

        ​	S=sigma(1,n,si)

        又假定系统中可用的物理块总数为*m*，则每个进程所能分到的物理块数为*b**i*，将有：

        ​	b(i)= S(i)/S * m

     3.  考虑到优先权的分配算法

        实际应用中，照顾到重要的，紧迫的作业能尽快完成，为其分配较多的内存空间。通常采取方法时把内存中可分配的物理块分成两部分:

        一部分按比例分配给各个进程，另一部分根据进程优先权，适当增加且相应份额，分配给各个进程。

        在重要的实时系统中，可能是完全按照优先权为各个进程分配物理块。

3.  调页策略

   +  调入页面的策略

     1.  预调页策略
     2.  请求调页策略

   +  调入页面的来源

     请求分页系统中外存分为两个部分: 用于存放文件的**文件区**和用于存放对换页面的**对换区**。通常，对换区采用连续分配方式，而事件采用离散分配方式。所以，对换区的磁盘IO速度要比文件区高。这样，昂发送缺页中断请求时，系统可以采用下述方案调取缺页:

     1.  系统拥有足够的对换区空间，这时可以全部从对换区调取所需页面，提高调页速度。为此，在进程运行前，必须将于进程相关的文件，从文件区拷贝到对换区。
     2.  系统缺少足够的对换区空间，指示凡是不会被修改的文件，都从文件区调入。当换出这些页面时，由于它们未被修改而不必将其换出，以后调入时，依旧从文件区调入。但是对于那些可能修改的部分，必须将其调到对换区，以后需要时，就从对换区调入。
     3.  UNIX方式。由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。由于UNIX系统允许页面共享，因此，某进程所请求的页面有可能已被其它进程调入内存，此时也就无须再从对换区调入。 

   +  页面调入过程

     程序所要访问页面未在内存时，便向CPU发出一条缺页中断请求，中断处理程序首先保留CPU环境，分析中断原因，转入缺页中断处理程序。程序通过查找页表，得到该页表在外存的物理块后，此时如果能够容纳新页，直接将新页调入内存，然后修改页表。

     如果内存不足以容纳新页，则需要按照某类**置换算法**，选取一页准备换出到外存。如果该页没有被修改过，可以不用将其写回外存(内存页没有使用过)。否则必须要写出到外存，再把所缺的页调入内存。并修改页表相应的表项，置存在位为1，并将此页表写入快表。缺页调入到内存后，利用修改后的页表，去形成所需要访问数据的物理地址，再去访问内存数据。

#### 页面置换算法

1.  最佳置换算法和先进先出置换算法

   +  最佳置换算法

     最佳置换算法时将以后永不使用的,或者在最长时间内不会再被访问的页面换出内存。可以保证最低的缺页率。

     假定系统为某个进程分配了三个物理块，并考虑到一下页面引用串:

     ```markdown
     7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
     ```

     进程运行时，将7 0 1三个页面装入内存，当进程访问页面2时，就会产生缺页中断，OS根据最佳置换算法，将页面7换出。

     <img src="E:\截图文件\最佳置换算法图解.png" style="zoom:67%;" />

   +  先进先出算法

     按照装入的顺序换出页面

     <img src="E:\截图文件\FIFO内存置换算法.png" style="zoom:67%;" />

2.  最近最久未使用LRU算法

   算法原理图示:

   <img src="E:\截图文件\LRU原理图示.png" style="zoom:67%;" />

   LRU算法硬件支持

   + 寄存器

     为了记录某进程在内存中各页使用情况，必须给每个内存中页面配置一个移位寄存器，表示为: 其中n为页面数量

     R=R(n-1) R(n-2) ... R(0)

   +  使用栈来表示当前页面变化情况

     <img src="E:\截图文件\栈内存使用情况.png" style="zoom:67%;" />

3.  时钟(Clock)置换算法

   +  简单时钟置换算法

     算法逻辑:

     1. 查询指针向前移动，指向下一个表目
     2.  检测页面访问位是否为0，如果为0，则淘汰这个页面，否则JMP 3
     3.  置页面访问位为0，JMP 1

     <img src="E:\截图文件\简单时间置换算法.png" style="zoom:67%;" />

   +  改进型时钟置换算法

     由访问位A和修改位M可以组合如下四种类型页面:

     1.  A=0,M=0： 表示该页面既未访问也未修改，为最佳淘汰页面
     2.  A=0,M=1:  表示该页最近未被方位，但是已经被修改，不是很好的淘汰页面
     3.  A=1,M=0： 表示已经被访问，但是没有被修改，该页肯在此被访问。
     4.  A=1,M=1： 最近已经被访问且被修改，该页可能再次被访问。

     执行过程:

     1.  指针从当前位置开始，扫描循环队列，寻找A=0,M=0的页面，所遇到的第一个这样页面就是淘汰页。第一次访问不改变访问位A。
     2.  第一步失败，查找一周后，找不到一类页面，开始第二轮扫描，去寻找第二类页面，遇到的第一个二类页面未淘汰页。二类扫描期间，所有扫描过的页面访问位设置为0.
     3.  第二步失败，即找不到二类页面，将指针移动到开始位置，并将所有访问位设置为0.重复第一步，如果仍就失败，重复第二步，直至找到被淘汰的页面。

4.  其他置换算法

   +  最少使用(LFU) 置换算法
   +  页面缓冲算法(PBA)

#### 请求分段管理方式

+  请求分段中的硬件支持

  1.  段表机制

     段表字段信息

     段名 + 段长 + 段基址 + 存取方式 + 访问字段A + 修改位M + 存在位P + 增补位 + 外存地址

  2.  缺段中断机构

     处理过程:

     +  发现段S不在内存中

     +  阻塞请求进程

     +  检查内存中是否有合适的空闲区

       ​	case 存在有合适的内存区

       + 读入段S，修改段表和空闲链表
       + 唤醒请求线程 

          case 不存在有合适的空闲区

           		case 空闲容量满足要求：

       ​			1.  空间拼接，形成一个合适的空区，以供读取段S

       ​		  case 空闲区不满足要求

       ​			1.  释放掉一些不需要的段内存，提供合适的空区

     <img src="E:\截图文件\缺段中断机制.png" style="zoom:67%;" />

  3. 地址变换机构

     <img src="E:\截图文件\地址中断机构.png" style="zoom:67%;" />

+  分段的共享与保护

  1.  共享段表数据结构设置

     <img src="E:\截图文件\共享段表数据结构.png" style="zoom:67%;" />

  2.  共享段的分配与回收

     +  共享段的分配

       在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1；之后，当又有其它进程需要调用该共享段时，由于该共享段已被调入内存，故此时无须再为该段分配内存，而只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共享段的段表中，填上调用进程的进程名、存取控制等，再执行count∶=count+1操作，以表明有两个进程共享该段。

     +  共享段的回收

       当共享此段的某进程不再需要该段时，应将该段释放，包括撤在该进程段表中共享段所对应的表项，以及执行count∶=count-1操作。若结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段；否则(减1结果不为0)，则只是取消调用者进程在共享段表中的有关记录。

  3.  分段保护

     +  越界检查
     +  存取控制检查
       1.  只读
       2.  只执行
       3.  读/写
     +  环保护机构
       1.  一个程序可以访问驻留在相同环或较低特权环中的数据
       2.  一个程序可以调用驻留在相同环或较高特权环中的服务。

     