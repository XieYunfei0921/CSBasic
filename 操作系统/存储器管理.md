#### **存储器管理**

---

1.  [程序的装入与链接](#  程序的装入与链接)
2.  [连续分配方式](# 连续分配方式)
3.  [基本分页存储管理方式](# 基本分页存储管理方式)
4.  [基本分段存储管理方式](# 基本分段存储管理方式)
5.  [虚拟存储器基本概念](# 虚拟存储器基本概念)
6. [请求分页存储管理方式](# 请求分页存储管理方式)
7.  [页面置换算法](# 页面置换算法)
8.  [请求分段存储管理方式](# 请求分段存储管理方式)

---

#### 程序的装入与链接

​	用户程序处理步骤:

+  编译程序产生目标模块
+  链接程序
+  装入模块
+  装入程序

1. 程序的装入

   +  绝对装入方式

     程序中所使用的的绝对地址，既可以在编译或者汇编时给出，也可以有程序员直接赋值。但是程序员直接赋值时，不仅仅需要熟悉内存使用情况，而且一旦数据或者程序发生了修改，可能要改变程序的所有地址，因此令可在程序中采用符号地址，然后编译或者汇编时，将这些符号地址转化为绝对地址。

   + 可重定位装入方式

     <img src="E:\截图文件\可重装式.png" style="zoom:50%;" />

   + 动态运行装入方式

     动态运行时装入程序，把装入模块装入内存后，并不立即把装入模块的相对地址转换为绝对地址。这种操作需要延时到程序真正执行时才进行。因此，装入内存后所有地址都是相对地址。

2.  程序的链接

   + 静态链接方式
   
     <img src="E:\截图文件\静态链接方式.png" style="zoom:67%;" />
   
     如图所示，当需要装配一个模块时，需要解决下面两个问题:
   
     1.  对相对地址进行修改 (B,C块的地址)
     2.  变换外部调用符合 B --> JSR "L"
   
   + 装入时动态链接
   
     优点:
   
     1.  便于修改和更新
     2.  便于实现对目标模块的共享
   
   + 运行时动态链接
   
     这种链接模式对默写模块链接要到执行时在执行(懒加载),即在执行过程中，当发现摸个被调用模块尚未装入内存，立即使用OS找到相应的模块并装入内存，把它链接到调用者模块上。法师执行过程中未使用到的目标模块，都不会被调入内存，和链接到装入模块中，这样加快了程序的装入过程，且节省大量内存空间。

#### 连续分配方式

1.  单一连续分配

   最简单的一种存储管理方式，只能用于单用户，单任务的操作系统中。采用这种存储管理方式时，可以把**系统区**和**用户区**两个部分，系统区仅仅提供给OS使用，通常处于内存的低地址区域，用户区为系统区以外的区域，供给用户使用。

2.  固定分区分配

   +  划分分区的方法

     1.  分区大小相等(所有分区内存大小相等)
     2.  分区大小不等

   + 内存分配 

     <img src="E:\截图文件\内存分配图示.png" style="zoom:67%;" />

3.  动态分区分配

   +  分区分配中使用的数据结构

     1.  空闲(可利用)分区表
     2.  空闲分区链表(队列)

   +  分区分配算法

     1.  首次适应算法FF
     2.  循环首次适应算法
     3.  最佳适应算法

   +  分区分配流程

     <img src="E:\截图文件\分配流程.png" style="zoom:67%;" />

4.  可重定位分区分配

   + 内存紧凑

     <img src="E:\截图文件\动态内存分配.png" style="zoom:67%;" />

   +  动态重定位的实现

     <img src="E:\截图文件\动态重定位效果.png" style="zoom:50%;" />
   
   +  动态重定位分区分配算法
   
     <img src="E:\截图文件\动态重定位分区算法流程.png" style="zoom:50%;" />
   
5. 对换

   +  对换的引入

     把内存中暂时不能运行的进程或者暂时不用的程序和数据，调到外存上，以便腾出足够的内存空间。再把已经具备运行条件的进程或进程需要的程序和数据,调入内存。对换时提高内存利用率的有效措施。

   +  对换空间的管理

     除了对对换区的空闲盘块进行管理，系统中配置相应的数据结构，已记录外存的使用情况。其形式与内存再动态分区分配方式中所有数据结构相似，同样可以空闲分区表和空闲分区链表。在空闲分区表中包含两项，即对换区**首地址**即**分区大小**。

   +  进程的换出和换入

     1.  进程的换出

        当进程由于创建子进程需要更多的内存空间，但又没有足够的内存空间等情况发生时。应当将某个进程换出。

        过程:

        系统首先选择处于阻塞状态，且优先级最低的进程作为换出进程，然后启动盘块，将进程的程序和数据传送到磁盘的对换区上。若传送过程中未出现错误，便可以回收该进程所占用的内存空间，并对该该进程PCB做出相应修改。

     2.  进程的换入

        系统提示查看所有进程状态，从中找出就绪状态，但是已经活出的进程，将其中换出时间最久的进程作为换入进程,并将其换入,直至无可以换入的进程或者无可换出的进程为止。

#### 基本分页存储管理方式

1.  页面与页表

   +  页面

     分页存储管理,是将一个进程的逻辑地址空间分割成若干个大小相等的片(称作**页面**/页)。并个各个页加上编号，从0开始。相应的内存空间分成与页面大小相同大小的若干存储卡，称作**物理块**/**页框**，也同样为其加上编号#0,#1...。为进程分配内存时，以块尾单位将进程的若干页分别装入到多个不相邻的物理块中。由于进程左右一页经常装不满，而形成了不可利用区域，称作为**页面碎片**。

     分页系统中页面大小应当适中,页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存.此外，还会降低页面换进换出的效率。

     如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。

     页面的大小应选择得适中，且页面大小应是2的幂，通常为512 B~8 KB(8192B).

   +  地址结构

     分页地址中地址结构如下:

     31-12 位	页号P

     11-0 位	偏移量W

     对于某个特定机器，地址结构是一定的。给定逻辑地址空间地址为A，页面大小为L，则页号P和页内地址d可以按照如下方式求解:

     ```markdown
     P= INT[A/L]
     d=[A] mod L
     ```

   +  页表

     页表处理页号与内存块之间的映射关系

     <img src="E:\截图文件\页表.png" style="zoom:67%;" />

2. 地址变换机构

   + 基本地址变换机构

     通过给定的页信息(页起始地址，页表长度)去页表中找到对应的物理地址。当然这其中需要对输入的业信息进行判断，主要判断其是否在页表运行的页范围内，页内地址是否符合要求(小于页长度)。

     如图所示:

     <img src="E:\截图文件\分页机制.png" alt="分页机制" style="zoom:67%;" />

   + 具有快表地址变换机构

     具有快表地址的变换机构在上面描述的结构中，加上了一个快表，这个快表可以通过输入寄存器提供的页号直接查找到对应的物理块号。
     
     如图所示：
     
     ​	<img src="E:\截图文件\快表.png" style="zoom:50%;" />

3.  两级和多级页表

   大多数现代计算机系统中，支持非常大的逻辑地址空间(2^32-2^64).这样的环境下，页表就变得非常的大，需要占用相当大的内存空间。
   
   例如，对于一个具有32位逻辑地址空间的分页系统，规定页面大小为4 KB即212B，则在每个进程页表中的页表项可达1兆个之多。又因为每个页表项占用一个字节，故每个进程仅仅其页表就要占用4KB的内存空间，而且还要求是连续的。 
   
   可以采用如下两个方法解决这一问题:
   
   1.  采用离散分配方式解决难以找到一块连续的大内存内存空间问题
   2.  只将当前需要部分页表调入内存，其余页表内容驻留在磁盘上，需要时再调用(spark)
   
   + 两级页表
   
     两级页表的逻辑结构由: 外层页号,外层页内地址,页内地址(双层映射，可以处理更大的存储空间)
   
     <img src="E:\截图文件\两级页表.png" style="zoom:67%;" />
     
     两级映射内存映射表:
     
     <img src="E:\截图文件\两级页表映射图.png" style="zoom:67%;" />
     
     两级页表地址变换机构简介:
     
     <img src="E:\截图文件\两级页表地址变换机构.png" style="zoom:67%;" />
     
   + 多级页表
   
     对于32位机器,采用两级页表结构是合适的.但是对于64位机器,如果页面仍采用4 KB(即2^12B).那么还剩余52位.假定仍按物理块的大小(2^12位)来划分页表,将剩余42位在外层页号,四十外层页表中可能含有4096G的页表项.需要占用16384G的连续内存空间.
   
     所以必要采用多级页表,对外层页表再进行划分.将各分页离散地址装入到不相邻的物理块中,再使用2级页表映射关系.

#### 基本分段存储管理方式

1.  分段存储管理方式引入

   引入分段存储管理方式,主要是满足如下需求

   +  方便编程
   +  信息共享
   +  信息保护
   +  动态增长
   +  动态链接

2.  分段系统基本原理

   +  段地址的结构

     段号 + 段内地址

     <img src="E:\截图文件\分段地址结构.png" style="zoom:67%;" />
   
   +  段表
   
     段表处理了段号和端信息(起始地址和段长)之间的关系.
   
     <img src="E:\截图文件\段地址.png" style="zoom:67%;" />
   
   +  地址变换结构模型
   
     地址定位先获取段号对应的段基址,获取段长度用以确定段范围
   
     <img src="E:\截图文件\段变换机构.png" style="zoom:67%;" />
   
   +  分页和分段的区别
     1.  页时信息的物理单位，分页时实现离散分配方式，用于消减内存外零头，提高内存利用率。段时信息的逻辑单位，含有一组相对完整的信息，主要是满足用户的需求。
     2.  页的大小固定且由系统决定，系统把逻辑地址划分为页号和页内地址两部分，有机器硬件实现，因此系统中只能使用一种大小的页面。但是段长度不固定，决定于用户编写程序，通常由编译程序对源程序进行编译，根据信息的性质进行划分。
     3.  分页作业地址空间时一维的，即单一线性的地址空间(获取到页号对应的页起始地址)。而段的作业地址时二维的(既需要给定段名，又需要给定段内地址，才能准确定位段内信息)
   
3. 信息共享

   分页系统中两个进程信息共享图:

   <img src="E:\截图文件\信息共享.png" style="zoom:67%;" />

   分段系统中两个进程共享图

   <img src="E:\截图文件\分段系统共享.png" style="zoom:67%;" />

4. 段页式存储管理方式

   +  地址结构

     段号S + 段内页号 P + 段内地址W

     作业空间地址
     
     <img src="E:\截图文件\作业地址空间.png" style="zoom:67%;" />
     
     地址结构
     
     <img src="E:\截图文件\地址结构.png" style="zoom:67%;" />

   +  段页式地址映射图

     <img src="E:\截图文件\段页式.png" style="zoom:67%;" />

5. 地址变换过程

   <img src="E:\截图文件\段页式地址变换.png" style="zoom:67%;" />

#### 虚拟存储器基本概念

1.  虚拟存储器的引入

   + 常规存储器管理方式特征

     1.  一次性
     2.  驻留性

   +  局部性原理

     1.  程序执行时，处理少部分转移和过程调用指令，大多数都是顺序执行的
     2.  过程调用将程序执行归集由一部分区域转移到另一部分区域。
     3.  过程中存在许多循环节后，多次执行。
     4.  程序中包含许多对数据结构处理。

     局限性表现在时间和空间两个维度

     1.  时间局限性

        如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作。

     2.  空间局限性

        一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。

   +  虚拟存储器定义

     是指具有请求调入功能，和置换功能，对逻辑上内存容量进行扩充的存储器系统。其逻辑容量为内存容量与外存容量之和，运行速度接近于内存速度。但是每位成本接近于外存。**虚拟存储技术**是一种性能优越的存储器管理技术。

2.  虚拟存储器的实现方法

   +  分页请求系统

     1.  硬件支持

        1.  请求分页的页表机制，在纯分页的页表机制的基础上，添加若干项形成，作为请求分页的数据结构。

        2.  缺页中断机制

           当请求页面尚未调入内存，便产生缺页中断。请求OS将缺页调入。

        3.  地址变换机构

           在分页地址变换机构基础上形成

     2.  实现请求分页的软件

3.  虚拟存储器特征

   +  多次性
   +  对换性
   +  虚拟性

#### 请求分页存储管理方式

#### 页面置换算法

#### 请求分段管理方式

+  请求分段中的硬件支持

  1.  段表机制

     段表字段信息

     段名 + 段长 + 段基址 + 存取方式 + 访问字段A + 修改位M + 存在位P + 增补位 + 外存地址

  2.  缺段中断机构

     处理过程:

     +  发现段S不在内存中

     +  阻塞请求进程

     +  检查内存中是否有合适的空闲区

       ​	case 存在有合适的内存区

       + 读入段S，修改段表和空闲链表
       + 唤醒请求线程 

          case 不存在有合适的空闲区

         		case 空闲容量满足要求：

       ​			1.  空间拼接，形成一个合适的空区，以供读取段S

       ​		  case 空闲区不满足要求

       ​			1.  释放掉一些不需要的段内存，提供合适的空区

     <img src="E:\截图文件\缺段中断机制.png" style="zoom:67%;" />

  3. 地址变换机构

     <img src="E:\截图文件\地址中断机构.png" style="zoom:67%;" />

+  分段的共享与保护

  1.  共享段表数据结构设置

     <img src="E:\截图文件\共享段表数据结构.png" style="zoom:67%;" />

  2.  共享段的分配与回收

     +  共享段的分配

       在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1；之后，当又有其它进程需要调用该共享段时，由于该共享段已被调入内存，故此时无须再为该段分配内存，而只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共享段的段表中，填上调用进程的进程名、存取控制等，再执行count∶=count+1操作，以表明有两个进程共享该段。

     +  共享段的回收

       当共享此段的某进程不再需要该段时，应将该段释放，包括撤在该进程段表中共享段所对应的表项，以及执行count∶=count-1操作。若结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段；否则(减1结果不为0)，则只是取消调用者进程在共享段表中的有关记录。

  3.  分段保护

     +  越界检查
     +  存取控制检查
       1.  只读
       2.  只执行
       3.  读/写
     +  环保护机构
       1.  一个程序可以访问驻留在相同环或较低特权环中的数据
       2.  一个程序可以调用驻留在相同环或较高特权环中的服务。

     