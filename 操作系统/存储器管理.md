#### **存储器管理**

---

1.  [程序的装入与链接](#  程序的装入与链接)
2.  [连续分配方式](# 连续分配方式)
3.  [基本分页存储管理方式](# 基本分页存储管理方式)
4.  [基本分段存储管理方式](# 基本分段存储管理方式)
5.  [虚拟存储器基本概念](# 虚拟存储器基本概念)
6. [请求分页存储管理方式](# 请求分页存储管理方式)
7.  [页面置换算法](# 页面置换算法)
8.  [请求分段存储管理方式](# 请求分段存储管理方式)

---

#### 程序的装入与链接

​	用户程序处理步骤:

+  编译程序产生目标模块
+  链接程序
+  装入模块
+  装入程序

1. 程序的装入

   +  绝对装入方式

     程序中所使用的的绝对地址，既可以在编译或者汇编时给出，也可以有程序员直接赋值。但是程序员直接赋值时，不仅仅需要熟悉内存使用情况，而且一旦数据或者程序发生了修改，可能要改变程序的所有地址，因此令可在程序中采用符号地址，然后编译或者汇编时，将这些符号地址转化为绝对地址。

   + 可重定位装入方式

     <img src="E:\截图文件\可重装式.png" style="zoom:50%;" />

   + 动态运行装入方式

     动态运行时装入程序，把装入模块装入内存后，并不立即把装入模块的相对地址转换为绝对地址。这种操作需要延时到程序真正执行时才进行。因此，装入内存后所有地址都是相对地址。

2.  程序的链接

   + 静态链接方式
   
     <img src="E:\截图文件\静态链接方式.png" style="zoom:67%;" />
   
     如图所示，当需要装配一个模块时，需要解决下面两个问题:
   
     1.  对相对地址进行修改 (B,C块的地址)
     2.  变换外部调用符合 B --> JSR "L"
   
   + 装入时动态链接
   
     优点:
   
     1.  便于修改和更新
     2.  便于实现对目标模块的共享
   
   + 运行时动态链接
   
     这种链接模式对默写模块链接要到执行时在执行(懒加载),即在执行过程中，当发现摸个被调用模块尚未装入内存，立即使用OS找到相应的模块并装入内存，把它链接到调用者模块上。法师执行过程中未使用到的目标模块，都不会被调入内存，和链接到装入模块中，这样加快了程序的装入过程，且节省大量内存空间。

#### 连续分配方式

1.  单一连续分配

   最简单的一种存储管理方式，只能用于单用户，单任务的操作系统中。采用这种存储管理方式时，可以把**系统区**和**用户区**两个部分，系统区仅仅提供给OS使用，通常处于内存的低地址区域，用户区为系统区以外的区域，供给用户使用。

2.  固定分区分配

   +  划分分区的方法

     1.  分区大小相等(所有分区内存大小相等)
     2.  分区大小不等

   + 内存分配 

     <img src="E:\截图文件\内存分配图示.png" style="zoom:67%;" />

3.  动态分区分配

   +  分区分配中使用的数据结构

     1.  空闲(可利用)分区表
     2.  空闲分区链表(队列)

   +  分区分配算法

     1.  首次适应算法FF
     2.  循环首次适应算法
     3.  最佳适应算法

   +  分区分配流程

     <img src="E:\截图文件\分配流程.png" style="zoom:67%;" />

4.  可重定位分区分配

   + 内存紧凑

     <img src="E:\截图文件\动态内存分配.png" style="zoom:67%;" />

   +  动态重定位的实现

     <img src="E:\截图文件\动态重定位效果.png" style="zoom:50%;" />
   
   +  动态重定位分区分配算法
   
     <img src="E:\截图文件\动态重定位分区算法流程.png" style="zoom:50%;" />
   
5. 对换

   +  对换的引入

     把内存中暂时不能运行的进程或者暂时不用的程序和数据，调到外存上，以便腾出足够的内存空间。再把已经具备运行条件的进程或进程需要的程序和数据,调入内存。对换时提高内存利用率的有效措施。

   +  对换空间的管理

     除了对对换区的空闲盘块进行管理，系统中配置相应的数据结构，已记录外存的使用情况。其形式与内存再动态分区分配方式中所有数据结构相似，同样可以空闲分区表和空闲分区链表。在空闲分区表中包含两项，即对换区**首地址**即**分区大小**。

   +  进程的换出和换入

     1.  进程的换出

        当进程由于创建子进程需要更多的内存空间，但又没有足够的内存空间等情况发生时。应当将某个进程换出。

        过程:

        系统首先选择处于阻塞状态，且优先级最低的进程作为换出进程，然后启动盘块，将进程的程序和数据传送到磁盘的对换区上。若传送过程中未出现错误，便可以回收该进程所占用的内存空间，并对该该进程PCB做出相应修改。

     2.  进程的换入

        系统提示查看所有进程状态，从中找出就绪状态，但是已经活出的进程，将其中换出时间最久的进程作为换入进程,并将其换入,直至无可以换入的进程或者无可换出的进程为止。

#### 基本分页存储管理方式

1.  页面与页表

   +  页面

     分页存储管理,是将一个进程的逻辑地址空间分割成若干个大小相等的片(称作**页面**/页)。并个各个页加上编号，从0开始。相应的内存空间分成与页面大小相同大小的若干存储卡，称作**物理块**/**页框**，也同样为其加上编号#0,#1...。为进程分配内存时，以块尾单位将进程的若干页分别装入到多个不相邻的物理块中。由于进程左右一页经常装不满，而形成了不可利用区域，称作为**页面碎片**。

     分页系统中页面大小应当适中,页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存.此外，还会降低页面换进换出的效率。

     如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。

     页面的大小应选择得适中，且页面大小应是2的幂，通常为512 B~8 KB(8192B).

   +  地址结构

     分页地址中地址结构如下:

     31-12 位	页号P

     11-0 位	偏移量W

     对于某个特定机器，地址结构是一定的。给定逻辑地址空间地址为A，页面大小为L，则页号P和页内地址d可以按照如下方式求解:

     ```markdown
     P= INT[A/L]
     d=[A] mod L
     ```

   +  页表

     页表处理页号与内存块之间的映射关系

     <img src="E:\截图文件\页表.png" style="zoom:67%;" />

2.  地址变换机构

   + 基本地址变换机构
   + 具有块表地址变换机构

3.  两级和多级页表

   +  两级页表
   +  多级页表

#### 基本分段存储管理方式

#### 虚拟存储器基本概念

#### 请求分页存储管理方式

#### 页面置换算法

#### 请求分段管理方式

