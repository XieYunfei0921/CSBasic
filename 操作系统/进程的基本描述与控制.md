**目录**

2. [进程的描述](# 进程的描述)
3. [进程控制](# 进程控制)
4. [进程同步](# 进程同步)
5. [经典的进程同步问题](# 经典的进程同步问题)
6. [进程通信](# 进程通信)
7. [线程的基本概念](# 线程的基本概念)
8. [线程实现](# 线程实现)

---



#### 进程的描述

---

1. 前驱图

   前驱图是一个有向无环图，两个相邻的节点之间的边描述了两个节点的拓扑关系(偏序关系)。需要注意的是有向无环图是不能够存在有环的。

2. 程序顺序执行的特征

   各个程序块之间，必须按照某种先后次序顺序执行，仅当前一个操作执行完毕后，才能执行后续操作。

   + 程序顺序执行时的特征

     1. 顺序性: 每一个操作必须在上一个操作结束后才能开始。
     2. 封闭性: 程序在封闭的环境下执行，程序运行时独占全机资源。一旦程序执行，执行结构不受影响。
     3. 可以再现性: 只要程序执行时环境和初始条件相同，无论程序如何的重复执行，获得的结果都是相同的。

     顺序执行有利于检测和校验程序。

     <img src="E:\截图文件\程序的顺序执行.png" style="zoom:67%;" />

3. 程序并发执行的特征

   + 间断性

     程序并发执行时，由于共享系统资源，以及为了完成同一项任务相互合作，使得在并发过程中形成了制约关系。因此会导致并发程序的执行--暂停--执行的间断性活动规律。

   + 失去封闭性

     程序并发执行时，多个程序共享系统各种资源，这些资源有多个程序来改变，致使程序的执行会受到其他并发程序的影响，失去了封闭性。

   + 不可再现性

     程序失去了封闭性亦可能导致程序失去了可在现性。即执行环境和初始条件相同，获得的执行结果不同。

     <img src="E:\截图文件\程序并发执行前驱图.png" style="zoom:67%;" />

4. 进程的特征

   + 结构特征

     正常状态下程序是不能够并发执行的，为了使程序能够独立运行，应当为其配置一个**进程控制块**(PCB)。因此创建进行通常指的是对进程控制块的创建，撤销进程实质上是对PCB的撤销(free)。**进程实体**由PCB,程序段，相关数据段组成。

   + 动态性

     进程实质是进程实体的一次执行，因此动态性是进程的基本特征，此外还表现在:进程由创建而生,由调度而执行，由撤销而消亡。

   + 并发性

     指的是多个进程同时存在于内存中，且能一段时间内同时运行。并发性是进程的重要特征。通常程序没有PCB是不能并发执行的。

   + 独立性

     进程实体能够独立运行，独立分配资源，独立接受调度。

   + 异步性

     进程按照各自独立的，不可预知的速度向前前进。

   因此，进程是进程实体的运行过程，是系统分配资源和调度的一个独立单位。

5. 进程的状态

   + 就绪状态

     当进程分配到处CPU之外的所有资源之后，只要再获得CPU即可立即执行，这个状态叫做就绪状态。一个系统中具有多个就绪状态的进程可以有多个，通常会排列成一个队列，叫做就绪队列。

   + 执行状态

     进程以及获得CPU的状态，在多处理机系统中可以有多个进程处于执行状态。

   + 阻塞状态由于发生时间而导致进程暂时无法进行，便放弃处理机而处于暂停状态。造成阻塞的常见事件有: 请求IO，申请缓冲空间。通常这个处于阻塞状态下的进程也会组成队列，有的系统还会根据不同的阻塞原因组成不同的队列。

     ![](E:\截图文件\Snipaste_2020-01-08_15-13-28.png)

   + 挂起状态

     设置挂起状态之后，使得进行处于就绪状态，但是不会再受OS的调度。

     主要应用于:

     1. 终端用户的请求: 用户希望在程序运行期间发现可疑的问题，并对其进行修改

     2. 父进程请求: 父进程希望挂起某个子进程，并对其进行修改。

     3. 符合调节需求: 实时系统中工作负荷较重，为保证系统正常运行，会将一些不重要的进程挂起。

     4. 操作系统要求: OS希望挂起某些进程，检查运行过程中资源使用情况。

        <img src="E:\截图文件\4状态转换图.png" style="zoom:80%;" />

   + 创建状态

     创建进程包括两个部分:

     1. 为了创建一个新的PCB，需要填写必要的管理信息
     2. 将进程转入就绪状态，添加到就绪队列中。

     当一个新的进程被创建时，系统为其分配了PCB，填写了进程标识信息。但是由于进程所需要的其他信息或者资源，比如说主存资源尚未分配。此时进程拥有了自己的PCB，但是并没有进入主存，即进程创建完成，处于**创建状态**。此时进程还是不能被调度执行。

   + 终止状态

     进程终止的步骤

     1. 等待操作系统善后
     2. 对PCB清空，并将PCB空间返回给系统(释放内存空间)

     一旦其他进程完成对终止进程的信息提取之后，操作系统将会对其进行删除操作。

     <img src="E:\截图文件\5状态转换图.png" style="zoom:80%;" />

6. 进程控制块

   + 进程控制块作用

     是操作系统中最重要的记录型数据结构。PCB记录了操作系统中**所需的**，用于**描述进程当前情况**以及控制**进程运行**的全部信息。PCB是进程存在的唯一标志。

     PCB生存在进程的生命周期中，在此期间，可以被操作系统的多个模块读或者修改。如**调度程序**，**资源分配程序**，**中断处理程序**和**监督分析程序**等。由于PCB经常被访问，所有PCB应当常驻内存。系统将所有的PCB组织成一个链表(队列)。

   + 进程控制块基本信息

     1. 进程标识符

        用于唯一的标识进程

        + 内部标识符

          方便系统使用

        + 外部标识符

          在用户访问进程时使用，为了描述进程的**家族关系**，还应当设置父进程以及子进程的标志。还可以设置用户标志，只是拥有进程的用户。

     2. 处理机状态

        处理机状态信息主要有处理机的各种寄存区中内容组成。当处理机被中断时，所有这些信息都必须保存在PCB中，以便重新执行时能够**断点继续执行**。这些信息包括:

        + 通用寄存器

          用于暂存信息，可供用户访问

        + 指令计数器

          存放着需要访问的下一条指令地址

        + 程序状态字

          状态信息: 条件码，执行方式，中断屏蔽方式

        + 用户栈指针

          每个用户都有一个或多个相关的系统栈，用于存放过程和**系统调用参数**以及**调用地址**,栈指针指向栈的栈顶。

     3. 进程调度信息

        存放一些与进程调度有进程替换相关的信息。

        + 进程状态

          指明进程为当前状态，作为**进程调度**和**进程对换**的依据。

        + 进程优先级

          优先级高，则处理机优先处理

        + 进程调度需要的其他信息

          与所采用的的进程调度方法有关。比如，进程等待CPU时间总和，进程已经执行时间总和等。

        + 时间

          主要是阻塞原因

     4. 进程控制信息

        + 程序和数据的地址

          指的是程序和数据所在内存或者是外存的**首地址**，以便到该程序执行时，能够从PCB中找到程序和数据。

        + 进程同步和通信机制

          实现进程同步和进程通信时必须要的机制，如**消息队列指针**，**信号量**等

        + 资源清单

          除CPU外进程所需的全部资源，以及分配到该进程的资源

        + 链接指针

          指向PCB所在队列中，下一个进程PCB的**首地址**

   + 进程控制块的组织方式

     1. 链接方式

        指具有同一状态的PCB连接成一个队列。这样基本可以形成就绪队列，阻塞队列，以及空白队列。其中需要对就绪队列按照优先级关键字排序，以供处理机处理。

        <img src="E:\截图文件\PCB链式存储.png" style="zoom:80%;" />

     2. 索引方式

        系统根据又有进程状态建立几张索引表，例如**就绪索引表**，**阻塞索引表**。索引表中存储PCB内存首地址。

        <img src="E:\截图文件\PCB索引表.png" style="zoom:80%;" />

#### **进程控制**

---

进程控制一般有OS内核中**原语**来实现

原语有若干条指令组成，用于完成一定功能的一个过程，具有**原子操作**的特性。原子操作指的是一个操作中的所有动作要么全做，要么全不做，执行过程中不允许被中断。原则操作在**管态**状态下常驻内存。

原语作用是实现进程的通信和控制，系统对于进程如果不使用原语，就会造成状态的不确定性。

1. **进程的创建**

   + 引起进程创建的事件
     1.  用户登录
     2.  作业调度
     3.  提供服务
     4.  应用请求
   +  进程创建的过程
     1. 申请空白PCB
     2.  为新进程分配资源
     3.  初始化进程控制块
     4.  将新进程插入就绪队列(在就绪队列允许的情况下)

2. **进程的终止**

    **进程终止的常见原因**

   + 正常终止

   +  异常结束

     常见的异常结束

     1. **越界错误**	程序所访问的存储区，已越出该进程的区域
     2.  **保护错**   进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问
     3.  **非法指令**    程序试图去执行一条不存在的指令
     4.  **特权指令错误**    用户进程试图去执行一条只允许OS执行的指令
     5.  **运行超时**     进程的执行时间超过了指定的最大值
     6.  **等待超时**     进程等待某事件的时间， 超过了规定的最大值
     7.  **算数运算错误**
     8.  **IO故障**

   +  外界干预

     1.  **操作员/OS干预**		发生了死锁， 由操作员或操作系统终止该进程
     2.  **父进程请求**    父进程具有终止自己的任何子孙进程的权利， 因而当父进程提出请求时，系统将终止该进程 
     3.  **父进程终止**     当父进程终止时，OS也将他的所有子孙进程终止。 

   **进程终止的过程**

   + 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态(检索PCB)
   + 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。(修改进程调度标记)
   +  若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。(子孙进程处理方案)
   +  将被终止进程所拥有的全部资源，或者归还给其父进程， 或者归还给系统。(资源处理)
   +  将被终止进程(它的PCB)从所在队列(或链表)中移出，等待其他程序来搜集信息。(移出队列) 

3. **进程的阻塞与唤醒**

   **引起阻塞/唤醒的事件**

   + 请求系统服务
   +  启动某种操作
   +  新数据尚未到达
   +  无新工作可做

   **进程阻塞过程**

   1.  进入block过程后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列(如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列)
   2.  转调度程序进行重新调度,将处理机分配给另一就绪进程，并进行切换.也就是说，保留被阻塞进程的处理机状态(在PCB中)，再按新进程的PCB中的处理机状态设置CPU的环境。

   **进程唤醒过程**

   1.  首先把被阻塞的进程从等待该事件的阻塞队列中移出
   2.  将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。

4. **进程的挂起与激活**

   **进程的挂起**

   + 常见挂起事件
     1.  用户进程请求将自己挂起
     2.  父进程请求将自己的某个子进程挂起
     3.  系统将利用挂起原语suspend()将指定进程或处于阻塞状态的进程挂起
   + 挂起的执行过程
     1.  首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪；对于活动阻塞状态的进程，则将之改为静止阻塞。(状态切换)
     2.  为了方便用户或父进程考查该进程的运行情况而把该进程的PCB复制到某指定的内存区域。
     3.  若被挂起的进程正在执行，则转向调度程序重新调度。 

   **进程的激活**

   + 常见激活事件
     1.  父进程或用户进程请求激活指定进程(若该进程驻留在外存而内存中已有足够的空间时，则可将在外存上处于静止就绪状态的进程换入内存)
     2.  系统将利用激活原语active()将指定进程激活
   + 激活的执行过程
     1.  激活原语先将进程从外存调入内存，检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞便将之改为活动阻塞。(状态处理)
     2.  假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，应检查是否要进行重新调度，即由调度程序将被激活进程与当前进程进行优先级的比较，如果被激活进程的优先级更低，就不必重新调度；否则，立即剥夺当前进程的运行，把处理机分配给刚被激活的进程。(抢占处理措施)

#### **进程同步**

---

1.  进程之间的制约关系

   + 间接相制约互关系
   + 直接相互制约关系

2.  临界资源

   ```markdown
   生产者-消费者问题简介：
   	有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程将它所生产的产品放入一个缓冲区中； 消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步，即不允许消费者进程到一个空缓冲区去取产品；也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。 
   ```

   解决这个问题的基本方法:

   ```markdown
   	我们可利用一个数组来表示上述的具有n个(0，1，…，n-1)缓冲区的缓冲池。用输入指针in来指示下一个可投放产品的缓冲区，每当生产者进程生产并投放一个产品后，输入指针加1；用一个输出指针out来指示下一个可从中获取产品的缓冲区，每当消费者进程取走一个产品后，输出指针加1。 由于这里的缓冲池是组织成循环缓冲的，故应把输入指针加1表示成 in∶=(in+1)mod n；输出指针加1表示成out∶=(out+1) mod n。当(in+1) mod n=out时表示缓冲池满；而in=out则表示缓冲池空。此外，还引入了一个整型变量counter, 其初始值为0。每当生产者进程向缓冲池中投放一个产品后，使counter加1；反之，每当消费者进程从中取走一个产品时， 使counter减1。生产者和消费者两进程共享下面的变量： 则有如下关系:
   	Var n, integer;
   	type item=…;
   	var buffer:array［0, 1, …, n-1］ of item;
   	in, out: 0, 1, …, n-1;
   	counter: 0, 1, …, n;
   	其中: 指针in和out初始化为1 ,no-op是一条空操作指令，while condition do no-op语句表示重复的测试条件(condication). 重复测试应进行到该条件变为false(假)，即到该条件不成立时为止。在生产者进程中使用一局部变量nextp,用于暂时存放每次刚生产出来的产品；而在消费者进程中，则使用一个局部变量nextc,用于存放每次要消费的产品。 
   ```

   获得如下代码:

   ```markdown
   producer: repeat
        …
        produce an item in nextp;
        …
        while counter=n do no-op;
        buffer［in］∶   =nextp;
        in∶   =in+1 mod n;
        counter∶   =counter+1;
       until false;
   consumer: repeat
        while counter=0 do no-op;
        nextc∶   =buffer［out］;
        out∶   =(out+1) mod n;
        counter∶   =counter-1;
        consumer the item in nextc;
       until false; 
   
   ```

   ​		虽然上面的生产者程序和消费者程序，在分别看时都是正确的，而且两者在顺序执行时其结果也会是正确的，但若并发执行时，就会出现差错，问题就在于这两个进程共享变量counter。生产者对它做加1操作，消费者对它做减1操作.

3.  临界区

可把一个访问临界资源的循环进程描述如下

```markdown
repeat
	entry section	//进入区域
	critical section 	// 临界区
	exit section	// 退出这个区域
	remainder section	// 剩余区
until false
```
4. 同步机制应当遵守的原则

   +  空闲则进
   +  忙则等待
   +  有限等待
   +  让权等待

5.  信号量机制

   + 整形信号量

     将整型信号量定义为一个整形量。除了初始化操作以外，仅能通过两个原子操作wait(S)，和signal(S)来访问。这两个操作分别称作P，V。可以做如下描述：

     ```markdown
     // S表示(信号量)
     wait(S): while S≤0 do no-op
              S∶=S-1;	// 获取信号量
     signal(S): S∶=S+1;  // 是否信号量
     ```
	  整形信号量缺陷：只要是信号量S≤0，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。

   + 记录型信号量

       	记录型信号量机制，则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。

     ​	为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量value外，还应增加一个进程链表L，用于链接上述的所有等待进程。

     ​	记录型信号量是由于它采用了记录型的数据结构(L）而得名的。
   
     ```markdown
     type semaphore=record	// 定义基本记录数据结构
              value:integer;	// 资源数目
              L:list of process;	// 进程列表
              end
     相应地，wait(S)和signal(S)操作可描述为：
     procedure wait(S)
          var S: semaphore;
          begin
            S.value∶=S.value-1;
            if S.value＜0 then block(S,L)	
            // 资源量不足，阻塞，并加入等待链表(队列).遵循让权等待
          end
     procedure signal(S)
          var S: semaphore;
          begin
           S.value∶=S.value+1;
           if S.value≤0 then wakeup(S,L);
           // 资源量不足，唤醒列表中的一个等待进程
          end
     
     ```
   
   + AND型型号量
   
     在两个进程中都要包含两个对Dmutex和Emutex的操作
   
     | process A    | process B    |
     | ------------ | ------------ |
     | wait(Dmutex) | wait(Emutex) |
     | wait(Emutex) | wait(Dmutex) |
   
     若进程A和B按下述次序交替执行wait操作：
   
     则:
   
     ```markdown
     process A: wait(Dmutex); 于是Dmutex=0
     process B: wait(Emutex); 于是Emutex=0
     process A: wait(Emutex); 于是Emutex=-1 A阻塞
     process B: wait(Dmutex); 于是Dmutex=-1 B阻塞 
     ```
   
     AND同步机制基本思想为:
   
     ​		将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。亦即，对若干个临界资源的分配，采取原子操作方式：要么全部分配到进程，要么一个也不分配。
   
     ​		由死锁理论可知，这样就可避免上述死锁情况的发生。为此，在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为同时wait操作， 即Swait(Simultaneous
     wait)定义如下： 
   
     ```markdown
     Swait(S1, S2, …, Sn)	// AND 形式 wait
         if Si≥1 and … and Sn≥1 then
             for i∶=1 to n do
             Si∶=Si-1;
             endfor
         else
          place the process in the waiting queue associated with the first Si found with Si＜1, and set the program count of this process to the beginning of Swait operation
       endif
     Ssignal(S1, S2, …, Sn)	// AND形式 signal
           for i∶=1 to n do
           Si=Si+1;
           Remove all the process waiting in the queue associated with Si into the ready queue.
       endfor; 
     ```
   
   + 信号量集
   
        ```markdown
        Swait(S1, t1, d1, …, Sn, tn, dn)
        if Si≥t1 and … and Sn≥tn then
           	for i∶=1 to n do
           		Si∶=Si-di;
            endfor
        else
           	Place the executing process in the waiting queue of the first Si with Si＜ti and set its program counter to the beginning of the Swait Operation.
        endif
        Signal(S1, d1, …, Sn, dn)
          for i∶=1 to n do
           Si ∶=Si+di;
           	Remove all the process waiting in the queue associated with Si into the ready queue
           endfor; 
        
        ```
   
        信号量集的特殊情况:
   
        1.  Swait(S, d, d),此时在信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数少于d时，不予分配。
        2.  Swait(S, 1, 1)。此时的信号量集已蜕化为一般的记录型信号量(S＞1时)或互斥信号量(S=1时)
        3.  Swait(S,1, 0)。这是一种很特殊且很有用的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。
   
   + 信号量的简单应用
   
        1.  利用信号量实现简单的进程互斥
   
           ```markdown
           Var mutex:semaphore∶=1;
               begin
               parbegin
                process 1: begin
                    repeat
                        wait(mutex);
                        critical section
                        signal(mutex);
                        remainder seetion
                    until false;
                end
                process 2: begin
                	repeat
                		wait(mutex);
                		critical section
               		 signal(mutex);
               		 remainder section
               	 until false;
                end
              	parend
           ```
           
        2.  实现前驱图逻辑
   
           前驱拓扑:
   
           <img src="E:\截图文件\前驱拓扑.png" style="zoom:70%;" />
   
        	```markdown
   	 Var a,b,c,d,e,f,g; semaphore∶=0,0,0,0,0,0,0;
        	      begin
	          parbegin
			     	begin S1; signal(a); signal(b); end;
			     	begin wait(a); S2; signal(c); signal(d); end;
			     	begin wait(b); S3; signal(e); end;
			     	begin wait(c); S4; signal(f); end;
			     	begin wait(d); S5; signal(g); end;
			     	begin wait(e); wait(f); wait(g); S6; end;
			        parend
			   end 
			```
#### **经典的进程同步问题**

---




#### **进程通信**

---



#### **线程的基本概念**

---



#### **线程实现**

---


