#### **处理机调度与死锁**

---

1.  [处理机调度的基本概念](# 处理机调度的基本概念)
2.  [调度算法](# 调度算法)
3.  [实时调度](# 实时调度)
4.  [多处理机中的调度](# 多处理机中的调度)
5.  [产生死锁的原因和必要条件](# 产生死锁的原因和必要条件)
6.  [预防死锁的方法](# 预防死锁的方法)
7.  [死锁的检测和解除](# 死锁的检测和解除)

---

#### 处理机调度的基本概念

1.  高级/中级/低级调度

   + 高级调度

     每次执行作业调度时，必须做出如下两个决定:

     - 接纳多少个作业
     - 接纳哪些作业

   + 中级调度

     引入中级调度的主要目的，是为了提高内存利用率和系统吞吐量。因此，应当使那些暂时不能运行的进程不再占有宝贵的内存资源。而将它们调到外存上,此时进程状态称为**就绪驻外存状态**或**挂起状态**。这些进程有重新具备运行条件，且内存用足够空闲时。使用中级调度决定外存上那些具备运行条件的就绪进程进入，重新调入内存。并修改其状态为就绪状态，挂在就绪队列上等待进程调度。

   + 低级调度

     低级调度分为两种情况

     1.  非抢占式调用

        引起进程调度的因素

        +  正在执行的进程执行完毕，或因某时间不能继续执行
        +  执行中因为IO请求暂停执行
        +  在通信/同步过程中执行某种原语，如P操作(wait操作),Block原语,Wakeup原语。

        这种方式优点是实现简单，系统开销小，适用于大多数批处理系统环境。但是难以满足紧急任务需求(立即执行)。显然·在要求比较严格的实时系统中，不适合采用这个调度方法。

     2.  抢占式调用

        +  优先权原则
        +  短作业(进程)优先原则
        +  时间片原则

2.  调度队列模型

   + 仅有进程调度的调度队列模型

     <img src="E:\截图文件\仅有进程调度的调度队列模型.png" style="zoom:67%;" />

   +  具有高级和低级调度的调度队列模型

     <img src="E:\截图文件\高低级别的调度队列.png" style="zoom:67%;" />

   + 具备三级调度的调度队列模型
   
   
     <img src="E:\截图文件\三级调度.png" style="zoom:60%;" />  
   
3. 选择调度方式和调度算法的准则

   +  面向用户的准则
     1.  周转时间短
     2.  响应时间块
     3.  截止时间的保证
   +  面向系统的准则
     1.  系统吞吐量高
     2.  处理机利用率好
     3.  各类资源平衡利用

#### 调度算法

1. 先来先去服务调度算法(FCFS)

   调度时间线

   <img src="E:\截图文件\FCFS.png" style="zoom:67%;" />

2. 短作业优先调度算法

   ​		短作业优先调度算法SJF，是指短作业或短进程优先调度算法。可以用于作业调度和进程调度。调度算法从后备队列中选择一个或者多个估计运行时间最短的作业，将它们调入内存。

   ​		而短进程调度算法(SPF),是从接续队列中估算出最短运行时间的进行，将处理机分配给他们。使它一直执行到完成，或发生某实现被阻塞，进而重新调度。

   ​	SJ(P)F算法的缺陷:

   1. 对长作业算法不利，会导致长作业长时间不被调度

   	2. 算法没有考虑到作业的紧急程度，不能保证紧迫性作业会被及时处理
    	3. 由于作业长短时根据用户提供的执行时间决定的，所以不一定做到真正的短作业优先调度。 

3. 高优先权优先调度算法

   + 优先权调度算法

     1.  非抢占式优先权算法

        ​		这种方式下，一旦系统把处理机分配给就绪队列中优先级最高的进程后。该进程边一直执行下去，直至完成。或因发生某事件使进程放弃处理机时,系统可将处理机重新分配给另一优先权最高的进程。这种调度算法适用于批处理系统中，也可以使用在实时性要求不高的实时系统中。

     2.  抢占式优先权调度算法

        ​		在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。

        ​	即每当系统中出现一个新的就绪进程i时，就将其优先权Pi与正在执行的进程j的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi＞Pj,则立即停止Pj的执行，做进程切换，使i进程投入执行。

        ​	这种抢占式的优先权调度算法，能更好的满足紧迫作用的要求，适用于要求严格的实时系统中或要求较高的批处理和分时系统中。

   +  优先权类型

     1.  静态优先权

        静态优先权是创建进程时确定的，且在进程运行期间一直不变。优先权一般使用某一返回内的一个整数来表示。比如0-7 或0-255，0表示最高优先权。

     2.  动态优先权

        动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。

        +  解决FCFS长期不调用问题

        ​		例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率a提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即FCFS算法。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。

        +  防止垄断

        ​		当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。

   +  高响应比优先调度算法

     优先权=(等待时间+ 要求服务时间)/要求服务时间=响应时间/要求服务时间

     1.  如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。
     2.  当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。
     3.  对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高， 从而也可获得处理机。

4. 基于时间片的轮转调度算法

   +  时间片轮转法

     ​		在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则，排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片的处理机执行时间。

   +  多级反馈队列调度算法

     1. 设置对个就绪队列，每个队列赋予不同的优先级。第一个队列优先级最高，其他队列优先级按照队列编号依次降低。算法服务各个队列执行时间片大小也不相同，优先级越高,规定的执行时间片越小。
     2.  当一个新的进程进入内存后，首先将其放入到第一个队列的某位，按照FCFS原则进程排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列中便采取按时间片轮转的方式运行。
     3.  仅当第一队列空闲时，调度程序才调度第二队列中的进程运行； 仅当第1~(i-1) 队列均空时，才会调度第i队列中的进程运行。

     <img src="E:\截图文件\多级反馈.png" style="zoom:67%;" />

   +   多级反馈队列调度算法性能

     1.  终端型作业用户
     2.  短批处理作业用户
     3.  长批处理作业用户

#### 实时调度

+  实时调度所必须的基本条件

  1.  需提供必要的信息

     +  就绪时间
     +  开始截止时间和完成截止时间
     +  处理时间
     +  资源要求
     +  优先级

  2.  足够的系统处理能力

     提高系统处理能力，主要有如下两个途径:

     +  仍然采用单处理机系统，需要增强其处理能力，以显著减少每个任务的处理时间
     +  采用多处理机系统

  3.  采用抢占式调度机制

     当一个优先级更高的任务到达时，运行将之前的任务暂时挂起，令高优先级任务立即投入运行。这样便可以满足硬实时任务对截止时间的要求。

     对于一些小的实时系统，如果能够预知开始截止时间，对实时任务的调度可以采用非抢占调度机制，以简化调度程序对任务调度所花费的系统开销，使用这种方法时，需要保证所有的实时任务都比较小，并在执行完关键性程序和临界区之后，能够及时的将自己阻塞起来，以便释放处理机。供调度程序去调度即将到达的任务。

  4.  具有快速切换机制

     该机制需要具有如下两方面能力:

     +  对外部中断的快速响应能力

       为使在紧迫的外部事件请求中断时系统能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机。

     +  快速的任务分配能力

       在完成任务调度后，便应进行任务切换。为了提高分派程序进行任务切换时的速度，
       应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。 

+  实时调度算法分类

  1.  非抢占式调度算法

     +  非抢占式轮转调度算法
     +  非抢占式优先调度算法

  2.  抢占式调度算法

     +  基于时钟中断的抢占式优先权调度算法
     +  立即抢占的有限调度算法

     <img src="E:\截图文件\时间调度算法.png" style="zoom:67%;" />

+  常见实时调度算法

  1.  最早截止时间优先EDF (Earliest Deadline First)算法 （用于非抢占式调度）

     <img src="E:\截图文件\EDF算法.png" style="zoom:67%;" />

  2.  最低松弛度优先即LLF(Least Laxity First)算法

     算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高，以使之优先执行。

     在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行。

     假如在一个实时系统中，有两个周期性实时任务A和B，任务A要求每 20 ms执行一次，执行时间为10 ms；任务B只要求每50 ms执行一次，执行时间为25 ms。

     <img src="E:\截图文件\LLF.png" style="zoom:67%;" />

#### 多处理机中的调度

+  多处理器系统类型

  1.  紧密耦合MPS

     通过**高速总线或高速交叉开关**，来实现多个处理器之间的互连的。它们共享**主存储器系统**和**I/O设备**，并要求将**主存储器划分为若干个能独立访问的存储器模块**，以便多个处理机能同时对主存进行访问。系统中的所有资源和进程，都**由操作系统实施统一的控制和管理**。 

  2.  松散耦合MPS

     通过**通道或通信线路**，来实现多台计算机之间的互连。每台计算机都有自己的**存储器**和**I/O设备**，并**配置了OS来管理本地资源和在本地运行的进程**。因此，每一台计算机都能独立地工作，必要时可通过通信线路与其它计算机交换信息，以及协调它们之间的工作。 

  3.  对称多处理器系统和非对称多处理器系统

     +  对称多处理器系统(SMPS)

       在系统中所包含的各处理器单元，在功能和结构上都是相同的， 当前的绝大多数MPS都属于SMP系统。

     +  非对称多处理器系统

       在系统中有多种类型的处理单元，它们的功能和结构各不相同，其中只有一个主处理器，有多个从处理器。 

+  进程分配方式

  1.  对称多处理器系统中进程分配方式

     ​		在SMP系统中，所有的处理器都是相同的，因而可把所有的处理器作为一个处理器池(Processor pool)，由调度程序或基于处理器的请求，将任何一个进程分配给池中的任何一个处理器去处理。在进行进程分配时，可采用以下两种方式之一。 

     +  静态分配方式
     +  动态分配方式

  2.  非对称多处理器系统进程分配方式

     ​		对于非对称MPS，其OS大多采用主—从(Master-Slave)式OS， 即OS的核心部分驻留在一台主机上(Master)， 而从机(Slave)上只是用户程序，进程调度只由主机执行。 每当从机空闲时， 便向主机发送一索求进程的信号， 然后， 便等待主机为它分配进程。 在主机中保持有一个就绪队列， 只要就绪队列不空，主机便从其队首摘下一进程分配给请求的从机。从机接收到分配的进程后便运行该进程， 该进程结束后从机又向主机发出请求。 

+  进程(线程)调度方式

  1.  自调度方式

     +  自调度机制

       ​	在系统中设置有一个公共的进程或线程就绪队列，所有的处理器在空闲时，都可自己到该队列中取得一进程(或线程)来运行。在自调度方式中，可采用在单处理机环境下所用的调度算法，如先来先服务(FCFS)调度算法、最高优先权优先(FPF)调度算法和抢占式最高优先权优先调度算法等。

     +  自调度优势

       1.  系统中的公共就绪队列可按照单处理机系统中所采用的各种方式加以组织
       2. 调度算法也可沿用单处理机系统所用的算法，亦即，很容易将单处理机环境下的调度机制移植到多处理机系统中，故它仍然是当前多处理机系统中较常用的调度方式。 
       3.  只要系统中有任务，或者说只要公共就绪队列不空，就不会出现处理机空闲的情况，也不会发生处理器忙闲不均的现象，因而有利于提高处理器的利用率。

     +  自调度缺陷

       1.  瓶颈问题
       2.  低效性
       3.  线程频繁切换

  2.  成组调度方式

     在成组调度时，如何为应用程序分配处理器时间

     + 面向所有应用程序平均分配处理器时间

     + 面向所有线程平均分配处理器时间 

  3.  专用处理器分配

#### 产生死锁的原因和必要条件

+  产生死锁的原因
  1.  竞争资源
     +  可剥夺和非剥夺性资源
     +  竞争非剥夺性资源
     +  临时竞争资源
  2.  进程间推进顺序非法
+  产生死锁的必要条件
  1.  互斥条件
  2.  请求和保持条件
  3.  不剥夺条件
  4.  环路等待条件
+  处理死锁的必要条件
  1.  预防死锁
  2.  避免死锁
  3.  检测死锁
  4.  解除死锁

#### 预防死锁的方法

+  预防死锁

  1. 摈弃"请求和保持"条件
  2.  摒弃"不剥夺"条件
  3.  摈弃"环路等待"条件

+  系统安全状态

  1.  安全状态

     允许进程动态的申请资源,但是系统在分配资源之前,应先计算此次资源分配的安全性.若此次分配不会导致系统进入不安全状态,则将资源分配给进程.否则,令进程等待.

     所谓安全状态,使之系统能够按照某种顺心(P1,P2...Pn 这种称作为安全序列),为每个进程Pi分配其所需资源,直至满足每个进程对资源的最大需求.使得每个进程都可以顺利的完成.如果系统无法找到这样一个安全序列,则称系统处于**不安全状态**.

  2.  安全状态之例

     我们通过一个例子来说明安全性。假定系统中有三个进程P1、 P2和P3，共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在*T*0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，如下表所示：

     | 进程 | 最大需求 | 已分配 | 可以 |
     | ---- | -------- | ------ | ---- |
     | P1   | 10       | 5      | 3    |
     | P2   | 4        | 2      |      |
     | P3   | 9        | 2      |      |

  3.  由安全状态向不安全状态转换

     如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。

     例如，在*T*0时刻以后，P3又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。

     因为，此时也无法再找到一个安全序列， 例如，把其余的2台分配给P2，这样，在P2完成后只能释放出4台，既不能满足P1尚需5台的要求，也不能满足P3尚需6台的要求，致使它们都无法推进到完成，彼此都在等待对方释放资源，即陷入僵局，结果导致死锁。

+  利用银行家算法避免死锁

  1.  银行家算法中的数据结构

     +  可利用资源向量Available,这是一个含有m个元素的数组,其中每一个元素代表一类可利用资源数目.其初始值是系统中所配置的该类全部可使用资源数目.其数值随着该类资源的分配和回收动态的改变.如Available[ j ]= K,表示系统中现有Rj类资源K个.

     +  最大需求矩阵Max,这是一个n*m的矩阵,定义了n个进程中每个进程对m类资源最大需求.如果Max[i,j]=K.表示进程i需要Rj类资源最大数目为K.

     +  分配矩阵Allocation.n这个也是n*m矩阵,定义每一类资源当前已分配给进程的资源数.如果Allocation[i,j]=K,表示当前资源已经分配到Rj类资源K个.

     +  需求矩阵Need,这也是一个n*m矩阵,用以表示一个进程尚需各类资源数量.如果Need[i,j]=K,表示当前进程i需要Rj类进程K个

       Need［i,j］=Max［i,j］-Allocation［i,j］ 

  2.  银行家算法

     设Request是进程Pi的请求向量.如果Request[ j ] = K,表示进程Pi需要K个Rj类型资源.当Pi发出资源请求之后,系统按照如下步骤进行检查:

     1. Requesti［j］≤Need［i,j］，便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。

     2.  如果Requesti［j］≤Available［j］，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。 

     3.  系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：

        ```markdown
          Available［j］∶=Available［j］-Requesti［j］;
          Allocation［i,j］∶=Allocation［i,j］+Requesti［j］;
          Need［i,j］∶=Need［i,j］-Requesti［j］;
        ```

     4.  系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。

  3.  安全性算法

     1.  设置两个向量: 

        +  工作向量Work: 表示系统可以提供进程继续允许的各类资源数目,包含有m个元素,算法执行开始时,Work:=Available
        +  Finish: 可以分配标记,表示是否由足够资源分配给进程,使之运行完成.开始时令Finish[ i ] :=false,当由足够资源分配时,Finish[i]=true

     2.  从进程集合中找到一个能满足下述条件的进程： 

        +  Finish［i］=false
        + Finish［i］=false

        如果找到了,执行3,否则执行4.

     3.  当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：

        ```markdown
        Work［j］∶=Work［i］+Allocation［i,j］;
        Finish［i］∶=true;
        go to step 2; 
        ```

     4.  如果所有进程的Finish［i］=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 

#### 死锁的检测和解除

+  死锁的检测

  1.  资源分配图
  2.  死锁定理

+ 死锁检测中的数据结构

  1.  可利用资源相邻Available,代表了m类资源中每一类资源的可使用数目.

  2.  把不占用资源的进程(Allocation:=0)记录表L中,即Li or L

  3.  从进程集合中找到一个Request<=Work进程,做如下处理: 

     1.  将其资源分配图简化,释放出资源,增加工作向量

        Work:=Work+Allocation

     2.  将它计入表L中

  4.  若不能把所有进程都计入到L中,说明系统中资源分配图不可以被完全简化.因此系统将会发送死锁:

     ```markdown
     Work :=Available
     L:= {Li|Allocationi=0∩Requesti=0}
     for all Request not belong to L do
     	begin
     		Work:=Work+Allocation
     		Li= Li or L;
     	end
     end
     deadlock:=(L={p1, p2, …, pn}); 
     ```

+  死锁的解除

  1.  剥夺资源
  2.  撤销进程

  把系统从死锁状态中解脱出来,所花费代价可以表示为:

  R(S)min=min{Cui}+min{Cuj}+min{Cuk}+… 

