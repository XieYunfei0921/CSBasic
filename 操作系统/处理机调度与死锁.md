#### **处理机调度与死锁**

---

1.  [处理机调度的基本概念](# 处理机调度的基本概念)
2.  [调度算法](# 调度算法)
3.  [实时调度](# 实时调度)
4.  [多处理机中的调度](# 多处理机中的调度)
5.  [产生死锁的原因和必要条件](# 产生死锁的原因和必要条件)
6.  [预防死锁的方法](# 预防死锁的方法)
7.  [死锁的检测和解除](# 死锁的检测和解除)

---

#### 处理机调度的基本概念

1.  高级/中级/低级调度

   + 高级调度

     每次执行作业调度时，必须做出如下两个决定:

     - 接纳多少个作业
     - 接纳哪些作业

   + 中级调度

     引入中级调度的主要目的，是为了提高内存利用率和系统吞吐量。因此，应当使那些暂时不能运行的进程不再占有宝贵的内存资源。而将它们调到外存上,此时进程状态称为**就绪驻外存状态**或**挂起状态**。这些进程有重新具备运行条件，且内存用足够空闲时。使用中级调度决定外存上那些具备运行条件的就绪进程进入，重新调入内存。并修改其状态为就绪状态，挂在就绪队列上等待进程调度。

   + 低级调度

     低级调度分为两种情况

     1.  非抢占式调用

        引起进程调度的因素

        +  正在执行的进程执行完毕，或因某时间不能继续执行
        +  执行中因为IO请求暂停执行
        +  在通信/同步过程中执行某种原语，如P操作(wait操作),Block原语,Wakeup原语。

        这种方式优点是实现简单，系统开销小，适用于大多数批处理系统环境。但是难以满足紧急任务需求(立即执行)。显然·在要求比较严格的实时系统中，不适合采用这个调度方法。

     2.  抢占式调用

        +  优先权原则
        +  短作业(进程)优先原则
        +  时间片原则

2.  调度队列模型

   + 仅有进程调度的调度队列模型

     <img src="E:\截图文件\仅有进程调度的调度队列模型.png" style="zoom:67%;" />

   +  具有高级和低级调度的调度队列模型

     <img src="E:\截图文件\高低级别的调度队列.png" style="zoom:67%;" />

   + 具备三级调度的调度队列模型
   
   
        <img src="E:\截图文件\三级调度.png" style="zoom:60%;" />  
   
3. 选择调度方式和调度算法的准则

   +  面向用户的准则
     1.  周转时间短
     2.  响应时间块
     3.  截止时间的保证
   +  面向系统的准则
     1.  系统吞吐量高
     2.  处理机利用率好
     3.  各类资源平衡利用

#### 调度算法

1. 先来先去服务调度算法(FCFS)

   调度时间线

   <img src="E:\截图文件\FCFS.png" style="zoom:67%;" />

2. 短作业优先调度算法

   ​		短作业优先调度算法SJF，是指短作业或短进程优先调度算法。可以用于作业调度和进程调度。调度算法从后备队列中选择一个或者多个估计运行时间最短的作业，将它们调入内存。

   ​		而短进程调度算法(SPF),是从接续队列中估算出最短运行时间的进行，将处理机分配给他们。使它一直执行到完成，或发生某实现被阻塞，进而重新调度。

   ​	SJ(P)F算法的缺陷:

   1. 对长作业算法不利，会导致长作业长时间不被调度

   	2. 算法没有考虑到作业的紧急程度，不能保证紧迫性作业会被及时处理
    	3. 由于作业长短时根据用户提供的执行时间决定的，所以不一定做到真正的短作业优先调度。 

3. 高优先权优先调度算法

   + 优先权调度算法

     1.  非抢占式优先权算法

        ​		这种方式下，一旦系统把处理机分配给就绪队列中优先级最高的进程后。该进程边一直执行下去，直至完成。或因发生某事件使进程放弃处理机时,系统可将处理机重新分配给另一优先权最高的进程。这种调度算法适用于批处理系统中，也可以使用在实时性要求不高的实时系统中。

     2.  抢占式优先权调度算法

        ​		在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。

        ​	即每当系统中出现一个新的就绪进程i时，就将其优先权Pi与正在执行的进程j的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi＞Pj,则立即停止Pj的执行，做进程切换，使i进程投入执行。

        ​	这种抢占式的优先权调度算法，能更好的满足紧迫作用的要求，适用于要求严格的实时系统中或要求较高的批处理和分时系统中。

   +  优先权类型

     1.  静态优先权

        静态优先权是创建进程时确定的，且在进程运行期间一直不变。优先权一般使用某一返回内的一个整数来表示。比如0-7 或0-255，0表示最高优先权。

     2.  动态优先权

        动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。

        +  解决FCFS长期不调用问题

        ​		例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率a提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即FCFS算法。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。

        +  防止垄断

        ​		当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。

   +  高响应比优先调度算法

     优先权=(等待时间+ 要求服务时间)/要求服务时间=响应时间/要求服务时间

     1.  如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。
     2.  当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。
     3.  对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高， 从而也可获得处理机。

4. 基于时间片的轮转调度算法

   +  时间片轮转法

     ​		在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则，排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片的处理机执行时间。

   +  多级反馈队列调度算法

     1. 设置对个就绪队列，每个队列赋予不同的优先级。第一个队列优先级最高，其他队列优先级按照队列编号依次降低。算法服务各个队列执行时间片大小也不相同，优先级越高,规定的执行时间片越小。
     2.  当一个新的进程进入内存后，首先将其放入到第一个队列的某位，按照FCFS原则进程排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列中便采取按时间片轮转的方式运行。
     3.  仅当第一队列空闲时，调度程序才调度第二队列中的进程运行； 仅当第1~(i-1) 队列均空时，才会调度第i队列中的进程运行。

     <img src="E:\截图文件\多级反馈.png" style="zoom:67%;" />

   +   多级反馈队列调度算法性能

     1.  终端型作业用户
     2.  短批处理作业用户
     3.  长批处理作业用户

#### 实时调度

#### 多处理机中的调度

#### 产生死锁的原因和必要条件

#### 预防死锁的方法

#### 死锁的检测和解除

