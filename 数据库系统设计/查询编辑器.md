#### 引言

数据库的查询编译器需要包含如下三个部分:

1. 撰写SQL语言的语法分析器, 将查询语言转化为语法树
2. 将语法树转化为关系代数表达式树,这个叫做**逻辑查询计划**
3. 逻辑查询计划需要转化为**物理查询计划**, 物理查询计划不仅仅需要指明需进行的操作, 而且需要明确操作的顺序, 执行的算法以及数据的存储方式等等.

逻辑查询计划的选择具有许多种方式,需要挑选出最佳的逻辑查询计划.这里需要依照不同的**代数定律**.

逻辑查询计划生产物理查询计划的时候,必须预估出每个可能选择的代价.**代价预估**则是一个需要解决的问题.

#### 语法分析与预处理

语法分析是接受类似SQL文本,并将其转化为**语法分析树**. 该树的节点对应于以下两者之一:

1.  原子

   这个是词法部分, 例如`SELECT`. 关系属性的名字, 常数, 括号, 运算符, 以及其他模式成分.

2.  语法类

   一个查询中起到相似作用的子成分所形成族的名称. 用尖括号将描述性的名称括起来表示**语法类**. 

   例如:

   `<Query>`表示常用`select from where`形式的查询.

   `<Condition>`用于表示属于条件的任何表达式.如: `SQL`中在`where`之后的表达式部分.

如果一个结点是一个原子,则其没有子结点. 如果是一个语法类, 则其子节点通过这种表达式进行连接.

如何设计一个语言的语法,以及如何进行语法分析,如何将查询语句转换为`AST`.这些内容属于编译的部分.

##### `SQL`一个简单子集的语法

语法类`<Query>`用于表示`SQL`查询语句. 下面给出一条规则:

`<Query>::= SELECT <SelectList> FROM <FromList> WHERE <Condition>`

这条规则不包含接受多种可选的子句,例如`ORDER BY`,`HAVING`,`GROUP BY`也不接受`DISTINCT`以及`UNION`,`JOIN`等二元操作符.

###### 选择列表的构成

`<SelectList> ::=<Attribute>,<SelectList>` 或者`<SelectList>::=<Attribute>`

上述规则说明:

​	要么是单个属性,要么是一个属性,一个逗号外加多个属性.

​	在完整的`SQL`语法中还需要可以接受**表达式**和**聚集函数**以及**属性和表达式别名**的规则.

###### `From`列表的构成

`<FromList>::=<Relation>,<FromList>`或者`<FromList>::= <Relation>`

`<FromList>`可以由任意逗号分割的关系列表组成. 为了简便起见, 省略了`from`列表可以是表达式的可能性.例如**连接**或者**子查询**. 完整的`SQL`语法中应当允许关系的元组变量.

###### `Condition`条件语句构成

常用规则

| 表达式                                      | 名称     |
| ------------------------------------------- | -------- |
| `<Condition>::=<Condition> And Condition`   | 与       |
| `<Condition>::=<Attribute> IN (<Query>)`    | `in`查询 |
| `<Condition>::=<Attribute>=<Attribute>`     | 等值判断 |
| `<Condition>::=<Attribute> like <Patttern>` | 模式匹配 |

上述描述并不完全,缺少`OR`,`NOT`,`EXISTS`.除了等值比较和模式匹配之外,还有大量的比较运算符`<`,`>`,`>=`,`<=`,`<>`等等.这些完整的SQL语句中都是要包括的.

###### 基本语法类

语法类`<Attribute>`,`<Relation>`,`<Pattern>`这三个是比较特殊的. 它们不是通过语法规则定义的, 而是通过他们所代表原子的规则来定义的.

例如,在语法分析树中, `<Attribute>`的一个子类可以是任意的字符串,该字符串表示当前数据库模式的属性. 类似的`<Relation>`可以由任意表示关系的字符串代替. `<Pattern>`是任意一个引号表达的字符串,该字符串是一个合法的`SQL`匹配模式.

##### 预处理器

预处理器有多个重要的功能.

例如,如果查询语句中用到了虚视图,列表中用到这个关系的地方(`from`后边),则需要将关系使用语法树进行替换. 这个语法树由视图的定义中得到, 其本质上变成一个查询语句.

预处理器也负责**语义检查**. 即使是查询语法上有效, 但是实际上可能违反了一个或者多个语义规则. 预处理器必须进行如下工作:

+ **检查关系的使用:** `From`子句的关系必须是当前模式的关系或者视图

+ **检查与解析属性的使用: **在`SELECT`子句或者`WHERE`子句中提到的每个属性必须是当前范围中某个关系的属性.预处理器具有二义性,如果拥有多个属性在范围内,则报错.

+ **类型检查: **所有属性必须与其使用相互适应

  例如: 对日期型数据的处理,要求对于的值可以转化为日期类型,在`SQL`中日期型通常为字符串.需要转化合法.同样的, 算是运算也需要符合.

##### 预处理器涉及到视图的查询

当查询中一个对象是一个虚视图, 预处理器需要将其替换为对应描述的语法树.

如图所示:

<img src="E:\截图文件\Snipaste_2021-01-17_22-03-54.png" style="zoom:67%;" />

查询Q中由V和W两个视图,找到V和W的定义,发现V和W也是一个查询.将其使用**关系代数**或者**语法树**进行表示.

这样只需要对V和W的部分进行替换即可.

例如:

```sql
create view ParamountMovie as
	select 
		`title`,
		`year`
	from 
		Movies
	where 
		studioNames='Paramount'
;

select 
	title
from
	ParamountMovie
where
	`year`=1979
;
```

会被替换成:

```sql
select 
	title
from
(
	select 
		`title`,
		`year`
	from 
		Movies
	where 
		studioNames='Paramount'
)
where
	`year`=1979
;
```

#### 改进查询计划的代数定律

将语法树转化为表达式之后,该表达式由扩充关系代数运算符组成. 这里介绍一些代数定律, 用于将表达式树转化为一个等价的表达式树. 其中后者表达式树的物理执行计划更加有效.

应用这些代数变换式的结果是**逻辑查询计划**.它是查询重写阶段的输出.

###### 交换律和结合律

###### 涉及选择的定律

###### 下推选择

###### 涉及投影的选择

###### 有关连接和积的选择

###### 有关消除重复的选择

###### 涉及分组和聚集的选择



#### 语法分析树到逻辑查询计划的转换



#### 代价预估



#### 代价计划选择



#### 连接顺序的选择



#### 物理计划选择的完成

