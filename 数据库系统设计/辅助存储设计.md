#### 存储器层次

1. 高速缓存

   一个典型的计算机有1M或者更多的高速缓存。

   分为

   + 版级高速缓存

     位于微处理器本身同一个芯片上的

   + 二级高速缓存

     与微处理器不在同一个芯片上

   访问平均时间为几纳秒

2. 主存储器

   平均访问时间为10-100ns

3. 辅助存储器

   磁盘和主存传送一个字节的时间在10ms左右,但是一次可以传送多个字节.

4. 第三级存储器

   用于处理PT级别读写容量.

#### 易丢失和非易丢失存储

易丢失存储(RAM)在切断电源的时候数据会丢失.非易丢失(ROM)在切断电源时不容易丢失.在DBMS中,即使是发生了错误,仍然能够保存数据.

原则上来说,三级存储和辅助存储都是非易丢失的,但是在DBMS中,数据库的任何修改都不能认为是最终有效的,直到该修改被存储到非易失存储中.

#### 虚拟存储器

操作系统管理虚拟存储器,使其一部分留在主存中,另一部分保留着磁盘上.内存和磁盘间的数据以数据块(页)的形式进行传送.

虚拟存储作用于磁盘和主存之间,不属于存储系统中.

#### 磁盘

大多数情况下辅助存储用的都是磁盘.

1. 磁盘的结构

   磁盘驱动器拥有两个重要的组件,一个是磁盘组合,另一个是磁头组合.磁盘组合由一个或者多个圆盘组成,围绕一个主轴进行旋转.

   磁盘组成磁道,磁道是单个盘片上的同心圆.半径相同的磁道构成柱面.

   磁道被组织成扇区.扇区又被间隙分割.扇区是读写的最小单位.

2. 磁盘存取特性

   存取一个磁盘块需要三个步骤,每一步都有延迟

   1. 磁盘控制器寻找磁道所在柱面的时间,即**寻道时间**
   2. 磁盘控制器等待访问第一个扇区旋转到磁头下.称为**旋转时间**.
   3. 当磁盘控制器读取或者写出数据时, 数据所在扇区和扇空间的空隙经过磁头时候,称为**传输时间**.

#### 辅存访问加速方法

1. 计算的IO模型

2. 按柱面进行组织

   如果我们选择单个磁道或者一个柱面上连续读取所有块,那么只需要考虑第一次寻道时间即可.

3. 使用多个磁盘

   如果使用多个磁盘,只要磁盘控制器,总线和主存储器以n倍速率进行数据处理.则n个磁盘的效果近似于一个磁盘执行了n次操作.

4. 磁盘镜像

   某些情况下,两个或者更多磁盘保留有相同的数据副本是有意义的.这些磁盘称作相互镜像.可增强设计的可靠性.

5. 磁盘调度算法

   让磁盘调度器进行控制选择合适的调度算法,对大量块请求进行调度.

6.  预先取和大规模缓冲

   预先取,有时也称为**双缓冲**. 一些应用中, 能够预先获取磁盘请求块的顺序. 如果这样, 就能在需要这些块之前将其调入主存. 得知请求顺序可以利用磁盘调度算法, 减少访问的平均时间.



#### 磁盘故障以及防御措施

> **间歇性故障: **读取或者写入一个扇区没有成功,但是经常反复尝试又能成功读写.
>
> **介质损坏: ** 故障一个或者多个二进制位永久损坏,无论尝试多少次,正确地读取一个扇区都是不可能的.
>
> **写中断: ** 当我们企图写入一个扇区,既不能正确的写, 也不能成功的检索之前的扇区.可能是写扇区的过程中发生了供电中断.
>
> **磁盘崩溃: ** 整个磁盘都不可读

##### 间歇性故障

> **读取**

​		读取时读到坏数据块，只需要反复的读取，直到到成功的扇区为止，如果一直失败，可以设置一个上限值。达到上限值时再停止。

> **写入**

​		写入失败，只有选择磁盘到扇区的开头并进行写入。判断写入正确与否的方法就是读取这个扇区，并与样本做对比。如果一致则表示写入正确。

> **校验和**
>
> 1. 奇偶校验法
> 2. CRC校验法

> **稳定性存储**

​		考虑下面这种情况，现在正准备将小的增量添加到账目余额中去, 现在新的余额和旧的余额已经丢失. 如果可以确信扇区里面不是新的余额就是旧的余额. 那么只需要判定写操作是否成功即可.

​		通常是将磁盘的扇区成对分配,每一对代表一个扇区内容X.分别称两个扇区为XL和XR.使用足够多的奇偶校验位保证坏扇区的可能性.如果XL或者XR读取返回了一个好值w.则w是X的真实值.

​		过程为:

+ 写X的内容到XL，检查返回值是否为好(校验位是正确的).如果不是好则反复的写,直到达到指定次数之后认定为介质故障.采取备用扇区进行替代.
+ 对XR进行上述操作.

稳定存储策略是交替尝试读取XL和XR直到返回一个好值.只有多次尝试之后才可认定X不可读.

> **稳定存储的错误处理能力**

+ **介质故障**

  只有当XL和XR都不可读取的时候,才会认定X坏了.

+ **写故障**

  写入X的时候由于电源断电,可能会出现扇区内一般是新值一般是旧值的情况.系统可用的时候,测试XL和XR.确定能够决定X的新值和旧值.可能会出现下面两种情况.

  1. 故障在写XL时发生,由于没有写过XR.则可以从XR中恢复数据到XL.修复XL的故障.
  2. 故障在写入XL之后发生. 那么预计XR状态为好. 并且将XL的数据复制到XR中.(不知道XR的状态).

##### 磁盘崩溃恢复以及冗余策略

| 名称  | 功能                                                         |
| ----- | ------------------------------------------------------------ |
| RAID1 | 有一半的磁盘作为备份使用,主备同时写入. 可靠性好,空间利用率低. |
| RAID2 |                                                              |
| RAID3 | 选取一块盘作为校验盘,其他盘按照RAID0策略写入,其中一块坏掉时,使用校验码还原原来的数据.<br />但是校验盘的可靠性需要得到保证 |
| RAID4 |                                                              |
| RAID5 | 与RAID3类似,但是校验码分布在各个磁盘中,属于分布式校验盘.最多允许一个坏盘(校验算法决定的) |
| RAID6 | 在RAID5基础上,多一块校验盘,这样可以校验出两个坏盘.           |
| RAID0 | 无备份，写入速度块，可靠性差                                 |

#### 磁盘上记录的组织方式

> **定长记录**

​		记录以**记录首部**开始，首部是记录自身信息的一个定长部分。包括如下信息:

+ 指向记录中**存储数据的模式**的指针。

  例如，一个元组的记录可以指向该元组所属的关系模式，此信息可以让我们找到记录的字段。

+ **记录长度**

+ **时间戳信息**

  用于数据库事务处理

+ 指向**记录字段**的指针

  可以代替模式信息，在非定长记录中比较有用。

例如:

```sql
create table MovieStar{
	name char(30) primary key,
	address varchar(300),
	gender char(1),
	birthdate date
};
```

这里假定系统的对齐的偏移量为4字节

则存储分布如下

<img src="E:\截图文件\存储分布.png" style="zoom:67%;" />

这样来说一条记录占有316个字节。

> **定长记录在数据块中的存储**

数据块的存储结构如下:

<img src="E:\截图文件\Snipaste_2021-01-10_22-07-20.png" style="zoom:67%;" />

处理多条记录之外，还有一个可选的**块首部**信息：

+ 与一个或者多个块相连,组成一个块网络
+ 这个数据块在网络中扮演的角色信息
+ 这个块的元组属于哪个关系的信息
+ 一个给出每条记录在块内偏移量的目录
+ 指明最后一次修改的时间或者存取的时间

#### 块和记录地址的表示

首先明确,**块地址**是块首个字节的虚拟内存地址, 记录地址时记录首个字节虚拟内存地址. 但是在二级存储中并不是如此.

事实上,有一个字节序列描述块在DBMS上系统的地址.例如,磁盘设备ID,柱面号等.

##### CS模式中的地址

数据库系统中,通常包括一个服务器进程,为一个或者多个客户端进程提供二级存储器数据.

客户端是使用数据的应用,服务器和客户端是工作在一个机器上的. 或者服务器和一些客户端可以分布在多个机器上.

> 客户端应用使用虚拟地址进行管理,通常为32位地址,可以寻址40亿.
>
> OS或者DBMS决定地址空间哪些部分在内存中,硬件将虚拟地址映射到主存的物理地址上.

服务器的数据位于**数据库地址空间**. 空间中的地址(namespace)涉及到数据块和块内偏移量.地址空间中表示地址的方法主要包括:

> **物理地址**

​		物理地址是一个字符串，据此可以确定二级存储中数据块或者记录的位置。下面的信息使用物理地址的一个或者多个字节进行指明。

+ 存储所连接的主机(如果不只一台主机)
+ 块所在磁盘或者其他存储设备的设备标识符号
+ 磁盘的柱面号
+ 柱面内部的磁道号
+ 磁道内部的块号
+ 记录的块内偏移量

> **逻辑地址**

​	每个记录或者数据块都有一个逻辑地址，是一个具有固定长度的字符串。存储在磁盘上一个已知地方的映射表将逻辑地址和物理地址联系起来.

如果需要存储大量的数据,物理地址的长度必须要足够长,才能支持寻址.或者是使用多级存储进行在相等长度下的扩容.

##### 逻辑地址和结构地址

逻辑地址和物理地址组合是多样的,得到的是结构化地址.一个相似又非常有用的方式的物理和逻辑地址组合方式*在每一个数据块内维护一个记录的偏移量表*.这种策略在**变长记录**是很有效的.

这样算起来,**记录的地址**=**数据块的物理地址**+**记录在数据块内部的偏移量**.

现在来讨论一下关于数据的增删的操作:

1. **移动记录**：修改记录的指向,保证仍然能够搜索到这条记录
2. 偏移表如果足够大,存储这条地址的新地址即可
3. 如果记录被删除，则在偏移量表中标记为**删除**即可, 记录删除之后, 需要沿着这条记录的指针,寻找相关的引用. 将相关位置设置为空指针, 或者是将该位置标记为不可用(推荐).

##### 指针混写

对象关系数据库允许指针类型的使用, 因此, 即使是关系存储也要考虑元组中表示指针. 此外, 索引结构内部有指针的块组成, 所以必须要考虑到数据块在主存和二级存储器中移动时指针的管理.

每一个数据块,记录,对象等可以引用的数据,都有两种地址形式:

​	数据库空间中的**数据库地址**和**内存地址**. 如果数据被拷贝到内存中则使用内存地址. 如果在二级存储中,则必须要使用数据库地址.

​	内存中的数据,使用两种寻址方式都可以找到,因此使用内存地址的效率会更好,只需要一条机器指令即可.

​	相反,使用数据库地址就会比较麻烦, 首先需要维护一个映射表, 将所有数据库地址转换为当前的内存地址. 数据库中所有可以访问的数据项在映射表中都有记录, 而转换表只记载当前内存中的数据项.

​	为了避免重复地将数据库地址转化为内存地址开销,提供**指针混写**的方式进行处理.总体思路是: *把二级存储器转移到主存的时候,块内指针可以混写,即从数据库地址转换到虚拟地址空间.*

​	因此,一个指针实际上包括:

+ 一个二进制位, 用来表示是数据库地址还是内存地址
+ 数据库或者内存地址指针,注: 内存地址的位数比数据库地址的位数要短.

下面介绍混写的几种方式:

1. 自动混写

   一旦数据块进入主存，则对其所有的指针和地址进行定位。如果它的指针和地址不在转换表中，将其注册到转换表中。如果这些指针和地址有来自其他地方的引用，并且可以访问到，则需要对这些引用进行处理。

   + 如果块存储的模式确定，那么可以通过模式确定记录的指针。
   + 如果块用于索引结构，那么数据块的指针在索引位置处
   + 在数据块首部维护一个记录指针列表

2. 按需混写

   ​	第一次进入主存的时候不进行混写，只将地址和指针信息一起存入到转换表中.按需混写是考虑到一些指针可能从来不会被使用,将其混写会造成时间上的开销.

   ​	那么当指针没有被混写的时候,访问这个内存空间会产生硬件陷阱,此时使用事件驱动的方式,在此触发DBMS设计的函数,按照上述的方式对指针进行混写,这个时候仅仅当遇到硬件陷阱的时候,才会进行混写的耗时操作.

3. 不混写

   不混写,仅仅注册转换表,使得指针按照未混写的方式进行追踪.

> **混写程序控制**

​	应用程序员可以显示地指明装入主存的指针会被混写(事件驱动). 也可以在需要请求的时候进行混写. 例如如果是经常使用的数据建议要混写,而仅仅进入一次的数据,则不需要进行混写.

##### 块返回磁盘

当数据块从主存移动回到磁盘的时候, 必须对数据块中的指针进行混写.它们的内存地址必须使用数据库地址进行代替.转换表可以用于两种类型的表的双向联系.即相互映射(两份散列表).

##### 被钉住的数据块

如果一个数据块不安全的返回到磁盘中,则称作数据块为不安全的.在块首部需要维护一个二进制位.

举个例子:

数据块B1中的某个记录混写到B2中的某条记录,如果B2被回收,那么需要注意B1记录中的指针可能悬空.因此在B2撤出主存之前,需要解混写所有相关引用.

这里提供两种措施:

+ 将相关引用以链表的形式存储起来,映射到转换表中(推荐)

  <img src="E:\截图文件\Snipaste_2021-01-10_23-52-32.png" style="zoom:67%;" />

+ 如果内存地址比数据库地址短许多,可以在指针内部维护一个链表进行处理

#### 变长数据和记录



#### 记录的修改

