### 主体解决方案

#### 离线解决方案:

1. 交由对应的执行引擎解决

   例如: `HiveSql`交给Hive,`SparkSQL` 交给`Spark`解决.`FlinkSQL`交给`Flink`解决等等

   考虑系统的扩展性,需要留给其他Sql执行引擎的扩展空间

   优点: 不需要手动造轮子,直接使用引擎解决. 可用放心依赖各个引擎的处理结构.

   缺点: 需要调研各个引擎`sql`解析的方案,编码时需要考虑扩展性.不能大量使用硬代码.

2. 自行解析sql处理依赖关系

   使用`calcite,antlr`之类的工具,解析sql.

   优点: 具有通用性,不会强行依赖某个引擎

   缺点: 写出的解析方案需要经过大量测试才能投入使用.

#### 表血缘关系处理

##### 表血缘关系数据存储设计

1. 类型选型

   + 关系存储 `MySQL`
   + 文档存储 `MongoDB`

   > **分析**:
   >
   > 血缘关系 是由 子数据表和数据表唯一确定,所以选用关系型数据存储
   >
   > 特别地考虑打A->B,B->A 这样地循环依赖,则应当检测出来并告警.应为再数仓分层中指出了将上一级表导入到下一层是不合适地. 应当给与警告.
   >
   > 其次, 需要提供热点表地查询功能,需要统计表作为子表/父表地访问次数. 

##### 表血缘关系缓存设计

 1. 选型

    `Redis`

	2.  键值对设计

    为了和关系型数据库配合使用,需要使用连字符将关系型数据库字段连接起来,特别地考虑到redis存储字符串有上限设置. 需要对长的字段进行唯一处理(`MD5`).

#### 字段投影关系映射

​	由父表中元素映射到子表中, 父级字段可能有多个. 需要记录所有字段到子字段投影关系.

​	过程中分为如下四种类型地投影关系:

1. 简单投影

   父字段与子字段一对一关系,且类型相同(名称可不同)

2. 复杂投影

   父字段有多个,子字段一个,由父字段组成子字段(使用简单计算方式)

3. 函数投影

   使用函数方式进行子字段投影

4. 复合投影

   投影表达式为子查询	

其中1,2,3 为直接投影,4为间接投影,间接投影需要加设临时表将其转换为直接投影处理

#### 血缘关系语义化

1. 建立投影表达式地语料库
2. 解析投影表达式,将其翻译为对应语义表达式